#+TITLE: Python
#+AUTHOR: DarkSun
#+EMAIL: lujun9972@gmail.com
#+OPTIONS: H3 num:nil toc:nil \n:nil ::t |:t ^:nil -:nil f:t *:t <:t

* 语法
** 序列
*** 分片操作
    "abcdefg"[1:3]      #=[bc]
*** 序列可以通过+合并，或*重复
    s="abc"
    print s+"123"       #="abc123"
    print s*2           #="abcabc"
** 列表
*** 列表是序列的一种，它可以被改变
*** 列表与数组类似，但列表没有固定类型的约束
*** 
** 类

1. python类支持多重继承

   当从多个基类继承同名方法时,先继承的类中的方法会覆盖后继承类的方法.

2. 可以将对象中的原本方法,绑定到一个函数
   #+BEGIN_SRC python
     class Class:
         def method(self):
             print("I have a self")

     def function():
         print("I don't have self")

     instance = Class()

     instance.method()               # I have a self

     instance.method=function
     instance.method()               # I don't have self
   #+END_SRC

3. 也可以将一个对象的方法绑定到一个变量上
   #+BEGIN_SRC python
     class Bird(object):
         def __init__(self,song):
             self.song = song

         def sing(self):
             print(self.song)

     bird = Bird("Squaawk!")

     birdsong = bird.sing
     birdsong()                      # Squaawk!
   #+END_SRC

4. python并不直接支持私有方式,而是通过修改以__开头的成员名称的方式间接实现.

   在类的内部定义中,所有以双下划线开始的名称都被翻译成前面加上单下划线和类名称的形式.

   如类Secretive中名为 ~__inaccessible~ 的名称被翻译成 ~_Secretive__inaccessible~
*** 实例属性与类属性
1. 类定义之后,可以通过类名动态添加类数据属性. 实例生成之后,也可以动态添加实例的属性.
   #+BEGIN_SRC python
     class ClsA:
         pass

     ClsA.cls_attr = "attr"

     a = ClsA()
     print(a.cls_attr)               # attr

     b = ClsA()
     print(b.cls_attr)               # attr

     a.obj_attr = "attr"
     print(a.obj_attr)               # attr
   #+END_SRC
   
   借助 =types.MethodType= 甚至可以給实例动态绑定一个方法
   #+BEGIN_SRC python
     class People(object):
         def __init__(self,name,age):
             self.name = name
             self.age = age

     p1 = People("p1",20)

     def set_age(self,age):
         self.age = age

     import types
     p1.set_age = types.MethodType(set_age,p1)

     print(p1.age)
     p1.set_age(25)
     print(p1.age)

   #+END_SRC

   #+RESULTS:
   : 
   : 20
   : 25

   
   但是,給一个实例绑定的方法,对另一个实例不起作用
   #+BEGIN_SRC python
     p2 = People("p2",20)
     p2.age
     p2.set_age(25)
   #+END_SRC

   #+RESULTS:
   : 
   : 20
   : Traceback (most recent call last):
   :   File "<stdin>", line 1, in <module>
   : AttributeError: 'People' object has no attribute 'set_age'

2. 所有在类中定义的函数或变量都处于类命名空间内，即为类所属的成员
   #+BEGIN_SRC python
     class MemberCounter:
         members=0
         def __init__(self):
             MemberCounter.members += 1

     m1 = MemberCounter()
     print (MemberCounter.members)

     m2 = MemberCounter()
     print (MemberCounter.members)
   #+END_SRC
   上面的members即为类MemberCounter的成员变量。

   当然,由于类也是对象,因此你也可以动态修改类成员
   #+BEGIN_SRC python
     class Cls(object):
         attr1 = "a"

     Cls.attr1
     c = Cls()
     c.attr1
     Cls.attr2 = "b"
     c.attr2
   #+END_SRC

   #+RESULTS:
   : >>> 'a'
   : >>> 'a'
   : >>> 'b'

   当然,若使用 =types.MethodType= 給类绑定方法,则所有对象均可调用
   #+BEGIN_SRC python
     def set_name(self,name):
         self.name = name

     People.set_name = types.MethodType(set_name,People)

     p1.set_name("people1")
     p1.name
     p2.set_name("people2")
     p2.name

   #+END_SRC

   #+RESULTS:
   : 
   : ... >>> >>> >>> >>> 'p1'
   : >>> 'p2'

*** 使用__slots__禁止动态添加属性
在Python中,每个类都有实例属性. 默认情况下Python用一个字典来保存一个对象的实例属性. 
*因此它允许我们在运行时去设置任意的新属性*.
然而,对于有着已知属性的小类来说,它可能是个瓶颈.这个字典浪费了很多内存.
Python不能在对象创建时直接分配一个固定量的内存来保存所有的属性.
因此如果你创建许多对象(我指的是成千上万个),它会消耗掉很多内存.

不过还是有一个方法来规避这个问题.这个方法需要使用 =__slots__= 来告诉Python不要使用字典，而只给一个固定集合的属性分配空间. 
下面是一个例子
#+BEGIN_SRC python
  class MyClass(object):
      __slots__ = ['name']
      def __init__(self,name):
          self.name = name

  my_object = MyClass("obj1")
  my_object.identifier = "identifier1"
#+END_SRC

#+RESULTS:
: 
: ... ... ... >>> >>> Traceback (most recent call last):
:   File "<stdin>", line 1, in <module>
: AttributeError: 'MyClass' object has no attribute 'identifier'

使用 =__slots__= 要注意,其只对当前类的实例其作用,而对继承的子类不起作用
#+BEGIN_SRC python
  class MySubClass(MyClass):
      pass

  my_sub_object = MySubClass("name")
  my_sub_object.id = 1
  my_sub_object.id
#+END_SRC

#+RESULTS:
: 
: 1

除非在子类也定义 =__slots__= ,这样子类实例允许定义的属性就是自身的 =__slots__= 加上父类的 =__slots__= 

*** 文档字符串

*** 调查继承

   + 如果想要查看一个类是否是另一个类的子类,可以使用内建的issubclass函数
     #+BEGIN_SRC python
       class Base:
           pass

       class Sub(Base):
           pass

       print(issubclass(Sub,Base))     # True
     #+END_SRC

   + 如果想要知道已知类的基类,可以使用类的 =__base__= 属性
     #+BEGIN_SRC python
       print (Sub.__base__)            # <class '__main__.Base'>
       print (Base.__base__)           # <class 'object'>
     #+END_SRC

   + 使用 =isinstance= 方法检查一个对象是否是一个类的实例
     #+BEGIN_SRC python
       s = Base()
       print (isinstance(s,object))    # True
       print (isinstance(s,Base))      # True
       print (isinstance(s,Sub))       # False
     #+END_SRC

   + =isinstance= 方法还能检查一个对象是否是 *某些* 类型中的一种
     #+BEGIN_SRC python
       isinstance([1,2,3],(list,tuple))
       isinstance((1,2,3),(list,tuple))
     #+END_SRC

     #+RESULTS:
     : True
     : True

   + 如果想知道一个对象是属于哪个类,可以使用对象的 =__class__= 属性
     #+BEGIN_SRC python
       s = Base()
       print (s.__class__)             # <class '__main__.Base'>
     #+END_SRC

     也可以使用type(对象)来查看对象的类
     #+BEGIN_SRC python
       print(type(s))                  # <class '__main__.Base'>
     #+END_SRC

*** 内省
   
   + 使用 ~hasattr~ 检查对象是否包含特定属性

     #+BEGIN_SRC python
       class Cls:
           def __init__(self):
               self.attr = 1
           
       obj = Cls()
       print(hasattr(obj,"__init__"))  # True
       print(hasattr(obj,"talk"))      # False
       print(hasattr(obj,"attr"))      # True
     #+END_SRC

     #+RESULTS:

   + 使用 ~getattr~ 可以获取对象中的属性
     #+BEGIN_SRC python
       print(getattr(obj,"attr",None)) # 1
       print(getattr(obj,"__init__",None)) # <bound method Cls.__init__ of <__main__.Cls object at 0x017782B0>>
       print(getattr(obj,"non-exist-attr",None)) # None
     #+END_SRC
     
     ~getattr~ 函数允许提供默认值,以便在特性不存在时使用.

   + 要判断一个属性到底是方法还是成员变量,可以检查该属性是否包含 ~__call__~ 属性
     #+BEGIN_SRC python
       attr = (getattr(obj,"attr",None))
       print(hasattr(attr,"__call__")) # false
       attr = getattr(obj,"__init__",None) 
       print(hasattr(attr,"__call__")) # True
     #+END_SRC

   + 若要设置对象中的属性,则使用 ~setattr~ 函数
     #+BEGIN_SRC python
       setattr(obj,"attr",100)
       print(obj.attr)                 # 100
       setattr(obj,"non_exist_attr",10)
       print(obj.non_exist_attr)                # 10
     #+END_SRC
     
     从上例可以看出, ~setattr~ 能够为对象设置以前不存在的属性

   + 若想查看对象内所有存储的值,可以使用对象的 ~__dict__~ 属性
     #+BEGIN_SRC python
       print(obj.__dict__)             # {'non_exist_attr': 10, 'attr2': 10, 'attr': 100}
     #+END_SRC

*** 类的特殊方法

**** 构造方法:__init__
当对象被创建后,会立即调用构造方法.
#+BEGIN_SRC python
  class Bird:
      def __init__(self,hungry=True):
          self.hungry = hungry
      def eat(self):
          if self.hungry:
              print("Aaaaah")
              self.hungry = False
          else:
              print("No. Thanks!")
#+END_SRC

一般来说,一个子类的构造方法中都需要调用父类的构造方法,否则对象很可能无法正确地初始化. 有两种方法能达到这个目的:

+ 调用超类构造方法的未绑定版本(不推荐)
  #+BEGIN_SRC python
    class SongBird(Bird):
        def __init__(self,hungry=True):
            Bird.__init__(self,hungry)     # 调用父类构造方法的未绑定版本
            self.sound = "Squawk!"

        def sing(self):
            print(self.sound)

    sb = SongBird()
    sb.sing()                       # "Squawk"
    sb.eat()                        # "Aaaah
    sb.eat()                        # No. thanks
  #+END_SRC

+ 使用super函数

  super函数接受一个类和对象作为参数,其返回的对象上的任何方法调用,都会调用到超类的方法而不是当前类的方法.
  #+BEGIN_SRC python
    class SongBird(Bird):
        def __init__(self,hungry=True):
            super(SongBird,self).__init__()
            self.sound = "Squawk!"

        def sing(self):
            print(self.sound)

    sb = SongBird()
    sb.sing()                       # "Squawk!"
    sb.eat()                        # "Aaaah"
    sb.eat()                        # No. thanks!
  #+END_SRC
  
  super函数能正确处理继承多个超类的情况,因此推荐使用

**** 析构方法:__del__
析构方法在对象被来及回收之前被调用,但由于调用的具体时间不可知,因此一般应避免__del__函数.

**** 实现为序列和映射的接口说明
若对象是不可变的，只需要实现前两个方法，若对象是可变的则需要实现全部的四个方法。

若使用的索引为非法类型,一般抛出TypeError异常, 若索引类型正确但超出范围,一般引发IndexError异常

在python中,甚至可以继承内置类型,例如list,string,dict

+ __len__(self)

  这个方法应该返回集合中所含项目的数量. 对于序列来说,这就是元素的个数,对于映射来说,则是键值对的数量.

  若__len__返回0,且没有重新实现__nonzero__,则该对象会被当作False
  
  若为无限序列,则可以不实现该函数
  
+ __getitem__(self,key)
  
  这个方法返回与所給键对应的值. 

  对序列来说,键一个整数. 对于序列来说,则可以是任意种类的键
  
  对于一个序列来说,如果能接受负整数的键,那么要从末尾开始计数,即x[-n] == x[len(x)-n]

  若对序列进行的是分片操作,则key会为一个 ~分片对象~. 

+ __setitem__(self,key,value)

  这个方法存储与key相关的value

+ __delitem__(self,key)
  
  这个方法在对一部分对象使用del语句时被删除,同时必须删除和元素相关的键.

  若没有实现__del__方法,则表示删除元素是非法的.

**** __getattribute__,__getattr__,__setattr__和__delattr__
+ __getattribute__(self,name) :: 当属性name被访问时自动调用,使用时请注意 *重复触发的情况*,因为访问__dict__也会触发该方法!
+ __getattr__(self,name) :: 当属性name被访问且对象 *没有相应属性时* 被自动调用
+ __setattr__(self,name,value) :: 当试图給属性name赋值时会自动调用,使用时请注意 *重复触发的情况*
+ __delattr__(self,name) :: 当试图删除属性name时被自动调用,若是非法的name,需抛出 *AttributeError异常*

可以使用这些方法来模拟propery函数的作用
#+BEGIN_SRC python
  class Rectangle:
      def __init__(self):
          self.width = 0
          self.height = 0
      def __setattr__(self,name,value):
          if name == "size":
              self.width,self,height = value
          else:
              self.__dict__[name] = value
      def __getattr__(self,name):
          if name == "size":
              return self,width,self,height
          else:
              raise AttributeError
#+END_SRC

**** 迭代器:__iter__
__iter__方法返回一个迭代器,所谓迭代器就是指具有__next__方法的对象.

当调用__next__方法时,迭代器会返回它的下一个值.

当__next__方法被调用,但迭代器没有值返回时,需要引发一个 ~StopIteration~ 异常.

#+BEGIN_SRC python
  class Fibs:
      def __init__(self):
          self.a = 0
          self.b = 1
      def __next__(self):
          self.a,self.b = self.b,self.a+self.b
          return self.a
      def __iter__(self):
          return self

  fibs = Fibs()
  for f in fibs:
      if f > 1000:
          print(f)
          break
#+END_SRC

实现了__iter__方法的对象被称为可迭代对象, 而实现了__next__方法的对象被称为迭代器,注意两者的区别

使用函数可以从可迭代对象中获取迭代器
#+BEGIN_SRC python
  it = iter([1,2,3])
  it.next()                       # 1
  it.next()                       # 2
#+END_SRC

*** Property
使用 ~property~ 函数可以创建一个并不实际存在的属性,其函数签名为 ~propery(fget=None,fset=None,fdel=None,doc=None)~. 其中

+ fget为获取属性的方法,若未设置则表示属性为不可读的
+ fset为设置属性的方法,若未设置则表示属性为不可写的
+ fdel为删除属性的方法(它无需参数),若为设置则表示属性为不可删除的.
+ doc为文档字符串.
#+BEGIN_SRC python
  class Rectangle:
      def __init__(self):
          self.width = 0
          self.height = 0
      def setSize(self,size):
          self.width,self.height = size
      def getSize(self):
          return self.width,self.height
      size = property(getSize,setSize)
#+END_SRC  

#+RESULTS:

上面的代码使用proerty函数为Rectangle创建了一个并不实际存在的属性:property. 然后可以像处理width,height一样处理size.
#+BEGIN_SRC python
  r = Rectangle()
  r.width = 10
  r.height = 5
  r.size                          # (10,5)

  r.size = 150,100
  r.width                         # 150
#+END_SRC

#+RESULTS:
: (10, 5)
: 10

 =property= 也可以作为装饰器来使用:
 #+BEGIN_SRC python
   class Student(object):
       @property
       def score(self):
           return self.__score
       @score.setter
       def score(self,value):      # 这个名字还是score!
           self.__score = value

   s = Student()
   s.score = 95
   s.score
 #+END_SRC

 #+RESULTS:
 : 
 : 95
 
=@property= 把一个getter方法变成属性，同时 =@property= 本身又创建了另一个装饰器 =@score.setter= ，负责把一个setter方法变成属性赋值.


*** 静态方法和类成员方法
静态方法与类成员方法不同点在于:

+ 静态方法的定义没有self参数,且能够被类本身直接调用.

  静态方法在创建时需要被封装到staticmethod类型的对象中

+ 类方法在定义时则需要名为cls的参数,其作用与self类似,表示类本身的引用.

  类成员方法可以被类的对象所调用.
  
  类成员方法在创建时需要被封装到classmethod类型的对象中.

#+BEGIN_SRC python
  class MyClass:
      def smeth():
          print("This is a static method")
      smeth = staticmethod(smeth)

      def cmeth(cls):
          print("This is a class method of",cls)
      cmeth = classmethod(smeth)
#+END_SRC

静态方法和类成员方法在python中用的比较少,因为一般情况下都能用函数或绑定方法来代替.

*** 抽象方法
抽象方法是定义在基类种可能有或者没有任何实现的方法。 通过Python内置的abc模块实现抽象方法，可以在试图实例化一个包含抽象方法的对象时得到警告提示。
#+BEGIN_SRC python
  import abc
  class BasePizza(metaclass=abc.ABCMeta):
      @abc.abstractmethod
      def get_radius(self):
          pass

  pizza = BasePizza()
#+END_SRC

支持在@abstractmethod之上使用@staticmethod和@classmethod装饰器：
#+BEGIN_SRC python
  import abc
  class BasePizza(metaclass=abc.ABCMeta):
      ingredients=['cheese']
      @classmethod
      @abc.abstractmethod
      def get_ingredients(cls):
          return cls.ingredients
#+END_SRC

*注意:* 在BasePizza中定义get_ingredients为类方法，并不能强迫其子类也将其定义为类方法。将其定义为静态方法也一样。
并没有什么方法可以强迫子类将抽象方法实现为某种特定类型的方法，甚至参数个数都可以不一样。 

*** 装饰器
装饰器的语法很简单,就是在方法或函数上方写上形如 ~@xxxx~,这里的xxxx可以是任意东西.

解析器会自动修改为 ~方法名 = xxxx(方法名)~ 这种格式.

可以指定多个装饰器, 多个装饰器的应用顺序与指定顺序相反. 例如
#+BEGIN_SRC python
  def m1(fn):
      print("m1")
      return fn
  def m2(fn):
      print("m2")
      return fn
  @m1
  @m2
  def fun1():
      print("fun1")

  fun1()
  # m2
  # m1
  # fun1

  def fun2():
      print("fun2")
  fun2 = m1(m2(fun2))
  fun2()
  # m2
  # m1
  # fun2
#+END_SRC

因此定义静态方法和类成员方法时也可以使用装饰器来简化代码
#+BEGIN_SRC python
  class MyClass:
      @staticmethod
      def smeth():
          print("This is a static method")

      @classmethod
      def cmeth(cls):
          print("This is a class method of ",cls)

  MyClass.smeth()                 # This is a static method
  MyClass.cmeth()                 # This is a class method of <class '__main__.MyClass'>
#+END_SRC

*** __slots__魔法
在Python中,每个类都有实例属性. 默认情况下Python用一个字典来保存一个对象的实例属性. 
*因此它允许我们在运行时去设置任意的新属性*.
然而,对于有着已知属性的小类来说,它可能是个瓶颈.这个字典浪费了很多内存.
Python不能在对象创建时直接分配一个固定量的内存来保存所有的属性.
因此如果你创建许多对象(我指的是成千上万个),它会消耗掉很多内存.

不过还是有一个方法来规避这个问题.这个方法需要使用 =__slots__= 来告诉Python不要使用字典，而只给一个固定集合的属性分配空间. 
下面是一个例子
#+BEGIN_SRC python
  class MyClass(object):
      __slots__ = ['name','identifier']
      def __init__(self,name,identifier):
          self.name = name
          self.identifier = identifier
#+END_SRC
** 元类
*** 使用type函数创建类
=type= 函数除了可以返回一个对象的类型外,还可以创建出新类型.即类对象.
要创建一个class对象,需要给 =type= 函数传递3个参数:
1. class的名称
2. 继承的父类集合,由于python支持多继承,因此需要写成元组的形式
3. class的方法名称与函数绑定

下面是一个例子:
#+BEGIN_SRC python
  def fn(self, name='world'): # 先定义函数
      print('Hello, %s.' % name)

  Hello = type('Hello', (object,), dict(hello=fn)) # 创建Hello class

  h = Hello()
  h.hello()
  print(type(Hello))
  print(type(h))
#+END_SRC

#+RESULTS:
: 
: Hello, world.
: <class 'type'>
: <class '__main__.Hello'>
*** metaclass控制类的创建行为
除了使用 =type= 动态创建类以外，要控制类的创建行为，还可以使用metaclass

元类是创建类对象的类,而由于类的类型为 =type= 因此元类必须继承至 =type=
#+BEGIN_SRC python
  # metaclass是类的模板，所以必须从`type`类型派生：
  class ListMetaclass(type):
      def __new__(cls, name, bases, attrs):
          attrs['add'] = lambda self, value: self.append(value)
          return type.__new__(cls, name, bases, attrs)
#+END_SRC

#+RESULTS:

这里, =__new__= 方法接收到的参数以此应该为:
1. 当前准备创建的class对象
2. 类的名字
3. 类继承的父类集合
4. 类的方法集合

有了ListMetaclass，我们在定义类的时候还要指示使用ListMetaclass来定制类，传入关键字参数metaclass：
#+BEGIN_SRC python
  class MyList(list, metaclass=ListMetaclass):
      pass

  # MyList具有了add函数
  L = MyList()
  L.add(1)
  L
  # 普通list没有add方法
  L2 = list()
  L2.add(1)
#+END_SRC

#+RESULTS:
: 
: [1]
: Traceback (most recent call last):
:   File "<stdin>", line 1, in <module>
: AttributeError: 'list' object has no attribute 'add'

** 特殊属性说明

   | 类属性     | 含义                   | 说明                                                              |
   |------------+------------------------+-------------------------------------------------------------------|
   | __name__   | 类名(字符串)  ,        | 在主程序中执行时,它的值为"__main__",在导入模板时,其值为模板的名字 |
   | __doc__    | 类的文档字符串         |                                                                   |
   | __bases__  | 类的所有父类组成的元组 |                                                                   |
   | __dict__   | 类的属性组成的字典     |                                                                   |
   | __module__ | 类所属的模块           |                                                                   |
   | __class__  | 类对象的类型           |                                                                   |
   | __all__    | 定义了模板的公有接口   | 一般用于模块中,告诉解释器从模块导入所有名字时实际导入了哪些名字   |
   | __file__   | 模块的源代码存放在哪个文件中 | 有些模块并没有源代码,它可能已经融入解释器中了                                           |
** 特殊方法说明
*** __str__
使用 =print= 输出对象时,调用该方法,该方法应该返回一个字符串
*** __repr__
返回对象的字面量
*** __iter__
如果一个类想被用于for ... in循环，类似list或tuple 那样，就必须实现一个__iter__()方法.该方法返回一个迭代对象.
然后，Python的for循环就会不断调用该迭代对象的__next__()方法拿到循环的下一个值，直到遇到StopIteration错误时退出循环

例如
#+BEGIN_SRC python
  class Fib(object): 
      def __init__(self): 
          self.a, self.b = 0, 1 # 初始化两个计数器a，b 
      def __iter__(self): 
          return self # 实例本身就是迭代对象，故返回自己 
      def __next__(self): 
          self.a, self.b = self.b, self.a + self.b # 计算下一个值 
          if self.a > 100000: # 退出循环的条件 
              raise StopIteration(); 
          return self.a # 返回下一个值
#+END_SRC

*** __getitem__
用于根据下标/切片/索引来取得相应的元素
#+BEGIN_SRC python
  class Fib(object): 
      def __getitem__(self, n): 
          if isinstance(n, int): # n是索引 
              a, b = 1, 1 
              for x in range(n): 
                  a, b = b, a + b 
              return a 
          if isinstance(n, slice): # n是切片 
              start = n.start 
              stop = n.stop 
              if start is None: 
                  start = 0 
              a, b = 1, 1 
              L = [] 
              for x in range(stop): 
                  if x >= start: 
                      L.append(a) 
                  a, b = b, a + b 
              return L 

  f = Fib()
  print(f[0:5])
  print(f[:10])
  print(f[2])
#+END_SRC

#+RESULTS:
: [1, 1, 2, 3, 5]
: [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]
: 2

为了简化说明,上面的例子既没有对step参数作处理,也没有对负数作处理
*** __setitem__
把对象作为list或dict来对集合赋值
*** __delitem__
用于删除某个函数
*** __getattr__
调用实例中不存在的属性时会调用该方法
#+BEGIN_SRC python
  class Student(object):
      def __init__(self):
          self.name = 'DarkSun'
      def __getattr__(self,attr):
          if attr == 'score':
              return 99

  s = Student()
  print(s.score)
  print(s.other)
#+END_SRC

#+RESULTS:
: 
: 99
: None

由于 =__getattr__= 函数默认返回的是None,因此对象的其他属性都是返回None. 若想不处理其他属性,则可以抛出AttributeError的错误
*** __call__
任何类，只需要定义一个__call__()方法，就可以把实例当成函数一样,直接进行调用
#+BEGIN_SRC python
  class Student(object):
      def __init__(self, name):
          self.name = name 
      def __call__(self): 
          print('My name is %s.' % self.name)

  s = Student('Dk')
  s()
  callable(s)
#+END_SRC

#+RESULTS:
: My name is Dk.
: True

** 异常处理

*** python中的异常,应该属于Exception的子类
  
  python内建了许多异常,下面是一些常用的内建异常类:
  | 类名              | 描述                                       |
  |-------------------+--------------------------------------------|
  | Exception         | 所有异常的基类                             |
  | AttributeError    | 对象属性引用或赋值失败时引发               |
  | IOError           | 试图打开不存在文件或无权限时引发           |
  | IndexError        | 当使用序列中不存在的索引时引发             |
  | KeyError          | 使用映射中不存在的键时引发                 |
  | NameError         | 当找不到变量名时引发                       |
  | SynaxError        | 语法错误时引发                             |
  | TypeError         | 当内建操作或函数应用于错误类型的对象时引发 |
  | ValueError        | 在内建操作或函数应用于非法值时引发         |
  | ZeroDivisionError | 被除数为0                                      |

*** 使用 ~raise~ 语句抛出异常
  
  ~raise~ 语句既可以接一个异常类,也可以结一个异常对象. 当使用类调用 ~raise~ 语句时,python会自动创建实例.
  #+BEGIN_SRC python
    raise Exception                
    # =>
    # Traceback (most recent call last):
    #   File "<stdin>", line 1, in <module>
    #   File "c:/Users/ADMINI~1/AppData/Local/Temp/py5360o8N", line 1, in <module>
    # Exception

    raise Exception("exception message")
    # =>
    # Traceback (most recent call last):
    #   File "<stdin>", line 1, in <module>
    #   File "c:/Users/ADMINI~1/AppData/Local/Temp/py53601GU", line 8, in <module>
    # Exception: exception message

  #+END_SRC

*** 捕捉异常

  使用 ~try/catch~ 来捕捉异常
  #+BEGIN_SRC python
    try:
        代码块
    except 异常类1:
        异常处理1
    except 异常类2:
        异常处理2
  #+END_SRC

  若捕捉到了异常,但是又想重新引发它,那么可以调用不带参数的 ~raise~ 语句
  #+BEGIN_SRC python
    Class MuffledCalculator:
        muffled = False

        def calc(self,expr):
            try:
                return eval(expr)
            except ZeroDivisionError:
                if self.muffled:
                    print "Division by zero"
                else:
                    raise           # 抛出原异常
  #+END_SRC

  一个块可以捕捉多个类型的异常,只需要将它们作为元组列出即可
  #+BEGIN_SRC python
    try:
        代码块
    except (异常类型1,异常类型2...):
        异常处理
  #+END_SRC
  
  如果希望在except子句中访问异常对象本身,只需要在except子句的异常类型/异常类型列表后加上 =as 变量名=. 这个变量名在except子句中引用到被捕获的异常对象
  #+BEGIN_SRC python
    try:
        代码块
    except (异常类型1,异常类型2...) as 异常变量:
        异常处理,其中可以使用异常变量引用被捕获的异常对象
  #+END_SRC

  若except子句后不接异常类型,则表示捕获所有异常
  #+BEGIN_SRC python
    try:
        x = float(input("Enter the first number:"))
        y = float(input("Enter the second number:"))
        print(x/y)
    except:
        print("Something wrong happend...")
  #+END_SRC

*** else子句
~else~ 子句只有在 ~try~ 子句未发生异常的情况下才会执行.
#+BEGIN_SRC python
  while True:
      try:
          x = float(input("Enter the first number:"))
          y = float(input("Enter the second number:"))
          print(x/y)
      except:
          print("Something wrong happend...")
      else:
          break
#+END_SRC

*** finally子句
~finally~ 子句常用来对可能的异常后进行清理. 它无论是否发生异常,都会保证执行.
#+BEGIN_SRC python
  x = None
  try:
      x = 1/0
  finally:
      print("Cleanning up")
      del x
#+END_SRC
** 生成器
生成器是一种用普通函数语法定义的迭代器. 任何包含yield语句的函数都被称为生成器.
#+BEGIN_SRC python
  def my_range(start,end):
      while start < end:
          yield start
          start+=1
#+END_SRC

yield与return语句一样都会返回一个值,所不同的在于它不会退出函数,相反它会暂时冻结函数的执行,等待再次被激活.

实际上,yield函数返回的是一个迭代器,当迭代器被请求一个值时,它会执行生成器中的代码,直到遇到一个yield或return语句.
+ yield语句意味着生成一个新值
+ return语句意味着生成器停止执行.

*** 生成器的其他方法
+ send方法

  外部作用域调用生成器的send方法时,就像调用它的__next__方法一样,只是send方法可以带一个参数,这个参数会作为生成器内yield语句的返回值. 若__next__方法被调用,则yield语句返回的是None值

  #+BEGIN_SRC python
    def repeater(value) :
        while True:
            new = yield value
            if new is not None:
                value = new

    r = repeater(42)
    r.__next__()                    # 42
    r.send("Hello")                 # "Hello"
    r.__next__()                    # "Hello"
  #+END_SRC
  
  注意,使用send方法,只有在生成器执行到yield方法时才有意义.

+ throw方法

  该方法会使得yield语句抛出一个异常

+ close方法

  该方法用于停止生成器,但是它的实现原理其实是在yield语句中抛出一个GeneratorExit异常.

  因此,若需要生成器内进行代码清理的话,需要将yield语句放在try/catch语句中,并捕获GeneratorExit异常. *但记得随后还需要重新引发一个异常*,否则无法停止生成器.
** 推导式
*** 列表推导式
列表推导式（又称列表解析式）提供了一种简明扼要的方法来创建列表。
它的结构是在一个 =[]= 中包含一个表达式，然后是一个 =for= 语句，然后是0个或多个 =for= 或者 =if= 语句。
那个表达式可以是任意的，意思是你可以在列表中放入任意类型的对象。返回结果将是一个新的列表，在这个以 =if= 和 =for= 语句为上下文的表达式运行完成之后产生.
#+BEGIN_SRC python
  # variable=[out_exp for out_exp in input_list if out_exp == 2]
  [i for i in range(30) if i % 3 is 0]
#+END_SRC

#+RESULTS:
: 
: [0, 3, 6, 9, 12, 15, 18, 21, 24, 27]


*** 集合推导式
集合推导式与列表推导式类似,唯一的区别在于 *它包含在了 ={}= 中*
#+BEGIN_SRC python
  {x**2 for x in [1,1,2,2,3,3]}
#+END_SRC

#+RESULTS:
: {1, 9, 4}

*** 字典推导式
字典推导式与列表推导式类似,但 *它的结构在一个 ={}= 中*,且 *使用两个用 =:= 分隔的表达式,分别表示key与value的值*
#+BEGIN_SRC python
  mcase = {'a': 10, 'b': 34, 'A': 7, 'Z': 3}
  mcase_frequency = {
      k.lower(): mcase.get(k.lower(), 0) + mcase.get(k.upper(), 0) for k in mcase.keys()
  }
  mcase_frequency
#+END_SRC

#+RESULTS:
: {'a': 17, 'b': 34, 'z': 3}
*** 生成器推导式
生成器推导式的工作方式与列表推导式的工作方式类似,只不过返回的不是列表,而是生成器

生成器推导式与列表推导式的语法不同点在于生成器推导式在 =()= 后,列表推导式在 =[]= 后.
#+BEGIN_SRC python
  g = ((i + 2) ** 2 for i in range(2,27))
  g.__next__()                        # 16
  g.__next__()                        # 25
#+END_SRC

生成器推导式可以在当前的圆括号内直接使用. 例如在函数调用的括号中,不需要增加另外一对圆括号
#+BEGIN_SRC python
  sum(i**2 for i in range(10))    # 285
#+END_SRC

** 模块
*** 模板导入过程
+ python检查模板是否已经导入过,若已经导入过,则不再导入

  监测的方法是查看sys.modules中是否已经有该模块

+ python会从 ~sys.path~ 指定的目录中寻找指定名字的模板.

  但一般不会直接编辑 ~sys.path~ 变量,而是设定在 ~PYTHONPATH~ 环境变量中

+ 若模板对应一个python文件,则执行该文件内容. 若模板对应一个目录名(这类模板也叫做包),则在目录名下寻找__init__.py执行.
*** 导入模块的方法
+ import 模块名
+ from 模块名 import *
+ from 模块名 import 函数s
*** 模块的文档字符串
与类一样,模块的文档字符串写在模块的开头
** lambda表达式
lambda表达式的格式为 =lambda 参数: 操作=
#+BEGIN_SRC python
  add = lambda x,y : x + y
  add(3,5)

  a = [(1, 2), (4, 1), (9, 10), (13, -3)]
  a.sort(key=lambda x: x[1])
  print(a)
#+END_SRC

#+RESULTS:
: 
: 8
:  [(13, -3), (4, 1), (1, 2), (9, 10)]

* 文件
** 使用open函数打开文件
open函数语法为 ~open(name,mode="w",buffer=1)~

+ ~name~ 为文件路径.

+ ~mode~ 为文件模式

  #+CAPTION: open函数中模式参数的常用值
  | 值 | 说明                                |
  |----+-------------------------------------|
  | r  | 读模式                              |
  | w  | 写模式                              |
  | a  | 追加模式                            |
  | b  | 可与其他模式一起使用,表示二进制模式 |
  | +  | 可与其他模式一起使用,表示读写模式 |

+ ~buffer~ 为缓存设置
  
  #+CAPTION: open函数中缓冲参数说明
  | 值      | 说明             |
  |---------+------------------|
  | 0/False | 无缓存           |
  | 1/True  | 有缓存           |
  | >1      | 缓存的大小       |
  | <0      | 使用默认缓存大小 |
** 基本文件方法
+ 读方法
  | read([数字])     | 读入指定个字符,默认为读取剩下的所有内容 |
  | readline()       | 读取单独一行                            |
  | readline(正整数) | 读取单独一行,或指定个字符               |
  | readlines()      | 读取文件中所有行并将其作为列表返回      |

+ 写方法

  写方法中要注意:程序不会自动添加回车符,需要自己添加.
  | write(string)           | 写入参数STRING |
  | writelines(string-list) | 将列表中所有的字符写入文件流中.  |
** 文件中的位置
+ ~tell()~ 方法返回当前访问的位置
+ ~seek(offset,whence=0)~ 方法跳转到文件中相对whence的offset位置,其中

  - whence=0 :: 偏移量从文件开头算起

  - whence=1 :: 偏移量相对当前位置算起

  - whence=2 :: 偏移量相对文件结尾算起
** 关闭文件
有两种方法关闭文件:

+ 调用文件对象的 ~close()~ 方法
  #+BEGIN_SRC python
    f = open("/tmp/xxx.log","w")
    try:
        f.write("someline\n")
    finally:
        f.close()
  #+END_SRC

+ 使用 ~with~ 语句
  #+BEGIN_SRC python
    with open("/tmp/xxx.txt") as f:
        f.write("somelines\n")
  #+END_SRC
* socket

* 测试
** unittest进行单元测试
1. 创建一个测试类,需要从从unittestTestCase继承
2. 编写test开头的测试方法.，不以test开头的方法不被认为是测试方法，测试的时候不会被执行。
3. unittest.TestCase提供了很多内置的条件判断，我们只需要调用这些方法就可以断言输出是否是我们所期望的。最常用的断言就是 =assertEqual= 和 =assertRaises=
4. 可以在单元测试中编写两个特殊的setUp()和tearDown()方法。这两个方法会分别在每调用一个测试方法的前后分别被执行
   
下面是一个例子:
#+BEGIN_SRC python
  import unittest

  from mydict import Dict

  class TestDict(unittest.TestCase):

      def test_init(self):
          d = Dict(a=1, b='test')
          self.assertEqual(d.a, 1)
          self.assertEqual(d.b, 'test')
          self.assertTrue(isinstance(d, dict))

      def test_key(self):
          d = Dict()
          d['key'] = 'value'
          self.assertEqual(d.key, 'value')

      def test_attr(self):
          d = Dict()
          d.key = 'value'
          self.assertTrue('key' in d)
          self.assertEqual(d['key'], 'value')

      def test_keyerror(self):
          d = Dict()
          with self.assertRaises(KeyError):
              value = d['empty']

      def test_attrerror(self):
          d = Dict()
          with self.assertRaises(AttributeError):
              value = d.empty
#+END_SRC

运行单元测试有两种方式
1. 在文件最后加上两行代码
   #+BEGIN_SRC python
     if __name__ == '__main__':
         unittest.main()
   #+END_SRC
2. 在命令行通过参数 =-m unittest= 直接运行单元测试：
   #+BEGIN_SRC sh
     python3 -m unittest mydict_test # 注意后面没有py后缀
   #+END_SRC
** doctest进行文档测试
通过 =doctest= 模块可以直接提取注释中的代码并执行测试。

doctest严格按照Python交互式命令行的输入和输出来判断测试结果是否正确。只有测试异常的时候，可以用...表示中间一大段烦人的输出

doctest.testmod函数会从一个模块中读取所有文档字符串,找出所哟看起来像是在交互解释器中输入的例子的文本,之后检查例子是否符合实际要求.

下面是一个例子
#+BEGIN_SRC python
  # mydict2.py
  class Dict(dict):
      '''
      Simple dict but also support access as x.y style.

      >>> d1 = Dict()
      >>> d1['x'] = 100
      >>> d1.x
      100
      >>> d1.y = 200
      >>> d1['y']
      200
      >>> d2 = Dict(a=1, b=2, c='3')
      >>> d2.c
      '3'
      >>> d2['empty']
      Traceback (most recent call last):
          ...
      KeyError: 'empty'
      >>> d2.empty
      Traceback (most recent call last):
          ...
      AttributeError: 'Dict' object has no attribute 'empty'
      '''
      def __init__(self, **kw):
          super(Dict, self).__init__(**kw)

      def __getattr__(self, key):
          try:
              return self[key]
          except KeyError:
              raise AttributeError(r"'Dict' object has no attribute '%s'" % key)

      def __setattr__(self, key, value):
          self[key] = value

  if __name__=='__main__':
      import doctest
      doctest.testmod()
#+END_SRC

* 性能测试

** profile
使用profile分析程序非常简单. 只需要用字符串参数调用它的run方法就会输出信息,包括各个函数和方法调用的次数,每个函数所花费的时间.
#+BEGIN_SRC python
  import profile
  profile.run("2+2")

  #       4 function calls in 0.000 seconds

  # Ordered by: standard name

  # ncalls  tottime  percall  cumtime  percall filename:lineno(function)
  #      1    0.000    0.000    0.000    0.000 :0(exec)
  #      1    0.000    0.000    0.000    0.000 :0(setprofile)
  #      1    0.000    0.000    0.000    0.000 <string>:1(<module>)
  #      1    0.000    0.000    0.000    0.000 profile:0(2+2)
  #      0    0.000             0.000          profile:0(profiler)
#+END_SRC

如果給profile.run提供了一个文件名作为第二个参数,则结果会保存到文件中. 可以在之后用pstats模块检查分析结果.
#+BEGIN_SRC python
  import pstats
  import profile

  profile.run("2+2","/tmp/profile.log")
  p = pstats.Stats("/tmp/profile.log")
  help(p)
#+END_SRC

* 程序打包
** Distutils
一个简单的Distutils安装脚本如下：
#+BEGIN_SRC python
  from idstutils.core import setup

  setup(name='Hello',
        version="1.0",
        description='A Simple Example',
        author='DarkSun',
        py_modules=['hello'])
#+END_SRC

相关命令
| 命令  | 说明 |
|-------+------|
| build | 打包 |
| setup | 安装 |
| sdist | 源码发布 |
|       |          |
* 日志
** logging模块
#+BEGIN_SRC python
  import logging
  logging.basicConfig(level=logging.INFO,filename='/tmp/mylog.log')
  logging.info('Starting program')
  logging.info('Trying to divide 1 by 0')
  print(1/0)
  logging.info('will not be logged')
#+END_SRC
* 序列化与反序列化
** pickle模块
python提供了 =pickle= 模块来实现序列化. 

使用 =pickle.dumps= 方法可以将任意对象序列化为一个bytes
#+BEGIN_SRC python
  import pickle
  d = dict(id=1,name="DarkSun")
  s = pickle.dumps(d)
  s
#+END_SRC

#+RESULTS:
: b'\x80\x03}q\x00(X\x04\x00\x00\x00nameq\x01X\x07\x00\x00\x00DarkSunq\x02X\x02\x00\x00\x00idq\x03K\x01u.'

使用 =pickle.dump= 方法可以将任意对象序列化后写入一个file-like object中
#+BEGIN_SRC python
  with open("/tmp/dump.txt",'wb') as f:
      pickle.dump(d,f)
#+END_SRC

#+RESULTS:

使用 =pickle.loads= 方法可以反序列化比特串为对象
#+BEGIN_SRC python
  print(pickle.loads(s))
#+END_SRC

#+RESULTS:
: {'name': 'DarkSun', 'id': 1}

使用 =pickle.load= 方法可以从一个file-like object中直接反序列化成对象
#+BEGIN_SRC python
  with open("/tmp/dump.txt","rb") as f:
      pickle.load(f)
#+END_SRC

#+RESULTS:
: {'name': 'DarkSun', 'id': 1}

*需要注意的是,反序列化的对象与原对象不是一个对象*
#+BEGIN_SRC python
  pickle.loads(s) is d
#+END_SRC

#+RESULTS:
: False
** Json库
Pickle的问题和所有其他编程语言特有的序列化问题一样，就是它只能用于Python，并且可能不同版本的Python彼此都不兼容.
因此，只能用Pickle保存那些不重要的数据，不能成功地反序列化也没关系

如果我们要在不同的编程语言之间传递对象，就必须把对象序列化为标准格式,比如xml或json

JSON和Python内置的数据类型对应如下
| JSON类型   | Python类型 |
|------------+------------|
| {}         | dict       |
| []         | list       |
| "string"   | str        |
| 1234.56    | int/float  |
| true/false | True/False |
| null       | None       |

使用 =json.dumps= 可以将一个Python类型序列化为Json类型:
#+BEGIN_SRC python
  import json
  s1 = json.dumps(dict(id=1,name="darksun"))
  print(s1)
  # 若要序列化非Python的内置类型,则需要为dumps函数的default参数提供一个转换函数,先用这个转换函数将对象转换为可序列化为JSON的类型
  class Person(object):
      def __init__(self,id,name):
          self.id = id
          self.name=name
      def __str__(self):
          return "{}:{}".format(self.id,self.name)

  p = Person(1,"Darksun")
  s2 = json.dumps(p,default=lambda obj:obj.__dict__)
  print(s2)
#+END_SRC

#+RESULTS:
: 
: {"name": "darksun", "id": 1}
: {"name": "Darksun", "id": 1}

类似的使用 =json.dump= 可以将对象序列化后直接存入file-like object中.

使用 =json.loads= 可以将一个Json类型序列化为Python类型:
#+BEGIN_SRC python
  json.loads(s1)
  # 若要转换出一个不直接支持的python对象,则需要給object_hook参数传递一个函数负责将dict转换回对象
  def dict2person(d):
      return Person(d['id'],d['name'])

  p = json.loads(s2,object_hook=dict2person)
  print(p)
#+END_SRC

#+RESULTS:
: {'name': 'darksun', 'id': 1}
: 1:Darksun


* Note
1. 数字、字符串和元组是不可变的；列表和字典是可变的
2. 可作用于多种类型的通用型操作都是以内置函数或表达式的形式出现的；但是类型特定的操作是以方法调用的形式出现的。
3. 方法也是函数属性
4. 可以调用内置的dir函数，将会返回一个列表，其中包含了对象的所有属性（方法也是属性）
5. dir函数简单地给出了方法的名称。查询他们做什么，可以传递给help函数
6. 实地改变对象并不会把变量划分为本地变量，实际上只有对变量名赋值才可以。
   例如，如果变量名L在模块顶端被赋值为一个列表，
   在函数内部的像L.append(X)这样的语句并不会将L划分为本地变量，
   而L=X却可以
7. 变量名引用分为四个作用域进行查找：本地-》函数内-》全局-》内置
8. 每个子类最好定义自己的构造器，不然基类的构造器会被调用。然而，如果子类重写基类的构造器，基类的构造器就不会自动调用了，这样基类的构造器就必须显式写出才会被执行
9. 内建类型没有__dict__属性
10. python中实例可以访问类中的属性，但是无法更新类属性。因为一旦尝试在实例中更新类属性，python会在实例的命名空间内新建一个属性而屏蔽了类属性
11. 在类中，一般不直接调用类名，而是使用self.__class__代替
12. python不支持重载
13. __getattribute__()与__getattr__()类似，不同在于前者在每一次属性访问时都会调用，而后者只当属性访问不到是调用.如果类同时定义了__getattribute__()及__getattr__()方法,除非明确从__get-attribute__()调用，或__getattribute__()引发了 AttributeError 异常,否则后者不会被调用. 
14. input()=eval(raw_input())
15. execfile(filename,global=globals(),local=locals())不保证不会修改局部名字空间，因此比较安全的做法是传入一个虚假的locals字典并检查是否有副作用
16. python -m 库名称（不用接后缀.py）  ，可以将库当做代码来执行，自动会通过python的导入机制找到库的地址，然后用__main__=='__main__'的方式执行库代码
17. startfile(filePath) ,使用默认的关联程序打开文件
18. os.spawn()家族函数=fork()+exec()家族函数
19. 现在一般用subprocess取代os模块来调用子进程
20. commands.getoutput(cmd),在子进程中执行文件，以字符串返回所有的输出，但该方法只能在UNIX下调用
21. 当调用sys.exit()时，就会引发systemExit()异常
22. sys.exitfunc()默认是不可用的，但你可以改写它以提供额外的功能。当调用了sys.exit()并在解释器退出之前，就会调用这个函数了，这个函数不带任何参数，所以你创建的函数也应该是无参的
23. os._exit(status)参数与平台有关，该函数与sys.exit()和exitfunc()不同，它根本不执行任何清理就立即退出，而且状态参数是必须得
24. os.kill()函数模拟传统的 unix 函数来发送信号给进程。kill()参数是进程标识数(PID)和你想要发送到进程的信号。发送的典型信号为 SIGINT, SIGQUIT,或更彻底地，SIGKILL,来使进程终结。 
25. SocketServer的请求处理器的默认行为是接受连接，得到请求，然后就关闭连接，这使得我们不能在程序的运行时，一直保持连接状态，要每次发送数据到服务器的时候都要创建一个新的套接字
26. 在向 CGI脚本返回结果时，须先返回一个适当的 HTTP头文件后才会返回结果 HTML 页面。 进一步说， 为了区分这些头文件和结果 HTML 页面， 需要在头与HTML页面之间多插入一个换行符。例如：
    #+BEGIN_SRC
    import cgi

    reshtml='''Content-Type:text/html\n            #这里多了一个换行
    <html>
    <head>
	<title>Friends CGI Demo</title>
    </head>
    <body>
	Your name is <B>%s</B><P>
	You have <B>%s</B> friends
    </body>
    </html>'''

    form=cgi.FieldStorage()
    name=form['name'].value
    howmany=form['howmany'].value
    print reshtml %(name,howmany)
    #+END_SRC
27. 读取密码时，可以用getpass模块的getpass()方法来获取
28. __开头的变量会被python重命名为带有类名前缀的名称。该特性被用来避免继承带来的命名冲突，但是在实践中，从不使用__。当表示一个属性非公开时，惯例是用一个_前缀。这不会调用任何改编算法，而只是证明这个特性是该类的私有元素
29. 使用内建函数vars()可以返回当前作用域的字典.
* 数据库
** Python DB-API
    1. 模块属性
       #+BEGIN_EXAMPLE
       DB-API 模块属性 
       属性名          描述 
       apilevel        DB-API 模块兼容的 DB-API 版本号 
       threadsafety    线程安全级别 
       paramstyle      该模块支持的 SQL 语句参数风格 
       connect()       连接函数 

       connect()   函数 属性 
       参数            描述 
       user            Username  
       password        Password  
       host            Hostname 
       database        Database name 
       dsn             Data source name         
       注意不是所有的接口程序都是严格按照规范实现的. MySQLdb 就使用了 db 参数而不是规范推荐的 database 参数来表示要访问的数据库.例如：
       MySQLdb.connect(host='dbserv', db='inv', user='smith') 
       连接对象方法 
       Method Name     Description 
       close()         关闭数据库连接 
       commit()        提交当前事务                  #在commit()之前close()的话，会自动rollback()
       rollback()      取消当前事务 
       cursor()        使用这个连接创建并返回一个游标或类游标的对象 
       errorhandler (cxn, cur,errcls, errval) 

       游标对象的属性 
       对象属性                描述
       arraysize       使用 fechmany()方法一次取出多少条记录, 默认值为 1 
       connectionn     创建此游标对象的连接(可选) 
       description     返回游标活动状态(一个包含七个元素的元组):  (name, type_code, display_size, internal_ size, precision, scale, null_ok); 只有 name 和 type_code 是必须提供的.  
       lastrowid       返回最后更新行的 id (可选), 如果数据库不支持行 id, 默认返回 None) 
       rowcount        最后一次 execute() 操作返回或影响的行数.  
       callproc(func[,args])  调用一个存储过程 
       close()             关闭游标对象 
       execute(op[,args])    执行一个数据库查询或命令 
       executemany(op,args)  类似 execute() 和 map() 的结合, 为给定的每一个参数准备并执行一个数据库查询/命令
       fetchone()      得到结果集的下一行 
       fetchmany([size=cursor. 
       arraysize])      得到结果集的下几行 (几 = size) 
       fetchall()      返回结果集中剩下的所有行 
       __iter__()      创建一个迭代对象 (可选; 参阅 next()) 
       messages        游标执行后数据库返回的信息列表 (元组集合) (可选) 
       next()      使用迭代对象得到结果集的下一行(可选; 类似 fetchone(), 参阅 __iter__()) 
       nextset()       移到下一个结果集 (如果支持的话) 
       rownumber       当前结果集中游标的索引 (以行为单位, 从 0 开始) (可选) 
       setinput- sizes(sizes) 设置输入最大值 (必须有, 但具体实现是可选的) 
       setoutput- size(size[,col]) 设置大列的缓冲区大写(必须有, 但具体实现是可选的) 

       异常类 
       异常                描述 
       Warning            警告异常基类 
       Error              错误异常基类 
       InterfaceError     数据库接口错误 
       DatabaseError      数据库错误 
       DataError           理数据时出错 
       OperationalError    数据库执行命令时出错 
       IntegrityError      数据完整性错误 
       InternalError      数据库内部出错 
       ProgrammingError    SQL 执行失败 
       NotSupportedError   试图执行数据库不支持的特性

       类型对象和构造器                #，对于Python DB-API的开发者来说，你传递给数据库的参数是字符串形式的，但数据库需要将它转换为多种不同的形式，该方式用来将Python的字符串参数转换为SQL类型的参数
       类型对象        描述 
       Date(yr,mo,dy)      日期值对象 
       Time(hr,min,sec)   时间值对象 
       Timestamp(yr,mo,dy,hr, min,sec)      时间戳对象 
       DateFromTicks(ticks) 通过自 1970-01-01 00:00:01 utc 以来的 ticks 秒数得到日期 
       TimeFromTicks(ticks) 通过自 1970-01-01 00:00:01 utc 以来的 ticks 秒数得到时间值对象 
       TimestampFromTicks(ticks) 通过自 1970-01-01 00:00:01 utc 以来的 ticks 秒数得到时间戳对象 
       Binary(string)  对应二进制长字符串值的对象 
       STRING        描述字符串列的对象, 比如 VARCHAR 
       BINARY        描述二进制长列的对象 比如 RAW, BLOB 
       NUMBER        描述数字列的对象 
       DATETIME      描述日期时间列的对象 
       ROWID          描述 “row ID” 列的对象
       #+END_EXAMPLE
    2. 某些接口程序的连接对象拥有query()方法可以执行SQL查询，但不建议使用这个方法，或者事先检查该方法在当前接口程序当中是否可用。因为这不规范，正常来说应该使用游标对象cursors的execute()方法
    3. sqlite被Python集成进了标准库，import sqlite3
       #+BEGIN_SRC
       >>> import sqlite3 
       >>> cxn = sqlite3.connect('sqlite_test/test') 
       >>> cur = cxn.cursor() 
       >>> cur.execute('CREATE TABLE users(login VARCHAR(8), uid 
       INTEGER)') 
       >>> cur.execute('INSERT INTO users VALUES("john", 100)') 
       >>> cur.execute('INSERT INTO users VALUES("jane", 110)') 
       >>> cur.execute('SELECT * FROM users') 
       >>> for eachUser in cur.fetchall(): 
       ...     print eachUser 
       ... 
       (u'john', 100) 
       (u'jane', 110) 
       >>> cur.execute('DROP TABLE users') 
       <sqlite3.Cursor object at 0x3d4320> 
       >>> cur.close() 
       >>> cxn.commit() 
       >>> cxn.close() 
       #+END_SRC
** TODO 对象-关系管理器(ORMs)
* 多进程与多线程
** python中的多进程
*** 使用os.fork产生子进程
由于 =fork= 系统调用只是在UNIX like操作系统中存在,因此windows是不支持的.
#+BEGIN_SRC python :session "none"
  import os
  print('Process (%s) start...' % os.getpid())
  # Only works on Unix/Linux/Mac:
  pid = os.fork()
  if pid == 0:
      print('I am child process (%s) and my parent is %s.' % (os.getpid(), os.getppid()))
  else:
      print('I (%s) just created a child process (%s).' % (os.getpid(), pid))
#+END_SRC

#+RESULTS:
: Process (9692) start...
: I (9692) just created a child process (1092).
: Process (9692) start...
: I am child process (1092) and my parent is 9692.
*** multiprocessing库
multiprocessing模块就是跨平台版本的多进程模块。 

multiprocessing模块提供了一个Process类来代表一个进程对象:
#+BEGIN_SRC python :session "none"
  from multiprocessing import Process
  import os
  # 子进程要执行的代码
  def run_proc(name):
      print('Run child process %s (%s)...' % (name, os.getpid()))

  if __name__=='__main__':
      print('Parent process %s.' % os.getpid())
      p = Process(target=run_proc, args=('test',))
      print('Child process will start.')
      p.start()
      p.join()
      print('Child process end.')
#+END_SRC

#+RESULTS:
: Parent process 1192.
: Child process will start.
: Run child process test (1036)...
: Child process end.

创建子进程时，只需要传入一个执行函数和函数的参数，创建一个Process实例，
用start()方法启动该子进程.
join()方法可以等待子进程结束后再继续往下运行，通常用于进程间的同步。

使用 =multiprocessing.Pool= 可以用进程池的方式批量创建子进程.
#+BEGIN_SRC python :session "none"
  from multiprocessing import Pool
  import os, time, random

  def long_time_task(name):
      print('Run task %s (%s)...' % (name, os.getpid()))
      start = time.time()
      time.sleep(random.random() * 3)
      end = time.time()
      print('Task %s runs %0.2f seconds.' % (name, (end - start)))

  if __name__=='__main__':
      print('Parent process %s.' % os.getpid())
      p = Pool(4)                 # 表示池中最多同时执行4个进程,默认为CPU的核数
      for i in range(5):
          p.apply_async(long_time_task, args=(i,))
      print('Waiting for all subprocesses done...')
      p.close()                   # close后就不能再继续添加新的Process了
      p.join()                    # 等待Pool中所有子进程执行完成,之前需要先调用close方法
      print('All subprocesses done')
#+END_SRC

#+RESULTS:
#+begin_example
Parent process 7732.
Run task 3 (4736)...
Task 3 runs 0.87 seconds.
Run task 2 (9512)...
Task 2 runs 1.00 seconds.
Run task 0 (10188)...
Task 0 runs 0.75 seconds.
Run task 4 (10188)...
Task 4 runs 0.83 seconds.
Run task 1 (2052)...
Task 1 runs 1.75 seconds.
Waiting for all subprocesses done...
All subprocesses done
#+end_example

multiprocessing模块还提供了Queue,Pipe等多种方式实现IPC
#+BEGIN_SRC python :session "none"
  from multiprocessing import Process, Queue
  import os, time, random

  # 写数据进程执行的代码:
  def write(q):
      print('Process to write: %s' % os.getpid())
      for value in ['A', 'B', 'C']:
          print('Put %s to queue...' % value)
          q.put(value)
          time.sleep(random.random())

  # 读数据进程执行的代码:
  def read(q):
      print('Process to read: %s' % os.getpid())
      while True:
          value = q.get(True)
          print('Get %s from queue.' % value)

  if __name__=='__main__':
      # 父进程创建Queue，并传给各个子进程：
      q = Queue()
      pw = Process(target=write, args=(q,))
      pr = Process(target=read, args=(q,))
      # 启动子进程pr，读取:
      pr.start()
      # 启动子进程pw，写入:
      pw.start()
      # 等待pw结束:
      pw.join()
      time.sleep(1)
      # pr进程里是死循环，无法等待其结束，只能强行终止:
      pr.terminate()
#+END_SRC

#+RESULTS:
: Process to write: 6296
: Put A to queue...
: Put B to queue...
: Put C to queue...

*** subprocess
subprocess模块可以让我们非常方便地启动一个外部程序作为子进程，然后控制其输入和输出
#+BEGIN_SRC python :session "none"
  import subprocess

  print('$ ls /')
  r = subprocess.call(['ls', '/'])
  print('Exit code:', r)
#+END_SRC

#+RESULTS:
#+begin_example
bin
cygdrive
Cygwin.bat
Cygwin.ico
Cygwin-Terminal.ico
dev
etc
home
lib
opt
proc
pypy-c.exe.stackdump
sbin
tmp
usr
var
$ ls /
Exit code: 0
#+end_example

也可以先启动一个子进程,然后使用 =communicate= 方法模拟输入
#+BEGIN_SRC python :session "none"
  import subprocess

  print('$ cat')
  p = subprocess.Popen(['cat'], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
  output, err = p.communicate(b'subprocess test\n')
  print(output.decode('utf-8'))
  print('Exit code:', p.returncode)
#+END_SRC

#+RESULTS:
: $ cat
: subprocess test
: 
: Exit code: 0

** python中的多线程
python的标准库提供了两个模块：_thread和threading，_thread是低级模块，threading是高级模块，对_thread进行了封装
*** threading
启动一个线程就是把一个函数传入并创建Thread实例，然后调用start()开始执行
#+BEGIN_SRC python :session "none"
  import time,threading

  # 线程执行的代码
  def loop():
      print('thread %s is running...' % threading.current_thread().name)
      n = 0
      while n < 5:
          n = n + 1
          print('thread %s >>> %s' % (threading.current_thread().name, n))
          time.sleep(1)
      print('thread %s ended.' % threading.current_thread().name)

  print('thread %s is running...' % threading.current_thread().name) # 主线程名称为mainThread
  t = threading.Thread(target=loop, name='LoopThread')
  t.start()
  t.join()
  print('thread %s ended.' % threading.current_thread().name)
#+END_SRC

#+RESULTS:
: thread MainThread is running...
: thread LoopThread is running...
: thread LoopThread >>> 1
: thread LoopThread >>> 2
: thread LoopThread >>> 3
: thread LoopThread >>> 4
: thread LoopThread >>> 5
: thread LoopThread ended.
: thread MainThread ended.

*** threading.Lock
当多个线程同时修改同一个变量时,需要加锁,而创建一个锁是由threading.Lock()来实现的
#+BEGIN_SRC python :session "none"
  import time,threading
  balance = 0
  lock = threading.Lock()

  def change_it(n):
      global balance
      balance = balance + n
      balance = balance -n

  def run_thread(n):
      for i in range(100000):
          # 先要获取锁:
          lock.acquire()
          try:
              # 放心地改吧:
              change_it(n)
          finally: 
              # 改完了一定要释放锁:
              lock.release()

  t1 = threading.Thread(target=run_thread, args=(5,))
  t2 = threading.Thread(target=run_thread, args=(8,))
  t1.start()
  t2.start()
  t1.join()
  t2.join()
  print(balance)
#+END_SRC

#+RESULTS:
: 0
*** ThreadLocal
*使用 =ThreadLocal= 可以方便在各个线程之间传递参数而不会相互影响*
可以把 =ThreadLocal= 对象看成全局变量，但其每个属性都是线程的局部变量，可以任意读写而互不干扰，也不用管理锁的问题，ThreadLocal内部会处理.
ThreadLocal最常用的地方就是为每个线程绑定一个数据库连接，HTTP 请求，用户身份信息等，这样一个线程的所有调用到的处理函数都可以 非常方便地访问这些资源。

* 高级应用
** 特殊的类属性
   #+CAPTION:特殊类属性
   | C.__name__   | 类C的名字（字符串）     |
   |--------------+-------------------------|
   | C.__doc__    | 类C的文档字符串         |
   |--------------+-------------------------|
   | C.__dict__   | 类C的所有父类构成的元组 |
   |--------------+-------------------------|
   | C.__module__ | 类C定义所在的模块       |
   |--------------+-------------------------|
   | C.__class__  | 实例C对应的类           |
   |--------------+-------------------------|
** __new__构造器方法
   由于__init__方法是在对象构造完成后，再调用__init__方法来对对象进行初始化的，这就使得构造出来的对象进行了改变。
   那么如何构造不可变对象呢？这就需要__new__方法。
   python在实例化不可变类型时会调用类的__new__方法，这是一个静态方法，并且传入的参数是在类实例化操作时生成的。__new__会调用父类的__new__来创建对象
   __new__必须返回一个合法的实例，并且__new__和__init__在类创建时，都传入了相通的参数
** 特殊的实例属性
   #+CAPTION:特殊的实例属性
   | I.__calss__ | 实例化I的类 |
   |-------------+-------------|
   | I.__dict__  | I的属性     |
   |-------------+-------------|
   |             |             |
   |-------------+-------------|
** super()内建方法
   1. super()内建函数可以自动捕获对应的父类
   2. super()不但能找到基类方法，而且还为我们传进self，这样我们就不用显示写父类的名称了
   3. super()语法为：super(type[,obj]).如果你希望父类被绑定，可以传入obj参数，否则父类不会被绑定，obj参数也可以是一个类型，但它应当是type的一个子类
   #+BEGIN_SRC Python
   class C(P):
       def foo(self):
           super(C,self).foo()
	   print 'Hi, I am C-foo()'
   #+END_SRC
   事实上，super()是一个工厂函数，它创造了一个super object，为一个给定的类使用__mro__去查找相应的父类。很明显，它从当前所找到的类开始搜索MRO
** __new__方法
   1. 所有的__new__方法都是类方法，我们要显示传入类左右第一个参数
** dir()方法
** 类的特殊方法
   #+CAPTION:类的特殊方法
   | 特殊方法                       | 描述                                             |
   |--------------------------------+--------------------------------------------------|
   | C.__init__                     | 构造器                                           |
   |--------------------------------+--------------------------------------------------|
   | C.__new__                      | 构造器，通常用在设置不变数据类型的子类           |
   |--------------------------------+--------------------------------------------------|
   | C.__del__(self)                | 解构器                                           |
   |--------------------------------+--------------------------------------------------|
   | C.__str__(self)                | 可打印的字符输出；内建str()以及print语句         |
   |--------------------------------+--------------------------------------------------|
   | C.__repr__(self)               | 运行时的字符串输出，内建repr()和``操作符         |
   |--------------------------------+--------------------------------------------------|
   | C.__unicode__(self)            | Unicode字符串输出，内建unicode()                 |
   |--------------------------------+--------------------------------------------------|
   | C.__call__(self,*args)         | 表示可调用的实例，任何在实例调用中给出的参数都会被传入到__call__中    |
   |--------------------------------+--------------------------------------------------|
   | C.__nonzero__(self)            | 为object定义False值，内建bool()                  |
   |--------------------------------+--------------------------------------------------|
   | C.__len__*self)                | 长度（可用于类）；内建len()                      |
   |--------------------------------+--------------------------------------------------|
   | 对象值比较                     |                                                  |
   |--------------------------------+--------------------------------------------------|
   | C.__cmp__(self,obj)            | 对象比较；内建cmp()                              |
   |--------------------------------+--------------------------------------------------|
   | C.__lt__(self,obj)             | 小于，小于等于；对应</<=操作符                   |
   |--------------------------------+--------------------------------------------------|
   | C.__gt__(self,obj)             | 大于，大于等于；对应>/>=操作符                   |
   |--------------------------------+--------------------------------------------------|
   | C。__eq__(self,obj)            | 等于，不等于；对应==，！=以及<>操作符            |
   |--------------------------------+--------------------------------------------------|
   | 属性                           |                                                  |
   |--------------------------------+--------------------------------------------------|
   | C.__getattr__(self, attr)      | 获取属性；内建 getattr()；仅当属性没有找到时调用 |
   |--------------------------------+--------------------------------------------------|
   | C.__setattr__(self, attr, val) | 设置属性                                         |
   |--------------------------------+--------------------------------------------------|
   | C.__delattr__(self, attr)      | 删除属性                                         |
   |--------------------------------+--------------------------------------------------|
   | C.__getattribute__(self, attr) | 获取属性；内建 getattr()；总是被调用             |
   |--------------------------------+--------------------------------------------------|
   | C.__get__(self, attr)          | （描述符）获取属性                               |
   |--------------------------------+--------------------------------------------------|
   | C.__set__(self, attr, val)     | （描述符）设置属性                               |
   |--------------------------------+--------------------------------------------------|
   | C.__delete__(self, attr)       | 述符）删除属性                                   |
   |--------------------------------+--------------------------------------------------|
   #+BEGIN_EXAMPLE
   定制类/模拟类型 
   数值类型：二进制操作符 
   C.__*add__(self, obj)             加；+操作符 
   C.__*sub__(self, obj)             减；-操作符 
   C.__*mul__(self, obj)             乘；*操作符 
   C.__*div__(self, obj)             除；/操作符 
   C.__*truediv__(self, obj)         True 除；/操作符 
   C.__*floordiv__(self, obj)        Floor 除；//操作符 
   C.__*mod__(self, obj)             取模/取余；%操作符 
   C.__*divmod__(self, obj)          除和取模；内建 divmod()                        |                                          |
   C.__*mod__(self, obj)             取模/取余；%操作符 
   C.__*divmod__(self, obj)          除和取模；内建 divmod() 
   C.__*pow__(self, obj[, mod])      乘幂；内建 pow();**操作符 
   C.__*lshift__(self, obj)          左移位；<<操作符 
 
   表 13.4 可定制类的特殊方法（续） 
 
   特殊方法                          描述 
   定制类/模拟类型 
   数值类型：二进制操作符 
   C.__*rshift__(self, obj)         右移；>>操作符 
   C.__*and__(self, obj)            按位与；&操作符 
   C.__*or__(self, obj)             按位或；|操作符 
   C.__*xor__(self, obj)            按位与或；^操作符 
   数值类型：一元操作符 
   C.__neg__(self)                  一元负 
   C.__pos__(self)                  一元正 
   C.__abs__(self)                  绝对值；内建 abs() 
   C.__invert__(self)              按位求反；~操作符 
   数值类型：数值转换 
   C.__complex__(self, com)        转为 complex(复数);内建 complex() 
   C.__int__(self)                 转为 int;内建 int() 
   C.__long__(self)                转为 long；内建 long() 
   C.__float__(self)               转为 float；内建 float() 
   数值类型：基本表示法（String） 
   C.__oct__(self)                八进制表示；内建 oct() 
   C.__hex__(self)                十六进制表示；内建 hex() 
   数值类型：数值压缩 
   C.__coerce__(self, num)        压缩成同样的数值类型；内建 coerce() 
   C.__index__(self)              在有必要时,压缩可选的数值类型为整型（比如：用于切片索引等等） 
   －－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－ 
   续 
   
   表 13.4 定制类的特殊方法（续） 
 
   序列类型 
   C.__len__(self)               序列中项的数目 
   C.__getitem__(self, ind)      得到单个序列元素 
   C.__setitem__(self, ind,val)   设置单个序列元素 
   C.__delitem__(self, ind)      删除单个序列元素 
   特殊方法                           描述 
   序列类型 
   C.__getslice__(self, ind1,ind2)   得到序列片断 
   C.__setslice__(self, i1, i2,val)  设置序列片断 
   C.__delslice__(self, ind1,ind2)   删除序列片断 
   C.__contains__(self, val)         测试序列成员；内建 in 关键字 
   C.__*add__(self,obj)              串连；+操作符 
   C.__*mul__(self,obj)              重复；*操作符 
   C.__iter__(self)                  创建迭代类；内建 iter() 
   映射类型 
   C.__len__(self)                   mapping 中的项的数目 
   C.__hash__(self)                  散列(hash)函数值 
   C.__getitem__(self,key)           得到给定键(key)的值 
   C.__setitem__(self,key,val)       设置给定键(key)的值 
   C.__delitem__(self,key)           删除给定键(key)的值 
   C.__missing__(self,key)           给定键如果不存在字典中，则提供一个默认值 

   NOTE:
   用星号通配符标注的数值二进制操作符则表示这些方法有多个版本，在名字上有些许不同。星号可代表在字符串中没有额外的字符，或者一个简单的“r”指明是一个右结合操作，或者是一个“i”指明是一个自操作符号
   重载一个__i*__()方法的唯一秘密是它必须返回self。
   #+END_EXAMPLE
** __slots__类属性
   1. 如果你有一个属性数量很少的类，但有很多实例，那么为节省内存，可以用__slots__属性代替__dict__
   2. __slots__是一个类变量，由一序列型对象组成，由所有合法标识构成的实例属性的集合来表示。它可以是一个列表，元组或可迭代对象。也可以是标识实例能拥有的唯一的属性的简单字符串。 任何试图创建一个其名不在__slots__中的名字的实例属性都将导致AttributeError异常：
      #+BEGIN_SRC
      class SlottedClass(object): 
      __slots__ = ('foo', 'bar')             #只有有foo和bar属性
      >>> c = SlottedClass() 
      >>> 
      >>> c.foo = 42 
      >>> c.xxx = "don't think so" Traceback (most recent call last): 
      File "<stdin>", line 1, in ? 
      AttributeError: 'SlottedClass' object has no attribute 
      'xxx' 
      #+END_SRC
   3. 带__slots__属性的类定义不会存在__dict__了（除非你在__slots__中增加'__dict__'元素）
** TODO 描述符
   1. __get__,__set__,__delete__特殊方法
   补完
   #+BEGIN_SRC
   >>> class DevNull(object):
	def __get__(self,obj,typ=None):
		pass
	def __set__(self,obj,val):
		pass

	
   >>> class C1(object):
	foo=DevNull()

	
   >>> c1=C1()
   >>> c1.foo='bar'
   >>> c1.foo
   >>> print c1.foo
   None
   #+END_SRC
** property()函数
   1. 可以写一个和属性有关的函数来处理实例属性的获取(getting),赋值(setting),和删除(deleting)操作，而不必再使用那些特殊的方法了
   2. property()内建函数有四个参数，它们是 ： 
      #+BEGIN_EXAMPLE
      property(fget=None, fset=None, fdel=None, doc=None) 
      #+END_EXAMPLE
   3. 请注意 property()的一般用法是，将它写在一个类定义中，property()接受一些传进来的函数(其实是方法)作为参数。实际上，property()是在它所在的类被创建时被调用的，这些传进来的(作为参数的)方法是非绑定的，所以这些方法其实就是函数！
   4. 例子
      #+BEGIN_EXAMPLE
      class ProtectAndHideX(object): 
        def __init__(self, x): 
            assert isinstance(x, int), \ 
                '"x" must be an integer!' 
        self.__x = ~x 
 
        def get_x(self): 
            return ~self.__x 
 
        x = property(get_x) 
        #+END_SRC

      我们来运行这个例子，会发现它只保存我们第一次给出的值， 而不允许我们对它做第二次修改： 

	>>> inst = ProtectAndHideX('foo')  
	Traceback (most recent call last): 
	File "<stdin>", line 1, in ? 
	File "prop.py", line 5, in __init__ 
	assert isinstance(x, int), \  
	AssertionError: "x" must be an integer! 
	>>> inst = ProtectAndHideX(10) 
	>>> print 'inst.x =', inst.x  
	inst.x = 10 
	>>> inst.x = 20 
	Traceback (most recent call last):  
	File "<stdin>", line 1, in ? 
	AttributeError: can't set attribute 
      #+END_EXAMPLE

** 原类
1. 创建的元类用于改变类的默认行为和创建方式
2. 你可以通过定义一个元类来迫使程序员按照某种方式实现目标类，这既可以简化他们的工作，也可以使所编写的程序更符合特定标准
3. 原类通常传递三个参数（到构造器）：类名，从基类继承数据的元组，和类的属性字典
   #+BEGIN_SRC python
     # 1. 创建一个类时，显示时间标签

     from time import ctime
     class MetaC(type): 
     def __init__(cls, name, bases, attrd): 
         super(MetaC, cls).__init__(name, bases, attrd) 
         print '*** Created class %r at: %s' % (name, ctime()) 

     print '\tClass "Foo" declaration next.' 

     class Foo(object): 
         __metaclass__ = MetaC 
        def __init__(self): 
            print '*** Instantiated class %r at: %s' % ( 
                self.__class__.__name__, ctime()) 

     print '\tClass "Foo" instantiation next.' 
     f = Foo() 
     print '\tDONE' 
     # 2. 创建一个元类，要求程序员在他们写的类中提供一个__str__方法的实现
     from warning import warn
     class ReqStrSugRepr(type): 

     def __init__(cls, name, bases, attrd): 
         super(ReqStrSugRepr, cls).__init__(name, bases, attrd) 

        if '__str__' not in attrd: 
        raise TypeError("Class requires overriding of __str__()") 

        if '__repr__' not in attrd: 
            warn('Class suggests overriding of __repr__()\n', stacklevel=3)
   #+END_SRC
4. 从上面例子可以看出，元类在类创建时被调用，可以使用传入元类的信息对类进行规范性检查
** 函数属性
1. 内建函数
   #+CAPTION:内建函数BIFs
   | BIF属性      | 描述                           |
   |--------------+--------------------------------|
   | bif.__doc__  | 文档字符串或None               |
   |--------------+--------------------------------|
   | bif.__name__ | 字符串类型的文档名称           |
   |--------------+--------------------------------|
   | bif.__self__ | 设置为None，保留给built-in方法 |
   |--------------+--------------------------------|
   | bif.module__ | 存放bif定义的模块名字或None    |
   |--------------+--------------------------------|
2. 用户自定义函数
   #+CAPTION:用户定义函数
   | UDF属性           | 描述                                                                  |
   |-------------------+-----------------------------------------------------------------------|
   | udf.__doc__       | 文档字符串，也可以用udf.func_doc                                      |
   |-------------------+-----------------------------------------------------------------------|
   | udf.__name__      | 字符串类型的函数名称，也可以用udf.func_name                           |
   |-------------------+-----------------------------------------------------------------------|
   | udf.func_code     | 字节编译的代码对象                                                    |
   |-------------------+-----------------------------------------------------------------------|
   | udf.func_defaults | 默认的参数元组                                                        |
   |-------------------+-----------------------------------------------------------------------|
   | udf.func_globals  | 全局名字空间字典:和从函数内部调用globals(x)一样                       |
   |-------------------+-----------------------------------------------------------------------|
   | udf.func_dict     | 函数属性的名字空间                                                    |
   |-------------------+-----------------------------------------------------------------------|
   | udf.func_closure  | 包含了自由变量的引用的单元对象元组，自用变量在UDF中使用，但在别处定义 |
   |-------------------+-----------------------------------------------------------------------|
3. 内建方法
   #+CAPTION:内建方法属性
   | BIM属性      | 描述                 |
   |--------------+----------------------|
   | bim.__doc__  | 文档字符串           |
   |--------------+----------------------|
   | bin.__name__ | 字符串类型的函数名称 |
   |--------------+----------------------|
   | bim.__self__ | 绑定的对象           |
   |--------------+----------------------|
4. 用户自定义方法
   #+CAPTION:用户自定义方法
   | UDM属性        | 描述                                                            |
   |----------------+-----------------------------------------------------------------|
   | udm.__doc__    | 文档字符串                                                      |
   |----------------+-----------------------------------------------------------------|
   | udm.__name__   | 字符串类型的方法名字                                            |
   |----------------+-----------------------------------------------------------------|
   | udm.__module__ | 定义udm的模块的名字或none                                       |
   |----------------+-----------------------------------------------------------------|
   | udm.im_class   | 方法相关联的类（对于绑定方法：如果是非绑定，那么为要求udm的类） |
   |----------------+-----------------------------------------------------------------|
   | udm.im_func    | 方法的函数对象                                                  |
   |----------------+-----------------------------------------------------------------|
   | udm.im_self    | 如果绑定的话为相关联的实例，如果非绑定为none                                        |
5. 函数对象仅是代码对象的包装，方法则是给函数对象的包装

** compile()
   1. compile的三个参数都是必须得，
      1. 第一个参数代表要编译的python代码
      2. 第二个字符串虽然必须得，但通常设置为空串。该参数代表了存放代码对象的文件的名字
      3. 最后的参数是个字符串，它用来表明代码对象的类型。有三个可能得值
      #+CAPTION:compile()第三个参数的可能值
      | 'eval'   | 可求值的表达式，和eval()一起使用 |
      |----------+----------------------------------|
      | 'single' | 单一可执行语句，和exec一起使用   |
      |----------+----------------------------------|
      | ‘exec'  | 可执行语句组，与exec一起使用     |
      |----------+----------------------------------|

** re
1. 正则表达式
   \b匹配一个单词的边界，\B匹配一个单词的中间模式
   \d匹配十进制数组
   \w表示字符和数组的集合
   ？非贪婪操作符，可以用在*、+、？的后面。它的作用是要求正则表达式引擎匹配的字符越少越好。
3. 当要从字符串头部开始匹配的时候，不要用re.search('^xxx')的方式，而用re.match('xxx')的方式来匹配
4. re.search与re.match如果匹配失败，则返回None
5. subn()和sub()一样，但它还返回一个表示替换次数的数字，替换后的字符串和表示替换次数的数字作为一个元组的元素返回
6. re模块和正则表达式对象的方法split()与字符串的split()方法相似，前者是根据正则表达式分割字符串，后者是根据固定的字符串分割
7. 需注意，\w和\W这两个表示字母或数字的字符受Unicode标志符号影响
8. 

** Tkinter
1. 对packer没有其他指令时，组件式按垂直顺序放置的。要水平放置则需要创建一个框架对象，再用它来添加按钮
2. 由于偏函数也能作用于类上，所以对于有许多待调对象，并且许多调用都反复使用相同参数的情况，用偏函数将预存并冻结这些预存参数是比较好的，此时可以看做是生成了新类
3. 
** Python扩展
1. 为python创建扩展需要三个主要步骤：
   1. 创建应用程序代码
   2. 利用样板来包装代码
   3. 编译与测试
2. 我们的样板主要分为 4 步： 
   1. 包含 Python 的头文件。 
   2. 为每个模块的每一个函数增加一个型如 Python对象指针 模块名称_函数名称(PyObject *self,PyObject *args)的包装函数。 
   你需要为所有想被 Python 环境访问的函数都增加一个静态的函数，函数的返回值类型为 PyObject*，函数名前面要加上模块名和一个下划线(_)。
   包装函数的用处就是先把 Python 的值传递给 C，然后调用我们想要调用的相关函数。当这个函数完成要返回 Python 的时候，把函数的计算结果转换成 Python 的对象，然后返回给 Python。
   在从 Python对象转换到C对象的转换就用PyArg_Parse*系列函数。在从 C 转到 Python 的时候，就用 Py_BuildValue()函数 
   PyArg_Parse 系列函数的用法跟 C 的 sscanf 函数很像，都接受一个字符串流，并根据一个指定的格式字符串进行解析，把结果放入到相应的指针所指的变量中去。它们的返回值为 1 表示解析成功，返回值为 0 表示失败。 
   Py_BuildValue 的用法跟 sprintf 很像，把所有的参数按格式字符串所指定的格式转换成一个Python 的对象。 
 
   3. 为每个模块增加一个型如 PyMethodDef 模块名Methods[]的数组。 
   这个数组由多个数组组成。其中的每一个数组都包含了一个函数的信息。最后放一个 NULL 数组表示列表的结束。例如:
   #+BEGIN_SRC C
   static PyMethodDef 
   ExtestMethods[] = { 
   { "fac", Extest_fac, METH_VARARGS }, 
   { "doppel", Extest_doppel, METH_VARARGS }, 
   { NULL, NULL }, 
   }; 
   #+END_SRC
    
   每一个数组都包含了函数在 Python 中的名字，相应的包装函数的名字以及一个 METH_VARARGS常量。
   其中，METH_VARARGS 常 量 表 示 参 数 以 tuple 形 式 传 入 。
   如果我们要使用PyArg_ParseTupleAndKeywords()函数来分析命名参数的话，我们还需要让这个标志常量与METH_KEYWORDS 常量进行逻辑与运算常量。
   最后，用两个 NULL 来结束我们的函数信息列表。 
   4. 增加模块初始化函数 void init模块名()
   所有工作的最后一部分就是模块的初始化函数。这部分代码在模块被导入的时候被解释器调用。在这段代码中，我们需要调用 Py_InitModule()函数，并把模块名和 ModuleMethods[]数组的名字传递进去，以便于解释器能正确的调用我们模块中的函数。
   #+BEGIN_SRC C
   void initExtest() { 
   Py_InitModule("Extest", ExtestMethods); 
   } 
   #+END_SRC
   3. 编译
      使用 distutils 包的时候我们可以方便的按以下步骤来做： 
      1. 创建 setup.py 
   #+BEGIN_EXAMPLE
   下一步就是要创建一个 setup.py 文件。编译最主要的工作由 setup()函数来完成。在这个函数调用之前的所有代码，都是一些预备动作。为了能编译扩展，你要为每一个扩展创建一个 Extension实例，在这里，我们只有一个扩展，所以只要创建一个 Extension 实例： 
   Extension('Extest', sources=['Extest2.c']) 
   第一个参数是（完整的）扩展的名字，如果模块是包的一部分的话，还要加上用'.'分隔的完整的包的名字。我们这里的扩展是独立的，所以名字只要写"Extest"就好了。sources 参数是所有源代码的文件列表。同样，我们也只有一个文件：Extest2.c。 
   现在，我们可以调用 setup()了。setup 需要两个参数:一个名字参数表示要编译哪个东西，一个列表列出要编译的对象。由于我们要编译的是一个扩展，我们把 ext_modules 参数的值设为扩展模块的列表。语法如下： 
   setup('Extest', ext_modules=[...]) 
 
   例 22.2 编译脚本(setup.py) 
   
   这个脚本会把我们的扩展编译到 build/lib.*子目录中。 
   
   #!/usr/bin/env python 
   
   from distutils.core import setup, Extension 
   MOD = 'Extest' 
   setup(name=MOD, ext_modules=[Extension(MOD, sources=['Extest2.c'])])
   #+END_EXAMPLE
   2. 通过运行 setup.py 来编译和连接您的代码 
   现在，我们已经有了 setup.py 文件。运行 setup.py build 命令就可以开始编译我们的扩展了
   3. 从 Python 中导入您的模块 
   你的扩展会被创建在你运行 setup.py 脚本所在目录下的 build/lib.*目录中。你可以切换到那个目录中来测试你的模块，或者也可以用以下命令把它安装到你的 Python 中：
   4. 测试功能
   4. 引用计数
      当创建扩展时，你必需对如何操作 Python 对象要格外的小心。你时时刻刻都要注意是否要改变某个对象的引用计数
      #+CAPTION:用于Python对象引用计数的宏
      | 函数           | 说明                    |
      |----------------+-------------------------|
      | Py_INCREF(obj) | 增加对象 obj 的引用计数 |
      |----------------+-------------------------|
      | Py_DECREF(obj) | 减少对象 obj 的引用计数 |
      |----------------+-------------------------|
   5. 线程和全局解释锁（GIL）
      编译扩展的人必须要注意，他们的代码有可能会被运行在一个多线程的 Python 环境中。
      由两个 C 宏Py_BEGIN_ALLOW_THREADS 和 Py_END_ALLOW_THREADS 包裹的代码，保证了运行和非运行时的安全性。将会允许其他线程的运行。
** 通过缓冲区协议实现零复制
在Python中使用分片操作往往意味着内容的复制。而对实现了缓冲区协议的对象，可以使用 =memoryview= 类的构造函数来构造一个memoryview对象，对该memoryview对象进行分片，则可以直接引用原始的对象内存，省略掉复制的消耗。
#+BEGIN_SRC python
  s = b"abcdefgh"
  view = memoryview(s)
  limited = view[1:3]
  print(bytes(limited))
#+END_SRC

Python中大部分的IO操作都知道如何处理实现了缓冲区协议的对象，他们不仅可以从这类对象中读，还可以向其中写
#+BEGIN_SRC python
  ba = bytearray(8)
  ba_at_4 = memoryview(ba)[4:]
  print(ba_at_4)

  with open("/dev/urandom","rb") as source:
      source.readinto(ba_at_4)

  print(ba)
#+END_SRC
* 文档
** reStructureText
** Sphinx模块
* 分发

* 模块说明
** cmd
1. 继承cmd.Cmd类
   * 以do_xxx命名的成员函数为xxx的命令的命令执行体
   * 以help_xxx命名的函数为xxx命令的帮助说明执行体
2. 运行时
   * help命令会显示所有有帮助说明的xxx命令
   * ? xxx会调用help_xxx来输出xxx命令的帮助
   * 直接运行xxx,会调用do_xxx函数
** sys模块
sys模块让你能够访问与python解释器联系紧密的变量和函数.

#+TABLE: sys模块中的重要函数和变量
| 函数/变量   | 类型说明   | 描述                                          |
|-------------+------------+-----------------------------------------------|
| argv        | 字符串列表 | 传递给命令行的参数,包括脚本名称               |
| exit([arg]) | 函数       | 退出当前程序,可选参数为给定的返回值或错误信息 |
| modules     | 字典       | 映射已经载入的模块名和载入模块的字典          |
| path        | 列表       | 在哪些目录中查找模块的列表                    |
| platform    | 字符串  | 操作系统平台或其他的平台标识符             |
| stdin       | 类文件对象 | 标准输入流                           |
| stdout      | 类文件对象 | 标准输出流                           |
| stderr      | 类文件对象 | 标准错误流                                |
** os模块
os模块为你提供了访问多个操作系统服务的功能. os和os.path模块还包括了一些用于检查,构造,删除目录和文件的函数,以及一些处理路径的函数.

#+CAPTION: os模块中一些重要函数和变量
| 函数/变量                 | 类型   | 描述                                       |
|---------------------------+--------+--------------------------------------------|
| environ                   | 字典   | 对环境变量进行映射                         |
| system(command)           | 函数   | 在子shell中执行command                     |
| sep                       | 字符串 | 路径中的分隔符                             |
| pathsep                   | 字符串 | PATH环境变量中各路径的分隔符               |
| linesep                   | 字符串 | 行分隔符                                   |
| urandom(n)                | 函数   | 返回n字节的加密强随机数据                  |
|                           |        | 若平台不支持,会抛出NotImplementedError异常 |
| mkdir(dir)                | 函数   | 创建目录                                   |
| rmdir(dir)                | 函数   | 删除目录                                   |
| rename(old-name,new-name) | 函数   | 文件重命名                                 |
| remove(file)              | 函数   | 删除文件                                   |
| listdir(dir)              | 函数   | 返回DIR中所有文件的列表                    |
| fork()                    | 函数   | 系统调用fork                                   |

*os模块中没有 =copyfile= 函数,需要使用 =shutil.copyfile= 代替*

#+CAPTION: os.path模块中的一些重要函数与变量
| 函数/变量      | 类型 | 描述               |
|----------------+------+--------------------|
| abspath(path)  | 函数 | 转换PATH为绝对路径 |
| join(dir,path) | 函数 | 合并DIR与PATH      |
| split(path)    | 函数 | 分拆path为目录与文件的元组 |
| splitext(path)  | 函数 | 在文件扩展名处分拆PATH     |
|                 |      |                            |

** fileinput
fileinput模块让你能轻松便利文本文件的所有行. 其中最重要的是 ~fileinput.input~ 函数,它会返回一个用于for循环遍历的对象,可用于遍历多个文件的行.

+ input(files=None,inplace=0,backup='',bufsize=0,mode='r',openhook=None)

  - files指定了遍历哪些文件的内容,默认为遍历传递给程序的参数与stdin

  - inplace为True则表示原地修改原内容,这时对于访问的每一行,需要打印出替代的内容,以返回到当前的输入文件中.

  - backup则指定了当inplace为True时,是否创建原文件的备份.

+ filename()

  返回当前处理的文件路径

+ lineno()

  当前累计处理的行数

+ filelinno()

  当前处理文件的当前行数

+ isfirstline()

  检查最后行是否为文件的第一行

+ isstdin()

  检查当前行是否来自sys.stdin

+ nextfile()

  关闭当前文件,移动到下一个文件

+ close()

  关闭整个文件链,结束迭代.

#+BEGIN_SRC python
  # 为python脚本添加行号

  import fileinput

  for line in fileinput.input(inplace=True):
      line = line.rstrip()
      num = fileinput.filelineno()
      print("%-40s # %2i" % (line,num))
#+END_SRC

** set
集合中的每个元素都是不等的,且和字典一样,集合元素的顺序是无序的.

+ 集合操作
  | A.union(B) 或 A \vert B          | 取两个集合的并集   |
  | A.intersection(B) 或 A&B         | 取两个集合的交集   |
  | A.difference(B)  或 A-B          | 去除在setb中的元素 |
  | A.symmetric_difference(B) 或 A^B | 异或操作           |
  | A.issubset(B) 或 A<=B            | A是否为B的子集     |
  | A.issuperset(B) 或 A>=B          | A是否为B的超集     |
  | A.copy()                         | 复制集合           |
  | A.add(element)                   | 往集合中添加元素 |
  | A.remove(element)                 | 从集合中删除元素   |
  |                                   |                    |

集合是 *可变* 的,因此不能作为字典的键, 而集合本身又只能包含 *不可变* 的值,因此也就不能包含其他集合. 
这时可以使用frozenset类型表示不可变的集合:
#+BEGIN_SRC python
  a = set()
  b = set()
  a.add(b)                        # 抛异常
  a.add(frozenset(b))             # OK
#+END_SRC
** heapq
堆是用于表示优先队列的一种数据结构. 它的特点在于,位于i位置上的元素总比i//2位置处的元素大
#+CAPTION: heapq模块中重要的函数
| 函数                | 描述                             |
|---------------------+----------------------------------|
| heappush(heap,x)    | 将x入堆                          |
| heappop(heap)       | 将堆中最小的元素弹出             |
| heapify(heap)       | 使用任意列表作为参数,并通过尽可能少的移位操作,将其转换为合法的堆 |
| heapreplace(heap,x) | 将堆中最小的元素弹出,同时将x入堆 |
| nlargest(n,iter)     | 返回iter中第n大的元素            |
| nsmallest(n,iter)     | 返回iter中第n小的元素                    |
** time
time模块所包含的函数能够实现以下功能:
+ 获取当前时间
+ 操作时间和日期
+ 从字符串读取时间
+ 格式化时间为字符串.

python中的时间可以用实数或一个包含是9个整数的元组. 其中实数表示从新纪元开始的秒杀,元组的意义如下所示:
| 索引 | 字段         |            值 |
|------+--------------+---------------|
|    0 | 年           |               |
|    1 | 月           |          1-12 |
|    2 | 日           |          1-31 |
|    3 | 时           |          0-23 |
|    4 | 分           |          0-59 |
|    5 | 秒           |    0-61(润秒) |
|    6 | 周           |  0-6(周一为0) |
|    7 | 一年中的天数 |         1-366 |
|    8 | 夏令时       | False,True,-1 |
|      |              |               |

#+CAPTION: time模块中重要的函数
| 函数                      | 描述                                               |
|---------------------------+----------------------------------------------------|
| asctime([tuple])          | 将时间元组转换为字符串,默认为当前时间              |
| localtime([secs])         | 将实数转换为时间元组,默认为当前时间,以本地时间为准 |
| mktime(tuple)             | 将时间元组转换为本地时间                           |
| sleep(secs)               | 休眠secs秒                                         |
| strptime(string[,format]) | 将字符串解析为时间元组                             |
| time()                     | 返回表示当前时间的实数                                        |

** random
#+CAPTION: random模块中的一些重要函数
| 函数                           | 描述                                 |
|--------------------------------+--------------------------------------|
| random()                       | 返回0<=n<1之间的随机实数n            |
| getrandbits(n)                 | 以长整形形式返回n个随机位            |
| uniform(a,b)                   | 返回a<=n<b之间的随机实数             |
| randrange([start],stop,[step]) | 返回range(start,stop,step)中的随机数 |
| choice(seq)                    | 从序列seq中返回随意元素              |
| shuffle(seq[,random])          | 原地打乱seq                          |
| sample(seq,n)                  | 从seq中随机选择n个随机元素                      |

** re

** Collections

*** defaultdict

*** counter

*** deque

*** namedtuple

** enum.Enum
枚举类中的每个常量都是class的唯一实例.
#+BEGIN_SRC python
  from enum import Enum

  Month = Enum('Month', ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'))
#+END_SRC

#+RESULTS:

上面的代码定义了一个Month类型的枚举类.其中预定了12个实例. 这些实例的 =value= 属性为一个int常量,且默认从1开始累加.

访问这些枚举类型的方法有很多
#+BEGIN_SRC python
  print(Month.Jan)
  print(Month['Jan'])
  print(Month(1))
  print(Month(Month.Jan.value))

  for name,member in Month.__members__.items():
      print(name,"=>",member)

#+END_SRC

#+RESULTS:
#+begin_example
Month.Jan
Month.Jan
Month.Jan
Month.Jan
>>> ... ... Jan => Month.Jan
Feb => Month.Feb
Mar => Month.Mar
Apr => Month.Apr
May => Month.May
Jun => Month.Jun
Jul => Month.Jul
Aug => Month.Aug
Sep => Month.Sep
Oct => Month.Oct
Nov => Month.Nov
Dec => Month.Dec
#+end_example

如果需要更精确地控制枚举类型，可以从Enum派生出自定义类：
#+BEGIN_SRC python
  from enum import Enum, unique

  @unique                         # @unique装饰器可以帮助我们检查保证没有重复值。
  class Weekday(Enum):
      Sun = 0 # Sun的value被设定为0
      Mon = 1
      Tue = 2
      Wed = 3
      Thu = 4
      Fri = 5
      Sat = 6

#+END_SRC

** operator模块

** itertools模块

*** chain(*iterables)
依次迭代多个iterables但不会构造包含所有元素的中间列表

*** combinations(iterable,r)
从给定的iterable中生成所有长度为r的组合

*** compress(data,selectors)
对data应用来自的selectors的布尔掩码并从data中返回selectors中对应为真的元素

*** count(start,step)
创建一个无限的值的序列，从start开始，步长为step

*** cycle(iterable)
重复的遍历iterable中的值

*** dropwhile(predicate,iterable)
过滤iterable中的元素，丢弃符合predicate描述的那些元素

*** groupby(iterable,keyfunc)
根据keyfunc函数返回的结果对元素进行分组，并返回一个迭代器

*** permutations(iterable [,r])
返回iterable中r的元素的所有组合

*** product(*iterables)
返回iterables的笛卡尔积的可迭代对象，但不是用嵌套的for循环

*** takewhile(poredicate,iterable)
返回满足predicate条件的iterable中的元素

** functools模块
*** partial实现偏函数应用
1. currying 的概念将函数式编程的概念和默认参数以及可变参数结合在一起。一个带 n 个参数， curried 的函数固化第一个参数为固定参数，并返回另一个带 n-1 个参数函数对象，分别类似于 LISP 的原始函数 car 和 cdr 的行为。Currying 能泛化成为偏函数应用（PFA）， 这种函数将任意数量（顺 序）的参数的函数转化成另一个带剩余参数的函数对象。 
2. 你可以通过使用 functional 模块中的 partial（）函数来创建 PFA:
3. 例如
   #+BEGIN_SRC Python
   from functools import partial
   def add(a,b):return a+b
   add100=partial(add,100)
   add100(1)            #=101
   baseTwo=partial(int,base=2)
   baseTwo('10010')       #=18   要注意的是这里需要关键字参数 base 
                          #baseTwo=int(x,base=2)
   #+END_SRC
*** lru_cache实现memozation
lru_cache不仅仅能实现memoization，而且能够限定缓存的条目数，当缓存的条目数达到最大时，会删除最近最少使用的条目。

此外，该模块还提供了对缓存命中，缺失情况的统计
#+BEGIN_SRC python
  import functools
  import math

  @functiontools.lru_cache(maxsize=2)
  def memoized_sin(x):
      return math.sin(x)
#+END_SRC
=======
** re
*** 正则表达式说明
1. \b匹配一个单词的边界，\B匹配一个单词的中间模式
2. \d匹配十进制数组
3. \w表示字符和数组的集合
4. ？非贪婪操作符，可以用在*、+、？的后面。它的作用是要求正则表达式引擎匹配的字符越少越好。

强烈建议写正则表达式时使用python的r前缀,这样不用考虑字符串的转义问题.
*** re.match(正则,字符串)
match()方法判断是否匹配，如果匹配成功，返回一个Match对象，否则返回None
   
当要从字符串头部开始匹配的时候，不要用re.search('^xxx')的方式，而用re.match('xxx')的方式来匹配

re.search与re.match如果匹配失败，则返回None

5. subn()和sub()一样，但它还返回一个表示替换次数的数字，替换后的字符串和表示替换次数的数字作为一个元组的元素返回
*** re.split(正则,字符串)
1. re模块和正则表达式对象的方法split()与字符串的split()方法相似，前者是根据正则表达式分割字符串，后者是根据固定的字符串分割
2. 需注意，\w和\W这两个表示字母或数字的字符受Unicode标志符号影响
*** re.compile(正则)
编译正则表达式,返回正则表达式的对象,可以使用该对象的match方法去匹配多个字符.
*** Match.group(分组) / Match.groups
获取匹配的分组内容

* 获取帮助
** dir函数
dir函数会将对象(模板的所有函数,类,变量等)的所有特性都列出.

1. dir()作用在实例上（经典类或新式类）时，显示实例变量，还有在实例所在的类及所有它的基类中定义的方法和类属性。 
2. dir()作用在类上（经典类或新式类）时，则显示类以及它的所有基类的__dict__中的内容。但它不会显示定义在元类（metaclass）中的类属性。 
3. dir()作用在模块上时，则显示模块的__dict__的内容。（这没改动）。 
4. dir()不带参数时，则显示调用者的局部变量。（也没改动）。 
5. 关于更多细节:对于那些覆盖了__dict__或__class__属性的对象，就使用它们；出于向后兼容的考虑，如果已定义了__members__和__methods__，则使用它们。 
** help函数
help函数会显示对象的__doc__内容
** type函数
type函数返回一个对象的类型.
#+BEGIN_SRC python
  type('')
  type([])
  type({})
  type(dict)
  type(3)
#+END_SRC

#+RESULTS:
: <class 'str'>
: <class 'list'>
: <class 'dict'>
: <class 'type'>
: <class 'int'>

** id函数
id函数返回任意不同种类对象的唯一id
#+BEGIN_SRC python
  name = "Yasoob"
  id(name)
#+END_SRC

#+RESULTS:
: 
: 2146216544

** inspect模块
inspect模块提供了许多有用的函数,来获取对象信息.

例如:
#+BEGIN_SRC python
  # 查看对象成员

  import inspect
  print(inspect.getmembers(str))
#+END_SRC

#+RESULTS:
: 
: >>> >>> [('__add__', <slot wrapper '__add__' of 'str' objects>), ('__class__', <class 'type'>), ('__contains__', <slot wrapper '__contains__' of 'str' objects>), ('__delattr__', <slot wrapper '__delattr__' of 'object' objects>), ('__dir__', <method '__dir__' of 'object' objects>), ('__doc__', "str(object='') -> str\nstr(bytes_or_buffer[, encoding[, errors]]) -> str\n\nCreate a new string object from the given object. If encoding or\nerrors is specified, then the object must expose a data buffer\nthat will be decoded using the given encoding and error handler.\nOtherwise, returns the result of object.__str__() (if defined)\nor repr(object).\nencoding defaults to sys.getdefaultencoding().\nerrors defaults to 'strict'."), ('__eq__', <slot wrapper '__eq__' of 'str' objects>), ('__format__', <method '__format__' of 'str' objects>), ('__ge__', <slot wrapper '__ge__' of 'str' objects>), ('__getattribute__', <slot wrapper '__getattribute__' of 'str' objects>), ('__getitem__', <slot wrapper '__getitem__' of 'str' objects>), ('__getnewargs__', <method '__getnewargs__' of 'str' objects>), ('__gt__', <slot wrapper '__gt__' of 'str' objects>), ('__hash__', <slot wrapper '__hash__' of 'str' objects>), ('__init__', <slot wrapper '__init__' of 'object' objects>), ('__iter__', <slot wrapper '__iter__' of 'str' objects>), ('__le__', <slot wrapper '__le__' of 'str' objects>), ('__len__', <slot wrapper '__len__' of 'str' objects>), ('__lt__', <slot wrapper '__lt__' of 'str' objects>), ('__mod__', <slot wrapper '__mod__' of 'str' objects>), ('__mul__', <slot wrapper '__mul__' of 'str' objects>), ('__ne__', <slot wrapper '__ne__' of 'str' objects>), ('__new__', <built-in method __new__ of type object at 0x595dd300>), ('__reduce__', <method '__reduce__' of 'object' objects>), ('__reduce_ex__', <method '__reduce_ex__' of 'object' objects>), ('__repr__', <slot wrapper '__repr__' of 'str' objects>), ('__rmod__', <slot wrapper '__rmod__' of 'str' objects>), ('__rmul__', <slot wrapper '__rmul__' of 'str' objects>), ('__setattr__', <slot wrapper '__setattr__' of 'object' objects>), ('__sizeof__', <method '__sizeof__' of 'str' objects>), ('__str__', <slot wrapper '__str__' of 'str' objects>), ('__subclasshook__', <built-in method __subclasshook__ of type object at 0x595dd300>), ('capitalize', <method 'capitalize' of 'str' objects>), ('casefold', <method 'casefold' of 'str' objects>), ('center', <method 'center' of 'str' objects>), ('count', <method 'count' of 'str' objects>), ('encode', <method 'encode' of 'str' objects>), ('endswith', <method 'endswith' of 'str' objects>), ('expandtabs', <method 'expandtabs' of 'str' objects>), ('find', <method 'find' of 'str' objects>), ('format', <method 'format' of 'str' objects>), ('format_map', <method 'format_map' of 'str' objects>), ('index', <method 'index' of 'str' objects>), ('isalnum', <method 'isalnum' of 'str' objects>), ('isalpha', <method 'isalpha' of 'str' objects>), ('isdecimal', <method 'isdecimal' of 'str' objects>), ('isdigit', <method 'isdigit' of 'str' objects>), ('isidentifier', <method 'isidentifier' of 'str' objects>), ('islower', <method 'islower' of 'str' objects>), ('isnumeric', <method 'isnumeric' of 'str' objects>), ('isprintable', <method 'isprintable' of 'str' objects>), ('isspace', <method 'isspace' of 'str' objects>), ('istitle', <method 'istitle' of 'str' objects>), ('isupper', <method 'isupper' of 'str' objects>), ('join', <method 'join' of 'str' objects>), ('ljust', <method 'ljust' of 'str' objects>), ('lower', <method 'lower' of 'str' objects>), ('lstrip', <method 'lstrip' of 'str' objects>), ('maketrans', <built-in method maketrans of type object at 0x595dd300>), ('partition', <method 'partition' of 'str' objects>), ('replace', <method 'replace' of 'str' objects>), ('rfind', <method 'rfind' of 'str' objects>), ('rindex', <method 'rindex' of 'str' objects>), ('rjust', <method 'rjust' of 'str' objects>), ('rpartition', <method 'rpartition' of 'str' objects>), ('rsplit', <method 'rsplit' of 'str' objects>), ('rstrip', <method 'rstrip' of 'str' objects>), ('split', <method 'split' of 'str' objects>), ('splitlines', <method 'splitlines' of 'str' objects>), ('startswith', <method 'startswith' of 'str' objects>), ('strip', <method 'strip' of 'str' objects>), ('swapcase', <method 'swapcase' of 'str' objects>), ('title', <method 'title' of 'str' objects>), ('translate', <method 'translate' of 'str' objects>), ('upper', <method 'upper' of 'str' objects>), ('zfill', <method 'zfill' of 'str' objects>)]

* Local Variables Setting:
# Local Variables:
# org-babel-default-header-args:python: ((:session . "None") (:results . "output") (:exports . "code") (:cache))
# org-babel-python-command: "python3"
# End:

