#+TITLE: docker
#+AUTHOR: DarkSun
#+TAGS: linux docker
#+DATE: [2016-03-22 周二 14:15]
#+OPTIONS: ^:{}
* docker基础说明
** docker images
image是用于创建container的一个静态模板.
** docker registries
用于管理docker image的地方叫做docker registry.

当我们创建了自己的image之后,就可以使用push命令将之上传docker registry.
下次要在另一个机器上使用这个image时,只需要从仓库上pull下来就行了.
** docker containers
container从image创建. 它可以被启动,开始,停止,删除. 每个容器都是相互隔离,安全的平台.

当我们运行 ~docker run -i -t ubunut /bin/bash~ 时,docker在后台运行的操作如下:

1. 如果本地没有ubuntu这个image,则从公有仓库下载
2. 从image创建容器
3. 分配一个文件系统,并在只读的image层外挂载一层可读写的层
4. 从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去
5. 从地址池中配置一个ip地址給容器
6. 执行指定的程序,这里是/bin/bash
7. -i -t 指定标准输入和输出
* docker使用说明
** docker image相关命令
Docker镜像就是一个只读的模板. Docker根据镜像来创建容器.一个镜像包括以下内容:

+ 所有的环境变量(ENV)
+ 当前工作目录(WORKDIR)
+ 定义的开放端口集合(PORT)
+ 所有的卷定义(VOLUME)
+ 容器入口点(ENTRYPOINT)
+ 命令和参数(CMD)
  
Docker镜像呈层级结构，若某些值没有在本层明确指定，则会从上一层镜像中继承。
*** 镜像的实现原理
Docker镜像是怎么实现增量的修改和维护的?
每个镜像都由很多层次构成,Docker使用Union	FS将这些不同的层结合到一个镜像中去.

通常Union	FS有两个用途,一方面可以实现不借助LVM,RAID将多个disk挂到同一个目录下
另一个更常用的就是将一个只读的分支和一个可写的分支联合在一起,Live CD正是基于此方法可以允许在镜像不变的基础上允许用户在其上进行一些写操作.
Docker在AUFS上构建的容器也是利用了类似的原理.
*** 显示本机上的images
#+BEGIN_SRC sh
  sudo docker images
#+END_SRC

在列出的信息中可以看到几个字段信息
  1. 来自哪个仓库,比如ubuntu
  2. tag标签,用来标记来自同一仓库的不通镜像,比如latest
  3. 镜像的id号,此为唯一性标示, *同一id可能具有不通的tag标签*
  4. 创建时间
  5. 创建大小
     
  一个仓库可能有一个image的多个发行版,这样就需要使用tag来指定image. 使用tag的方法是在image后加上冒号和tag: 例如 ~sudo docker run -t -i ubunut:latest /bin.bash~
  
*** 查找images

docker hub上有很多人创建的各种不同的images. 使用 ~docker search~ 来搜索合适的image. 例如
#+BEGIN_SRC sh
    sudo docker search emacs
#+END_SRC

可以看到返回的信息包括image名称,描述,受欢迎程度,是否官方创建,是否自动创建的信息.

根据是否是官方提供,可将镜像资源分为两类:
一种是类似 =centos= 这样的基础镜像,被称为基础或根镜像. 这些基础镜像是由Docker公司创建,验证,支持,提供.这样的镜像往往使用单个单词作为名字.
还有一种类型,比如 =tianon/centos= 镜像，它是由Docker的用户创建并维护的,往往带有用户名称前缀.可以通过前缀 =user_name/= 来指定使用某个用户提供的镜像,比如 =tianon= 用户.

另外,在查找的时候通过 ~-s N~ 参数可以指定仅显示评价为 =N= 星以上的镜像.

*** 自动创建
自动创建(Automated Builds)功能对于需要经常升级镜像内程序来说十分方便.
有时候,用户创建了镜像,安装了某个软件,如果软件发布新版本则需要手动更新镜像.
而自动创建允许用户通过Docker Hub指定跟踪一个目标网站(目前支持GitHub或BitBucket)上的项目,一旦项目发生新的提交,则自动执行创建.

要配置自动创建,包括如下的步骤:
+ 创建并登录 =Docker Hub= 以及目标网站
+ 在目标网站中连接帐户到 =Docker Hub=
+ 在 =Docker Hub= 中配置一个自动创建
+ 选取一个目标网站中的项目(需要含Dockerfile)和分支
+ 指定Dockerfile的位置,并提交创建
+ 之后可以在Docker Hub的自动创建页面中跟踪每次创建的状态
*** 获取images

我们可以使用 ~docker pull~ 命令来预先下载我们需要的image
#+BEGIN_SRC shell
    sudo docker pull ubuntu
#+END_SRC
上述命令实际上相当于
#+BEGIN_SRC shell
  sudo docker pull registry.hub.docker.com/ubuntu:latest
#+END_SRC
即从注册服务器 =registry.hub.docker.com= 的 =ubunut= 仓库下载标记为 =latest= 的镜像.

若官方仓库注册服务器下载太慢,可以从其他仓库下载,但此时需要指定完整的仓库注册服务器地址
#+BEGIN_SRC shell
  sudo docker pull dl.dockerpool.com:5000/ubuntu:12.04
#+END_SRC

每个镜像都有一个摘要值,可以通过  =docker images --digiests= 来查看image对应的摘要
#+BEGIN_SRC shell :results org
  docker images --digests
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
REPOSITORY          TAG                 DIGEST                                                                    IMAGE ID            CREATED             SIZE
silex/emacs         master              sha256:bc8ad6b899387fc145b6dbcc122a744a65903978d859bb18f9edfeebfec2d7c4   14571ed1613d        2 weeks ago         500MB
ubuntu              latest              sha256:5f4bdc3467537cbbe563e80db2c3ec95d548a9145d64453b06939c4592d67b6d   113a43faa138        8 weeks ago         81.1MB
centos              latest              sha256:3b37e941676e3a1f3752e9cdb1d37d1db37c9931fcbdd60339ea5f2134c85c0f   49f7960eb7e4        8 weeks ago         200MB
busybox             latest              sha256:141c253bc4c3fd0a201d32dc1f493bcf3fff003b6df416dea4f41046e0f37d47   8c811b4aec35        2 months ago        1.15MB
#+END_SRC

我们可以使用这个摘要值来下载镜像，这能保证下载镜像的唯一性
#+BEGIN_SRC shell :results org
  docker pull base/archlinux@sha256:ad40853b5a41267138de587391960b9a0f4a3f20c37cb2a5001cd8b797aa0673
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
sha256:ad40853b5a41267138de587391960b9a0f4a3f20c37cb2a5001cd8b797aa0673: Pulling from base/archlinux
dd22593c6335: Pulling fs layer
2d0a93adad2c: Pulling fs layer
a8e30b2d8506: Pulling fs layer
6fa053f065b2: Pulling fs layer
6fa053f065b2: Waiting
2d0a93adad2c: Download complete
6fa053f065b2: Verifying Checksum
6fa053f065b2: Download complete
a8e30b2d8506: Verifying Checksum
a8e30b2d8506: Download complete
dd22593c6335: Download complete
dd22593c6335: Pull complete
2d0a93adad2c: Pull complete
a8e30b2d8506: Pull complete
6fa053f065b2: Pull complete
Digest: sha256:ad40853b5a41267138de587391960b9a0f4a3f20c37cb2a5001cd8b797aa0673
Status: Downloaded newer image for base/archlinux@sha256:ad40853b5a41267138de587391960b9a0f4a3f20c37cb2a5001cd8b797aa0673
#+END_SRC

*** 创建自己的image
有两种方法创建自己的image:

+ 使用 ~docker commit~ 扩展一个image

  1. 先使用 ~docker run~ 根据image启动容器
     #+BEGIN_SRC sh
       sudo docker run -t -i ubuntu /bin/bash
     #+END_SRC

  2. 对容器做出修改后,使用 ~docker commit~ 提交结果到新的image
     #+BEGIN_SRC sh
       # sudo docker commit -m="新容器提交信息" -a="新容器作者" 容器ID image仓库名称[:tag]
       sudo docker commit -m="Installed ruby" -a="darksun" 0b2616b0e5a8 lujun9972/ruby:v2
     #+END_SRC
     
+ 从Dockerfile创建
  
  使用docker commit来扩展一个image比较简单,但它不容易在一个团队中分享它. 

  我们还可以使用 ~docker build~ 来根据dockerfile创建一个新image

  1. 创建一个目录和一个dockerfile
     #+BEGIN_SRC sh
       mkdir ruby
       cd ruby
       touch Dockerfile
       echo "#this is a comment
       FROM ubuntu:latest
       MAINTAINER darksun <lujun9972@gmail.com>
       RUN apt-get -qqy update;exit 0
       RUN apt-get -qqy install ruby ruby-dev
       RUN gem install sinatra" > Dockerfile
     #+END_SRC

     #+RESULTS:

  2. 使用 ~docker build~ 来根据dockerfile创建image
     #+BEGIN_SRC sh
       sudo docker build -t="lujun9972/ruby:v2" .
     #+END_SRC
     使用-t标记来指定新的image名称及tag

     后面的 ~.~ 是Dockerfile所在的目录名称(docker默认在该路径中寻找名为Dockerfile的文件),或者是指向Dockerfile的路径也可以(不一定叫Dockerfile文件),甚至还可以是一个 *git地址！*

     我们可以看到dockfile中的指令被一条条的执行了. 每一步都创建了一个新的容器,当所有的指令都执行完毕之后,返回一个image id,并且所有的中间步骤所产生的容器都被删除和清理了.

     *注意:一个image不能超过127层*

*** 查看别人是怎么创建image的？
=docker history ${image}= 将会返回指定image在构建过程中所有执行过的命令。
#+BEGIN_SRC shell :results org
  docker history lujun9972/archlinuxcn.docker
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT
9462714d994c        6 days ago          /bin/sh -c pacman -Syu --noconfirm && pacman…   10.1MB              
<missing>           6 days ago          /bin/sh -c #(nop) ADD file:924b52f8e9afb079e…   18.7kB              
<missing>           6 days ago          /bin/sh -c #(nop) ADD file:5b1ab05b934898a2a…   3.06kB              
<missing>           6 days ago          /bin/sh -c #(nop)  CMD ["/bin/bash"]            0B                  
<missing>           6 days ago          /bin/sh -c pacman --noconfirm -Syu     && rm…   159MB               
<missing>           6 days ago          /bin/sh -c #(nop)  LABEL maintainer=ArchLinu…   0B                  
<missing>           4 weeks ago         /bin/sh -c #(nop)  CMD ["/bin/bash"]            0B                  
<missing>           4 weeks ago         /bin/sh -c :     && chmod 755 /etc     && pa…   44.9MB              
<missing>           4 weeks ago         /bin/sh -c #(nop) ADD dir:34946d778ee95c934e…   175B                
<missing>           4 weeks ago         /bin/sh -c #(nop) ADD dir:a34d7a3975e195fbec…   414MB               
<missing>           4 weeks ago         /bin/sh -c #(nop)  LABEL maintainer=ArchLinu…   0B                  
#+END_SRC

这里 =CREATED BY= 就是构建每层的命令了，不过你可以看到这些命令都被截断了。 你可以通过 =--no-trunc= 来显示完整的命令。
#+BEGIN_SRC shell :results org
  docker history --no-trunc lujun9972/archlinuxcn.docker
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
IMAGE                                                                     CREATED             CREATED BY                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     SIZE                COMMENT
sha256:9462714d994c154bf9d2f7bb96e00c700cc618f5beff29c3c6a4f176dc9b58ee   6 days ago          /bin/sh -c pacman -Syu --noconfirm && pacman -S archlinuxcn-keyring --noconfirm  && pacman -Scc --noconfirm                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    10.1MB              
<missing>                                                                 6 days ago          /bin/sh -c #(nop) ADD file:924b52f8e9afb079e44786992624eeddb54419139150c58c08f97efb57fc2d6d in /etc/pacman.d/mirrorlist                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        18.7kB              
<missing>                                                                 6 days ago          /bin/sh -c #(nop) ADD file:5b1ab05b934898a2a4c4e65754ad1edbff9bb92efda235332efb1726a550095d in /etc/pacman.conf                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                3.06kB              
<missing>                                                                 6 days ago          /bin/sh -c #(nop)  CMD ["/bin/bash"]                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           0B                  
<missing>                                                                 6 days ago          /bin/sh -c pacman --noconfirm -Syu     && rm -f       /var/cache/pacman/pkg/*       /var/lib/pacman/sync/*       /etc/pacman.d/mirrorlist.pacnew                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               159MB               
<missing>                                                                 6 days ago          /bin/sh -c #(nop)  LABEL maintainer=ArchLinux Dockerimage Maintainers                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          0B                  
<missing>                                                                 4 weeks ago         /bin/sh -c #(nop)  CMD ["/bin/bash"]                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           0B                  
<missing>                                                                 4 weeks ago         /bin/sh -c :     && chmod 755 /etc     && pacman-key --init     && pacman-key --populate archlinux     && pacman --noconfirm -Syu --needed base     && pacman --noconfirm -Rsc          cryptsetup          device-mapper          dhcpcd          iproute2          jfsutils          linux          lvm2          man-db          man-pages          mdadm          nano          netctl          openresolv          pciutils          pcmciautils          reiserfsprogs          s-nail          systemd-sysvcompat          usbutils          vi          xfsprogs     && rm -rf       /usr/share/man/*       /var/cache/pacman/pkg/*       /var/lib/pacman/sync/*       /README       /etc/pacman.d/mirrorlist.pacnew   44.9MB              
<missing>                                                                 4 weeks ago         /bin/sh -c #(nop) ADD dir:34946d778ee95c934e90e13e7f03eaf5ac42ced78fa513349e2a731bd74343eb in /                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                175B                
<missing>                                                                 4 weeks ago         /bin/sh -c #(nop) ADD dir:a34d7a3975e195fbecaeaf0faf050c5a672fe492133dedd8f5256128d5db5010 in /                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                414MB               
<missing>                                                                 4 weeks ago         /bin/sh -c #(nop)  LABEL maintainer=ArchLinux Dockerimage Maintainers                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          0B                  
#+END_SRC

*** 上传images到公共images仓库
使用docker push上传images
#+BEGIN_SRC sh
  sudo docker push lujun9972/ruby
#+END_SRC

需要注意的是: *若仓库实现了角色控制,则上传前需要使用docker login先登录,下载则无需先登录*

*** 删除本地images
使用 ~docker rmi~ 可以删除本地images
#+BEGIN_SRC sh
  sudo docker rmi lujun9972/ruby
#+END_SRC

*** 修改镜像标签
使用 ~docker tag~ 命令可以修改镜像标签,所谓修改镜像标签其实就是 *对镜像进行重命名操作*
#+BEGIN_SRC sh
  sudo dockr tag 5db5f8471261 ouruser/sinatra:devel
#+END_SRC

*** 从本地文件系统导入镜像
要从本地文件系统导入一个镜像，可以使用	openvz（容器虚拟化的先锋技术）的模板来创建

比如，先下载了一个	ubuntu-14.04	的镜像，之后使用以下命令导入:
#+BEGIN_SRC sh
  sudoi cat ubuntu-14.04-x86_64-minimal.tar.gz |docker import - ubuntu:14.04
#+END_SRC

注意: *在删除镜像之前要先用docker rm 删掉依赖于这个镜像的所有容器*

*** 导出镜像到本地文件
使用 ~docker save~ 命令将镜像保存到本地文件
#+BEGIN_SRC sh
  sudo docker save -o ubuntu_latest.tar ubunut:latest
#+END_SRC

*** 载入镜像
可以使用 ~docker load~ 从导出的本地文件中再导入到本地镜像库中
#+BEGIN_SRC sh
  # 将导入镜像以及相关的元数据信息(包括标签等)
  sudo docker load --input ubunut_latest.tar
  # or
  sudo docker load < ubunut_latest.tar
#+END_SRC
** docker container相关命令
简单的说,容器是独立运行的一个或一组应用,以及它们的运行态环境.

容器是从镜像创建的运行实例. 它可以被启动,开始,停止,删除. 每个容器都是相互隔离的,保证安全的平台.

*** 新建并启动容器
使用命令 ~docker run~ 新建并启动一个容器

容器在前台运行时，Docker会在容器初始化时将控制台重定向至STDIN、STDOUT和STDERR.

但我们可以通过 =-a= 参数来控制标准挂载哪些输入输出流，比如
#+BEGIN_SRC shell
  docker run -a stdin -a stdout  --name ubuntu -it ubuntu /bin/bash
#+END_SRC

上面这个命令只挂了标准输入和标准输出，其中
~-t~ 选项让Docker分配一个伪终端并绑定到容器的标准输出上.
~-i~ 则让容器的标准输入保持打开.
~--name 容器名~ 指定容器的名称

需要说明的是，当标准输入/输入是通过重定向或者管道传入容器时，不能使用 =-t= 参数
#+BEGIN_EXAMPLE
  [lujun9972@T430S tmp]$   ls|docker run -it busybox cat
  the input device is not a TTY
  [lujun9972@T430S tmp]$   ls|docker run -i busybox cat
  babel-nRWTJg
  emacs1000
  error.log
  fcitx-socket-:0
  hsperfdata_lujun9972
  info.log
  mozilla_lujun99720
  NutstoreTmp0xyz
  serverauth.ccvtYWQ1RD
  shadowsocks-qt5
  Temp-b0bdb25a-2d64-4f54-946d-f0cd05db2640
#+END_EXAMPLE


更多的时候,需要让Docker容器在后台以守护态（Daemonized）形式运行.此时,可以通过添加 ~-d~参数来实现.
#+BEGIN_SRC sh
  sudo docker run -d ubuntu:latest --name echo /bin/sh -c "while true; do echo hello;sleep 1;done"
#+END_SRC
则该docker容器会在后台一直输出hello

另外，若容器在前台运行，则按下 =C-p C-q= 也会让容器切换到后台来运行

当使用 ~docker run~ 来创建容器时,Docker在后台运行的标准操作包括:

1. 检查本地是否存在指定的镜像,不存在就从公有仓库下载
2. 利用镜像创建并启动一个容器
3. 分配一个文件系统,并在只读的镜像层外挂载一层可读写层
4. 从宿主容器配置的网桥接口中桥接一个虚拟接口到容器中去
5. 从地址池配置一个ip地址給容器
6. 执行用户指定的应用程序
7. 应用程序执行完毕后容器终止
8. 容器也可能被 ~docker stop~ 终止

**** 创建临时容器
在执行 ~docker run~ 时如果添加 =--rm= 标记,则容器会在终止后立刻删除.

*注意 =--rm= 和 =-d= 不能同时使用*

**** 设置命名空间
默认情况下一个容器有自己独立的命名空间，但若需要将容器与主机或者多个容器相互访问时，则可能需要设置命名空间

***** pid命名空间
~--pid="XXX"~ 参数可以设置pid命名空间，相同pid命名空间的容器可以看到彼此的进程。

~--pid="host"~ 表示使用宿主的PID命名空间

***** UTS命名空间
UTS命名空间用来设定主机名和域名

~--uts="XXX"~ 参数可以设置uts命名空间.

~--uts="host"~ 表示使用宿主的UTS命名空间,但一般不推荐这样设置，因为这表示容器具有了修改主机配置文件的权限。

***** IPC命名空间
IPC命名空间提供了相互隔离的命名共享内存、信号灯变量和消息队列

~--ipc="XXX"~ 参数可以设置ipc命名空间

~--ipc="container:<name/id>"~ 使用指定容器的IPC命名空间

~--pid="host"~ 表示使用宿主的ipc命名空间


**** 设备访问权
有时候，在主机和特定容器之间共享设备可能非常重要。通过 =-device= 选项可以指定一个设备挂载进新容器中，比如
#+BEGIN_SRC shell
  docker -it --rm --device /dev/video0:/dev/video1 ubuntu:latest # 挂载位于/dev/video0位置的网络摄像头
#+END_SRC

**** 设置重启策略
docker可以通过 =--restart= 参数设定重启策略，目前支持4种重启策略

+ no :: 退出后不再重启
+ on-failure[:max-retries] :: 当容器失败退出时重启,还可以设定最大重启次数
+ always :: 总是重启，而且每次Docker Daemon启动时都会启动容器
+ unless-stopped :: 类似always，但是在Docker Daemon启动时不会去启动 =stopped= 状态的容器
                    
docker的定时重启策略为指数回退策略，即后一次尝试重启的时间为前一次尝试重启时间的两倍。
我们可以通过下面实验来验证这一点:
#+BEGIN_SRC shell :results org
  docker run -d --name backoff-test --restart always busybox date
  sleep 120
  docker logs -f backoff-test
  docker stop backoff-test
  docker rm backoff-test
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
ae0b8bbd1a1fda8677a1646520fe304fe2cd4ad42f1c2edba216d1d34179a58b
Sun Aug  5 02:15:22 UTC 2018
Sun Aug  5 02:15:23 UTC 2018
Sun Aug  5 02:15:24 UTC 2018
Sun Aug  5 02:15:25 UTC 2018
Sun Aug  5 02:15:26 UTC 2018
Sun Aug  5 02:15:29 UTC 2018
Sun Aug  5 02:15:32 UTC 2018
Sun Aug  5 02:15:39 UTC 2018
Sun Aug  5 02:15:53 UTC 2018
Sun Aug  5 02:16:19 UTC 2018
Sun Aug  5 02:17:11 UTC 2018
backoff-test
backoff-test
#+END_SRC

**** 指定额外的安全选项
Docker在容器创建(docker create)或运行(docker run)时能够通过 =--security-opt= 选项来指定Linux安全模块(LSM)的选项，常见的LSM包括SELinux和AppArmor.

=--security-opt= 选项可以设置多次，其值的格式可以是:

+ label:user:<USERNAME> :: 设置SELinux用户标签
+ label:role:<ROLE> :: 设置SELinux角色标签
+ label:type:<TYPE> :: 设置SELinux的类型标签
+ label:level:<LEVEL> :: 设置SELinux的级别标签
+ label:disable :: 禁用SELinux标签限制
+ label:apparmor:<PROFILE> :: 应用一个AppArmor配置
*** 终止容器
可以使用 ~docker stop~ 来终止一个运行中的容器. 
#+BEGIN_SRC sh
  # sudo docker stop 容器id/容器name  
  sudo docker stop echo
#+END_SRC

可以使用 ~docker kill~ 来立即强制终止一个运行中的容器. 
#+BEGIN_SRC sh
  # sudo docker kill 容器id/容器name  
  sudo docker kill echo
#+END_SRC

默认 ~docker kill~ 会向指定容器发送SIGKILL信号，如果需要向容器发送特定的信号可以使用 =--signal= 参数
#+BEGIN_SRC shell
  docker kill --signal SIGKILL echo
#+END_SRC

*** 重新启动容器
可以利用命令 ~docker start~ 来将一个已经终止的容器启动运行
#+BEGIN_SRC sh
  sudo docker start  echo
#+END_SRC
start可以在启动时完成容器与主机IO流之间的重定向。 其中
+ =-i / --interactive= :: 进入interactive模式,即将挂载stdin
+ =-a / --attach= :: 挂载stdout、stderr并捕获信号

此外, ~docker restart~ 命令会将一个运行态的容器终止,然后再重新启动它
#+BEGIN_SRC sh
  # sudo docker restart 容器id/容器name
  sudo docker restart echo
#+END_SRC

若终止容器时容器内部出现异常，可能导致容器无法正常关闭，则我们可以通过 =-t/--time= 设置N秒后强制杀掉容器，默认为10秒
#+BEGIN_SRC sh
  sudo docker restart -t 5 echo
#+END_SRC

*** 查看容器信息
通过 ~docker ps~ 命令可以查看容器信息

**** 显示正在运行的容器

#+BEGIN_SRC sh
  sudo docker ps
#+END_SRC

**** 显示所有的容器,包括终止状态的容器

#+BEGIN_SRC sh
  sudo docker ps -a
#+END_SRC

**** 根据条件筛选容器

=--filter= 可以用来筛选哪些容器需要被显示，可以从5个维度来筛选

+ id

+ label

+ name

+ exited

+ status :: 可以是 created/restarting/paused/exited
            
            
#+BEGIN_SRC shell :results org
  docker ps -a --filter=status=created
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
CONTAINER ID        IMAGE               COMMAND                   CREATED             STATUS              PORTS               NAMES
98a9d8100fc1        3c09bddc26b1        "/bin/sh -c 'echo \"e…"   11 days ago         Created                                 unruffled_wilson
9103874e80da        5bbbe403001d        "/bin/sh -c 'pacman …"    11 days ago         Created                                 unruffled_ramanujan
#+END_SRC

**** 只输出容器ID
=--quiet= 参数可以只输出容器ID值，这个功能常在编写脚本时使用，比如批量stop/kill容器时
*** 监控容器资源
=docker stats CONTAINER= 可以实时监控容器资源，包括CPU使用率、内存使用率、网络吞吐量等信息
#+BEGIN_SRC shell :results org
  docker stats --no-stream 73380fe0cfb5
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
CONTAINER ID        NAME                     CPU %               MEM USAGE / LIMIT   MEM %               NET I/O             BLOCK I/O           PIDS
73380fe0cfb5        determined_ardinghelli   0.00%               880KiB / 7.5GiB     0.01%               1.26kB / 0B         2.87MB / 0B         1
#+END_SRC

其中 =--no-stream= 表示只统计并显示一次资源数据，而不要实时监控

而 =docker top CONTAINER [ps参数]= 则可以显示容器内运行进程的信息，相当于在容器内执行ps命令
#+BEGIN_SRC shell :results org
  docker top 73380fe0cfb5 axjf
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
PPID                PID                 PGID                SID                 TTY                 TPGID               STAT                UID                 TIME                COMMAND
6812                6830                6830                6830                ?                   -1                  Ss                  0                   0:00                | \_ cat
#+END_SRC

其中 =ps参数= 可以是ps命令可用的任意参数

而相比之下，使用 =docker exec ps= 命令则会多出一个 ps 进程
#+BEGIN_SRC shell :results org
  docker exec 73380fe0cfb5 ps -a
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
PID   USER     TIME  COMMAND
    1 root      0:00 cat
   14 root      0:00 ps -a
#+END_SRC

*** 获取容器的日志信息
**** docker logs命令
要获取容器的输出信息，可以通过 ~docker logs~ 命令
#+BEGIN_SRC sh
  sudo docker logs echo
#+END_SRC

类似 =tail= 命令,使用 ~-f~ 选项可以不断的获取容器的输出信息
#+BEGIN_SRC sh
  sudo docker logs -f echo
#+END_SRC

=--since= 可以用来截取日志，截取的范围是指定时间开始到现在为止所有的日志。时间格式可以是UNIX时间戳，或者是RFC3339时间表达式
#+BEGIN_SRC sh
  sudo docker logs --since "2018-07-04T12:34:53" echo
#+END_SRC

此外，也能使用 =--tail= 来截取最后N条日志
#+BEGIN_SRC sh
  sudo docker logs --tail=20 echo
#+END_SRC


不过要注意的是， =docker logs= 只能获取容器内应用输出到stdin和stderr的日志，若日志输出到了文件中，之只能使用 =docker exec XXX tail yyy= 来变通查看了。
**** 容器的日志引擎
+ json-file

  默认情况下，Docker使用json-file的日志引擎，它会捕获容器中进程的STDOUT和STDERR，将之保存以json的格式保存起来。

  宿主机上拥有root权限的用户可以直接访问容器日志，可以通过下面命令来获取容器的日志路径
  #+BEGIN_SRC shell :results org :dir /ssh:192.168.1.9:
    docker inspect -f '{{.LogPath}}' aria2-service
  #+END_SRC

  #+BEGIN_SRC org
  /var/lib/docker/containers/b017f3306ffd81ba2a2dd36298928c6955d48870281169c396c9175a57bc0b21/b017f3306ffd81ba2a2dd36298928c6955d48870281169c396c9175a57bc0b21-json.log
  #+END_SRC
  
+ syslog

  Docker的另一个日志驱动可以是 syslog, 这中情况下 Docker 会将应用日志发送到宿主机上的syslog.

  用户可以在启动容器时使用 ~--log-driver=syslog~ 来设置,比如
  #+BEGIN_SRC shell :results org
    docker run --rm --log-driver=syslog ubuntu date
  #+END_SRC

  #+RESULTS:
  #+BEGIN_SRC org
  Sun Jul 15 09:53:49 UTC 2018
  #+END_SRC
  
+ none

  Docker还可以将日志驱动设置为 none，这种情况下，Docker会忽略应用程序生成的所有日志：
  #+BEGIN_SRC shell :results org
    docker run --rm --log-driver=none ubuntu date
  #+END_SRC

  #+RESULTS:
  #+BEGIN_SRC org
  Sun Jul 15 09:55:42 UTC 2018
  #+END_SRC

*** 进入容器
在使用 ~-d~ 参数时,容器启动后会进入后台. 若需要进入容器进行操作,则可以使用 ~docker attach~ 命令或 ~nsenter~ 工具
#+BEGIN_SRC sh
  sudo docker run -idt --name ubuntu_d ubuntu:latest
  sudo docker attach ubuntu_d
#+END_SRC
*** 在已运行的容器中运行新的进程
使用 =docker exec [-d] [-i] [-t] 容器名 [command] [args]= 可以在已运行的容器中再运行新的命令。

其中 =-d= =-i= =-t= 跟 =docker run= 中的一样。
*** 导出容器
如果要导出某个容器快照到本地文件,可以使用 ~docker export~ 命令
#+BEGIN_SRC sh
  # sudo docker export 容器id/容器名称
  sudo docker export ubuntu > ubuntu.tar
#+END_SRC

*** 导入容器快照
可以使用 ~docker import~ 从容器快照文件中再导入为镜像
#+BEGIN_SRC sh
  cat ubuntu.tar | sudo docker import - test/ubuntu:v1.0
#+END_SRC

此外,也可以通过指定URL或者某个目录来导入
#+BEGIN_SRC sh
  sudo docker import http://example.com/exampleimage.tgz example/imagerepo
#+END_SRC

*注*:用户既可以使用 ~docker load~ 来导入镜像存储文件到本地镜像库,也可以使用 ~docker import~ 来导入一个容器快照到本地镜像库.
这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息(即仅保存容器当时的快照状态),而镜像存储文件将保存完整记录,体积也要大.
此外,从容器快照文件导入时可以重新指定标签等元数据信息

*** 删除容器
可以使用 ~docker rm~ 来删除一个处于终止状态的容器
#+BEGIN_SRC sh
  sudo docker rm ubuntu
#+END_SRC

若要删除一个运行中的容器,可以添加 ~-f~ 参数. Docker会发送 =SIGKILL= 信号

*** 探测容器/镜像
使用 ~docker inspect~ 来探测容器/镜像参数
#+BEGIN_SRC shell :results org
  docker inspect centos
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
[
    {
        "Id": "sha256:49f7960eb7e4cb46f1a02c1f8174c6fac07ebf1eb6d8deffbcb5c695f1c9edd5",
        "RepoTags": [
            "centos:latest"
        ],
        "RepoDigests": [
            "centos@sha256:3b37e941676e3a1f3752e9cdb1d37d1db37c9931fcbdd60339ea5f2134c85c0f"
        ],
        "Parent": "",
        "Comment": "",
        "Created": "2018-06-04T22:19:34.475342266Z",
        "Container": "ef04c6fb40e53318c38014531a0bb5647e2d659dbe8a5e375374d4bbac57a02d",
        "ContainerConfig": {
            "Hostname": "ef04c6fb40e5",
            "Domainname": "",
            "User": "",
            "AttachStdin": false,
            "AttachStdout": false,
            "AttachStderr": false,
            "Tty": false,
            "OpenStdin": false,
            "StdinOnce": false,
            "Env": [
                "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
            ],
            "Cmd": [
                "/bin/sh",
                "-c",
                "#(nop) ",
                "CMD [\"/bin/bash\"]"
            ],
            "ArgsEscaped": true,
            "Image": "sha256:40ef8420eda09fa48ca36df234cb2b68387b5e13abb352e6390da642afe0351d",
            "Volumes": null,
            "WorkingDir": "",
            "Entrypoint": null,
            "OnBuild": null,
            "Labels": {
                "org.label-schema.schema-version": "= 1.0     org.label-schema.name=CentOS Base Image     org.label-schema.vendor=CentOS     org.label-schema.license=GPLv2     org.label-schema.build-date=20180531"
            }
        },
        "DockerVersion": "17.06.2-ce",
        "Author": "",
        "Config": {
            "Hostname": "",
            "Domainname": "",
            "User": "",
            "AttachStdin": false,
            "AttachStdout": false,
            "AttachStderr": false,
            "Tty": false,
            "OpenStdin": false,
            "StdinOnce": false,
            "Env": [
                "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
            ],
            "Cmd": [
                "/bin/bash"
            ],
            "ArgsEscaped": true,
            "Image": "sha256:40ef8420eda09fa48ca36df234cb2b68387b5e13abb352e6390da642afe0351d",
            "Volumes": null,
            "WorkingDir": "",
            "Entrypoint": null,
            "OnBuild": null,
            "Labels": {
                "org.label-schema.schema-version": "= 1.0     org.label-schema.name=CentOS Base Image     org.label-schema.vendor=CentOS     org.label-schema.license=GPLv2     org.label-schema.build-date=20180531"
            }
        },
        "Architecture": "amd64",
        "Os": "linux",
        "Size": 199671138,
        "VirtualSize": 199671138,
        "GraphDriver": {
            "Data": null,
            "Name": "btrfs"
        },
        "RootFS": {
            "Type": "layers",
            "Layers": [
                "sha256:bcc97fbfc9e1a709f0eb78c1da59caeb65f43dc32cd5deeb12b8c1784e5b8237"
            ]
        },
        "Metadata": {
            "LastTagTime": "0001-01-01T00:00:00Z"
        }
    }
]
#+END_SRC

可以看到docker返回了超级多的信息，但是有时候我们只需要其中的某些信息，则可以使用 =-f= 参数来定义输出
#+BEGIN_SRC shell :results org
  docker inspect -f {{.ContainerConfig.Cmd}} centos
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
[/bin/sh -c #(nop)  CMD ["/bin/bash"]]
#+END_SRC

上面例子中 =.ContainerConfig.Cmd= 返回了一个数组，那么如果我希望获取数组中的某个元素怎么办呢？
这个时候就需要用到 =index= 函数了
#+BEGIN_SRC shell :results org
  docker inspect -f '{{(index .ContainerConfig.Cmd 0)}}' centos
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
/bin/sh
#+END_SRC


*** 对容器进行重命名
docker rename 旧容器名或ID 新容器名

** Docker仓库与仓库注册服务器(registry)
仓库是几种存放镜像文件的场所. 要注意它与仓库注册服务器之间的区别.

+ 一个仓库注册服务器上可以存放多个仓库
+ 一个仓库可能包含多个镜像
+ 一个镜像可以有不同标签

一般来说,仓库可以被认为是一个具体的项目或目录.例如对于仓库地址 =dl.dockerpool.com/ubuntu= 来说, =dl.dockerpool.com= 是注册服务器地址, =ubuntu= 是仓库名.

*** 登录仓库注册服务器
可以通过执行 ~docker login~ 命令来输入用户名、密码和邮箱来完成注册和登录.注册成功后,本地用户目录的 =.dockercfg= 中将保存用户的认证信息.

*** 创建私有仓库
=docker-registry= 是官方提供的工具,可以用于构建私有的镜像仓库.

在安装了Docker后,可以通过获取官方 =registry= 镜像来运行.
#+BEGIN_SRC sh
  sudo docker run -d -p 5000:5000 registry
#+END_SRC
这将使用官方的 =registry= 镜像来启动本地的私有仓库.

用户可以通过指定参数来配置私有仓库位置,例如配置镜像存储到 =Amazon S3= 服务.
#+BEGIN_SRC sh
  sudo docker run \
       -e SETTINGS_FLAVOR=s3 \
       -e AWS_BUCKET=acme-docker \
       -e STORAGE_PATH=/registry \
       -e AWS_KEY=AKIAHSHB43HS3J92MXZ \
       -e AWS_SECRET=xdDowwlK7TJajV1Y7EoOZrmuPEJlHYcNP2k4j49T \
       -e SEARCH_BACKEND=sqlalchemy \
       -p 5000:5000 \
       registry
#+END_SRC

默认情况下,仓库会被创建在容器的 =/tmp/registry= 下.可以通过 ~-v~ 参数来将镜像文件存放在本地的指定路径
#+BEGIN_SRC sh
  sudo docker run -d -p 5000:5000 -v /opt/data/registry:/tmp/registry registry
#+END_SRC

*** 从私有仓库上传,下载,搜索镜像
1. 使用 ~docker tag~ 标记一个镜像的tag
   #+BEGIN_SRC sh
     # sudo docker tag IMAGE[:TAG] [REGISTRYHOST:PORT/][USERNAME/]NAME[:TAG]
     # 其中REGISTRYHOST:PORT为私有仓库的地址与端口
     sudo docker tag ubuntu localhost:5000/ubunut:local
   #+END_SRC

2. 使用 ~docker push~ 上传标记的镜像
   #+BEGIN_SRC sh
     sudo docker push localhost:5000/ubuntu:local   
   #+END_SRC
   
   这一步后,就往本地仓库上传了一个镜像
   #+BEGIN_SRC sh
     # 可以用curl查看仓库中的镜像
     curl http://localhost:5000/v1/search
   #+END_SRC

3. 使用 ~docker pull~ 下载标记的镜像
   #+BEGIN_SRC sh
     sudo docker pull localhost:5000/ubunut:local
   #+END_SRC

*** 仓库配置文件
**** 模板说明
在 =config_sample.yml= 文件中，可以看到一些现成的模板段:
+ common :: 基础配置
+ local :: 存储数据到本地文件系统
+ s3 :: 存储数据到AWS S3中
+ dev :: 使用local模板的基本配置
+ test :: 单元测试使用
+ prod :: 生产环境配置(基本上跟s3配置类似)
+ gcs :: 存储数据到Google的云存储
+ swift :: 存储数据到OpenStack Swift服务
+ glance :: 存储数据到OpenStack Glance服务,本地文件系统为后备
+ glance-swift :: 存储数据到OpenStack Glance服务,Swift为后备
+ elliptics :: 存储数据到Elliptics key/value存储

**** 设置默认模板               
使用某个模板作为默认值,可以添加 =SETTINGS_FLAVOR= 到环境变量中,例如:
#+BEGIN_SRC sh
  export SETTINGS_FLAVOR=dev
#+END_SRC

**** 选项说明

** Docker Volumes

数据卷是一个由UFS文件系统专门设计的特殊目录,它有如下特性:

1. 数据卷可以在容器之间共享和重用

2. 对数据卷的改变是立马生效

3. 数据卷中的数据不会包含在image中

4. 卷会一直存在直到没有容器使用它

*** 添加一个数据卷
使用 ~docker run~ 命令时,使用-v选项来添加一个数据卷. 且一次run中可以多次使用-v来挂载多个数据卷:
#+BEGIN_SRC sh
  # 添加一个新卷到容器的/var/www中
  sudo docker run -d -P --name web -v /var/www lujun9972/apache 
#+END_SRC

*** 挂载主机目录为数据卷
使用 ~-v 主机目录绝对路径:容器路径~ 来挂载主机目录为数据卷
#+BEGIN_SRC sh
  # 挂载主机中的/home/lujun9972/www到容器的/var/www目录
  sudo docker run -d -P --name web -v /home/lujun9972/www:/var/www lujun9972/apache
#+END_SRC

*** 挂载只读数据卷
docker加载的数据卷默认是读写权限,但我们可以通过在 ~-v 容器路径:ro~ 来挂载只读数据卷
#+BEGIN_SRC sh
  # 加了ro之后,就挂载为只读了
  sudo docker run -d -P --name web -v /home/lujun9972/www:/var/www:ro lujun9972/apache
#+END_SRC

*** 挂载一个宿主主机文件作为数据卷
-v标记还可以从主机挂载 *单个文件* 到容器中
#+BEGIN_SRC sh
  sudo docker run --rm -it -v ~/.bash_history:./bash_history ubunut /bin/bash
#+END_SRC

*** 多个容器间共享数据卷
~docker run~ 中使用选项 ~--volumes-from 其他容器~ 来挂载其他容器中的卷,已达到与其他容器共享数据卷的目的.

一般会单独创建一个容器专门用于挂载共享的数据卷
#+BEGIN_SRC sh
  # 创建数据卷容器,该容器专用于挂载共享数据卷
  sudo docker run -d -v /dbdata --name dbdata trainning/posgres echo Data-only container for postgeres

  # 使用--volumes-from挂载/dbdata卷
  sudo docker run -d --volumes-from dbdata --name db1 tranning/postgres
  sudo docker run -d --volumes-from dbdata --name db2 tranning/postgres

  # 甚至可以从其他已经挂载了容器卷的容器来挂载数据卷
  sudo docker run -d --volumes-from db1 --name db3 tranning/postgres
#+END_SRC

如果要删除一个数据卷,必须在删除最后一个还挂载着它的容器时使用 ~docker rm -v~ 命令来指定同时删除关联的容器.

** docker中的网络介绍

*** docker网络相关的命令列表

+ -b BRIDGE / --bridge=BRIDGE :: 桥接配置
+ --bip=CIDR :: 定制docker0的掩码
+ -H SOCKET / --host=SOCKET :: 告诉docker从哪个通道来接受控制container的命令,即指定docker api的地址
+ --icc=true|false :: 当启动docker服务时,默认会添加一条转发策略到iptables的FORWRAD链上,该配置决定了策略为通过还是禁止.
+ --ip-forward=true|false :: 设定系统是否支持转发. 容器要想访问外部网络,需要本地系统的转发支持.
+ --iptables=true|false :: 决定启动docker服务时,是否添加转发策略到iptables的FORWARD链上.(参见--icc选项)
+ --mtu=BYTES :: 指定MTU-接口允许接受的最大传输单元
+ --dns=IP_ADDRESS :: 设定DNS服务器IP
+ --dns-search=DOMAIN :: 设定容器的搜索域,当该选项被设置，在查询时，任何不包括已知顶级域名(比如.com/.cn)的主机名会自动加上该后缀。
+ -h HOSTNAME / --hostname=HOSTNAME :: 主机配置
+ --link=CONTAINER_NAME:ALIAS :: 与其他容器进行互联,其中其他容器在容器中以ALIAS为名
+ --net=bridge|none|container:NAME_OR_ID|host :: 桥接配置
+ -p SPEC / --publish=SPEC :: 映射容器端口到宿主主机
+ -P / --publish-all=true|false :: 映射容器端口到宿主主机

*** docker创建容器网络的过程

1. 创建一对虚拟接口

2. 宿主主机一端使用一个名字比如veth65f9,它是唯一的. 另外一端桥接到默认的docker0,或其他指定的桥接网卡

3. 主机上的veth65f9这种接口映射到新的新容器中的名称,通常为eth0. 在容器这个隔离的network namespace中它是唯一的.

4. 从主机桥接网卡的地址中获取一个空闲地址給eth0使用,并设定默认路由到桥接网卡

5. 完成这些后,容器可以使用eth0虚拟网卡来连接其他容器和其他网络了

*** 映射内部容器端口到host端口
默认情况下,容器可以建立到外部网络的连接,但是外部网络无法连接到容器.

若向容器接受外部连接,则需要在docker run执行的时候就指定对应选项

+ --expose PORT / --expose PORT/tcp / --expose PORT/udp
  
  docker run 命令提供了一个 --expose 选项，能够设置容器想要开放,但没有在Dockerfile中注明的端口.
  
  --expose 注明的端口会添加到 -P 选项的端口列表中。

+ -P --publish-all=true|false

  该选项会映射dockerfile中expose的所有端口,对应的主机端口在49000-49900中随机选择.
  
  要查看具体映射到host中的哪个端口,可以使用 ~docker ps~ 和 ~docker port~ 来查看

+ -p SPEC / --publish=SPEC

  可以指定任意端口从主机映射容器内部

  其中SPEC的格式为 ~ip:hostPort:containerPort或ip::containerPort或hostPort:containerPort~

  docker默认映射了0.0.0.0,标示它接受主机上的所有接口地址. 可以通过 ~-p IP:host_port:container_port~ 或 ~-p IP::port~ 来指定主机上的ip接口

  还可以使用udp标记来指定udp端口
  #+BEGIN_SRC sh
    sudo docker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py
  #+END_SRC

  *如果希望永久改变绑定的主机ip地址,可以在docker配置中指定--ip=IP_ADDRESS*


*** 查看端口映射
使用 ~docker port~ 来查看当前映射的端口设置,还能查看绑定到的地址
#+BEGIN_SRC sh
  docker port ubuntu 5000
#+END_SRC

*** 容器间互联
**** 使用 =--link= 进行互联
运行 ~docker run~ 是使用 =--link= 参数可以让容器之间安全的进行交互.

其语法为 ~--link=CONTAINER_NAME:ALLIAS~

该选项会在创建容器时时候添加一个其他容器CONTAINER_NAME的主机到/etc/hosts文件中, 让新容器的进程可以使用主机名ALIAS就可以连接它.

#+BEGIN_SRC sh
  sudo docker run -d --name db lujun9972/mysql
  sudo docker run -d -P --name web --link db:db lujun9972/webapp python app.py
#+END_SRC

*在通过 ~-icc=false~ 关闭网络访问后,还可以通过 ~--link=CONTAINER_NAME:ALIAS~ 选项来访问容器的开放端口*

Docker 在用 =--link= 连接容器时，还会创建一系列的的环境变量，来帮助启动的容器发现目标容器公开的IP和服务端口。
这些环境变量包括：

+ <ALIAS>_NAME
+ <ALIAS>_PORT
+ <ALIAS>_PORT_<EXPOSEDPORT>_TCP
+ <ALIAS>_PORT_<EXPOSEDPORT>_TCP_PROTO
+ <ALIAS>_PORT_<EXPOSEDPORT>_TCP_PORT
+ <ALIAS>_PORT_<EXPOSEDPORT>_TCP_ADDR

比如
#+BEGIN_SRC shell :results org :dir /ssh:192.168.1.9:
  docker run --rm  --link=aria2-service:test busybox env
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
HOSTNAME=88e33ba5c741
TEST_PORT=tcp://172.17.0.2:6800
TEST_PORT_6800_TCP=tcp://172.17.0.2:6800
TEST_PORT_6800_TCP_ADDR=172.17.0.2
TEST_PORT_6800_TCP_PORT=6800
TEST_PORT_6800_TCP_PROTO=tcp
TEST_PORT_51413_TCP=tcp://172.17.0.2:51413
TEST_PORT_51413_TCP_ADDR=172.17.0.2
TEST_PORT_51413_TCP_PORT=51413
TEST_PORT_51413_TCP_PROTO=tcp
TEST_NAME=/focused_morse/test
HOME=/root
#+END_SRC
**** 使用 --net 共享网络命名空间

+ --net=none

  告诉docker将新容器放在自己的网络堆栈中,但是不要配置它的网络. 其类似vmware的host-only,可以让你创建任何自定义的配置.

+ --net=bridge

  连接到默认的docker0网桥,这是docker启动容器时的默认值

+ --net=host

  告诉docker不要将容器放到隔离的网络堆栈中,即容器直接使用host相同的网络.

  例如,我们可以做个比较：
  #+BEGIN_SRC shell :results org :dir /ssh:192.168.1.9:
    ip link list
  #+END_SRC

  #+BEGIN_SRC org
  1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000
      link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
  2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP mode DEFAULT group default qlen 1000
      link/ether 02:01:57:df:77:3d brd ff:ff:ff:ff:ff:ff
  3: docker0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP mode DEFAULT group default 
      link/ether 02:42:21:ca:10:79 brd ff:ff:ff:ff:ff:ff
  165: vethd96edba@if164: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue master docker0 state UP mode DEFAULT group default 
      link/ether f2:4d:94:b2:68:4a brd ff:ff:ff:ff:ff:ff link-netnsid 2
  227: vetha522e28@if226: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue master docker0 state UP mode DEFAULT group default 
      link/ether 2a:c3:60:73:81:50 brd ff:ff:ff:ff:ff:ff link-netnsid 0
  #+END_SRC
  
  与

  #+BEGIN_SRC shell :results org :dir /ssh:192.168.1.9:
    docker run --rm --net=host busybox ip link list
  #+END_SRC

  #+BEGIN_SRC org
  1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue qlen 1000
      link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
  2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq qlen 1000
      link/ether 02:01:57:df:77:3d brd ff:ff:ff:ff:ff:ff
  3: docker0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue 
      link/ether 02:42:21:ca:10:79 brd ff:ff:ff:ff:ff:ff
  165: vethd96edba@if164: <BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN> mtu 1500 qdisc noqueue master docker0 
      link/ether f2:4d:94:b2:68:4a brd ff:ff:ff:ff:ff:ff
  227: vetha522e28@if226: <BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN> mtu 1500 qdisc noqueue master docker0 
      link/ether 2a:c3:60:73:81:50 brd ff:ff:ff:ff:ff:ff
  #+END_SRC
  
  这两个的输出是一样的

+ --net=container:NAME_OR_ID

  告诉docker将新容器进程放到一个已存在容器的网络命名空间中,两者共享ip地址和端口,他们之间还可以通过环回接口通信.

  例如,我们可以做个比较：
  #+BEGIN_SRC shell :results org :dir /ssh:192.168.1.9:
    docker exec top ip link list
  #+END_SRC

  #+BEGIN_SRC org
  1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue qlen 1000
      link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
  246: eth0@if247: <BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN> mtu 1500 qdisc noqueue 
      link/ether 02:42:ac:11:00:04 brd ff:ff:ff:ff:ff:ff
  #+END_SRC
  
  与
  #+BEGIN_SRC shell :results org :dir /ssh:192.168.1.9:
    docker run --rm --net=container:top busybox ip link list
  #+END_SRC

  #+BEGIN_SRC org
  1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue qlen 1000
      link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
  246: eth0@if247: <BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN> mtu 1500 qdisc noqueue 
      link/ether 02:42:ac:11:00:04 brd ff:ff:ff:ff:ff:ff
  #+END_SRC
  
  结果是一样的

*** 配置DNS

docker通过使用host主机上的 ~/etc/hostname~, ~/etc/hosts~, ~/etc/resolv.conf~ 覆盖容器中的这三个文件,这样方式来为容器提供主机和DNS配置.

docker提供了一些选项来动态的配置他们:

+ -h HOSTNAME / --hostname-HOSTNAME

  设定容器的主机名,它会被写到/etc/hostname, /etc/hosts中的ip地址自动写成分配的ip地址, 在/bin/bash中显示该主机名.

  但它不会在docker ps中显示,也不会再其他的容器的/etc/hosts中显示

+ --link=CONTAINER_NAME:ALLIAS

  该选项会在创建容器时时候添加一个其他容器CONTAINER_NAME的主机到/etc/hosts文件中, 让新容器的进程可以使用主机名ALIAS就可以连接它.

+ --dns=IP_ADDRESS

  添加dns服务器到容器的/etc/resolv.conf中,让容器用这ip地址来解析所有不在/etc/hosts中的主机名,可以在启动Docker后台进程时用来设置默认值。

+ --dns-search=DOMAIN

  设定容器的搜索域, 例如,当搜索域为.example.com时,会在搜索host主机名时,DNS不仅搜索host,还会搜索host.example.com,可以在启动Docker后台进程时用来设置默认值。

+ --add-host=HOST:IP

  自定义主机到IP地址的映射关系，可以设置多次以配置多个映射关系，但不能在启动Docker后台进程时设置默认值。
*** 定制docker0
docker服务默认会创建一个docker0接口,用于在linux内核层桥接所有容器的虚拟网卡和host物理网卡.

docker允许指定docker0的ip地址和子网掩码,还能定义MTU(接口允许接受的最大传输单元)

+ --bip=CIDR

  其中CIDR的格式为 ~IP地址/掩码~ (例如192.168.1.5/24)

+ --mtu=BYTES

  设定MTU大小为BYTES字节,

*可以在docker配置文件中配置DOCKER_OPTS,然后重启来改变这些参数*

当容器启动后,可以使用brctl来确认他们是否已经连接到docker0网桥
#+BEGIN_SRC sh
  sudo brctl show
#+END_SRC

*** 创建自己的桥接
如果希望完全使用自己的桥接设置,可以在启动docker服务的时候,使用 ~-b BRIDGE~ 或 ~--bridge=BRIDGE~ 来告诉docker使用哪个网桥.

如果服务已经启动,旧的网桥还在使用中,那需要先停止服务,再删除旧的网桥

1. 停止旧网桥并删除
   #+BEGIN_SRC sh
     sudo service docker stop
     sudo ip link set dev docker0 down
     sudo brctl delbr docker0
   #+END_SRC

2. 创建自己的网桥
   #+BEGIN_SRC sh
     sudo brctl addbr bridge0
     sudo ip addr add 192.168.5.1/24 dev bridge0
     sudo ip link set dev bridge0 up
   #+END_SRC

3. 确认网桥启动
   #+BEGIN_SRC sh
     ip addr show bridge0
   #+END_SRC

4. 告诉docker桥接设置,并启动docker服务
   #+BEGIN_SRC sh
     echo 'DOCKER_OPTS="-b=bridge0"'>>/etc/default/docker
     sudo service docker start
   #+END_SRC

   
* 资源限制

** CPU

+ --cpu-share=权重 / -c 权重 :: 当运行多个docker容器时，会根据各个容器的权重分配CPU资源，默认权重为1024
+ --cpuset-cpus=0,1 :: 设置在哪些CPU上运行容器
** 内存

+ -m 128M :: 限制容器的内存使用量
+ --memory-swap 256M :: 限制容器内存和swap的总使用量
** IO

+ --device-read-bps list  :: 各磁盘的读取速率限制(bytes per second),默认为[]
+ --device-read-iops list :: 各磁盘读取次数的限制 (IO per second),默认为 []
+ --device-write-bps list :: 各磁盘的写入速率限制(bytes per second),默认为[]
+ --device-write-iops list :: 各磁盘写入次数的限制 (IO per second),默认为 []       Limit write rate (IO per second) to a device (default [])
* Dockerfile编写说明
1. 新建一个目录和Dockerfile

2. Dockerfile中每一条指定都会创建一层镜像

3. 当所有的指令都执行完毕之后,返回最终的镜像id. 所有的中间步骤产生的容器都被删除和清理了.

4. 注意,一个镜像不能超过127层

5. 注意，docker build构建镜像时会把指定目录(一般为Dockerfile所在目录)作为构建环境的上下文通过tar文件传递给Docker守护进程。
   docker的CS架构，使得只有构建环境上下文中的文件/目录才能被ADD/COPY命令所应用。
   为了从构建环境的上下文中排除不必要的文件，可以使用 =.dockerignore= 文件

** Dockerfile基础语法
+ =#= 用来注释
+ =FROM= 告诉Docker使用哪个镜像作为基础
+ =MAINTAINER= 指定维护者信息
+ =RUN= 指令会在创建镜像的过程中运行
+ =ADD= 命令复制本地文件到镜像
+ =EXPOSE= 命令向外部开发端口
+ =CMD= 命令来描述容器启动后运行的程序.
Dockerfile由一行行命令语句组成,并且支持以 =#= 开头的注释行.

一般的,Dockerfile分为四部分:基础镜像信息,维护者信息,镜像操作指令和容器启动时执行指令.

** 基础镜像信息

*** FROM
第一条指令必须为FROM指令, 指定该镜像是以哪个image为基础镜像的.

如果在同一个Dockerfile中创建多个镜像,则可以使用多个FROM指令.

+ FROM image
  
+ FROM image:tag

** 维护者信息

*** MAINTAINER
指定维护者信息

+ MAINTAINER name

** 镜像操作指令
*** RUN
每条 ~RUN~ 指定都将在当前镜像基础上执行指定命令,并提交为新的镜像.当命令较长时可以使用 =\= 来换行

+ RUN command :: 在shell终端中运行命令,即 =/bin/sh -c=, *这也意味着镜像中必须包含/bin/sh才行*
  
+ RUN ["executable","param1","param2"...] :: 使用exec执行, *这种情况下则需要注意环境变量的问题，它不会加载环境变量中的数据*
     

*** EXPOSE
告诉Docker服务端容器暴露的端口号,供互联系统使用. 在启动容器时需要 =-P= 选项,Docker主机会自动分配一个端口转发到指定的端口.

可以一次暴露多个端口

+ EXPOSE port [port...]

*** ENV
指定一个环境变量,会被后续 ~RUN~ 指令使用,并在容器运行时保持

+ ENV key value
  
+ ENV key1=value1 key2=value2 ...

ENV声明的环境变量不仅对产生的容器有效，而且还能够在其他Dockerfile的指令中使用，例如
#+BEGIN_EXAMPLE
  ENV VERSION="1.0"
  LABEL base.version=${VERSION}
#+END_EXAMPLE

*** ARG

类似ENV，ARG能够指定构建镜像时的变量，该变量能够在在其他Dockerfile的指令中使用，但与ENV不同的是，它不能在容器中被访问。例如
#+BEGIN_SRC shell
  ARG _USER="arch"
  ARG _UID="1000"
  RUN useradd -m  -u ${_UID}  ${_USER}
#+END_SRC

Docker引入ARG的意义在于，ARG中指定的参数值可以被 =docker build= 中的 =--build-arg= 参数所覆盖，从而起到动态构建镜像的目的

比如下面这个构建语句使用当前用户的用户名和UID来替代Dockerfile中的_USER和_UID的值
#+BEGIN_SRC shell
  docker build --tag test_arg --build-arg=_USER=$USER --build-arg=_UID=$UID .
#+END_SRC

*** ADD
#+BEGIN_EXAMPLE
  ADD src dest
#+END_EXAMPLE

将复制指定的<src>到容器中的<dest>. 其中<src>可以是Dockerfile所在目录的一个相对路径也可以是一个URL,还可以是一个tar文件(会自动解压为目录)
在src标记的路径中，还支持通配符

<dest>是容器中的一个目录，且若 <dest>目录不存在，ADD命令会自动创建该目录

1. src指定的路径必须存在于Dockerfile所在目录。

   例如，下面所给定的路径就是非法路径：
   #+BEGIN_EXAMPLE
     ADD ../something /something
   #+END_EXAMPLE

   因为在Dockerfile执行时，Docker Daemon会读取Dockerfile所在目录的所有数据。如果ADD命令使用的文件在此目录中不存在，那么Daemon将找不到指定文件。

2. 如果src指定的是URL，并且dest所指定的路径没有以“/”结尾，那么URL下载的数据将直接覆盖dest所给定的文件。

3. 如果src指定的是URL，并且dest所指定的路径是以“/”结尾的。那么URL下载后的数据将直接写入dest所指定的目录中，例如：

   #+BEGIN_EXAMPLE
     ADD http://example.com/foobar /
   #+END_EXAMPLE

   ADD命令将会下载foobar目录，并且将此目录放入容器的根目录，结果是在容器中出现/footbar目录。

4. 如果src指向的是一个目录，那么ADD指令将包括元数据在内的所有数据复制到容器中dest所指定的文件中，但src所指定的目录本身不会被复制进去，只会复制此目录下的文件。

5. 如果src指向的是一个已知格式的压缩文件，例如，gzip、bzip2或者xz格式的文件。当添加到容器之后，会自动执行解压缩动作。而从URL中下载的压缩文件则不会执行解压缩。

6. 如果src使用通配符指定了多个文件，那么此时dest必须是一个以“/”结尾的目录。

7. 如果dest指向的路径没有以“/”结尾，那么这个路径指向的文件将会被src指定的文件覆盖。

8. 如果dest指向的路径不存在，那么此路径中所涉及的父级目录都将会被创建。

9. 当src指向的URL没有下载权限时，首先需要使用RUN wget或者RUN curl获取文件。

10. 当ADD命令所标记的文件发生变化时，从变化的那个ADD命令开始，保存在缓存中的镜像将会失效，同时RUN命令产生的缓存镜像也会失效。

*** COPY
复制本地主机的<src>(必须为Dockerfile所在目录的相对路径)到容器中的<dest>

#+BEGIN_EXAMPLE
  COPY src dest
#+END_EXAMPLE

1. src指定的路径必须存在于Dockerfile所在目录。

   例如，下面所给定的路径就是非法路径：
   #+BEGIN_EXAMPLE
     ADD ../something /something
   #+END_EXAMPLE

   当Dockerfile执行时，Docker Daemon会读取Dockerfile所在目录的所有数据。所以如果COPY命令指定的文件在此目录中不存在，那么Daemon将找不到指定文件。

2. 如果src指向的是一个目录，那么COPY命令将包括元数据在内的所有数据复制到容器中dest所指定的文件中。但src所指定的目录本身不会被复制进去，只会复制此目录下的文件。

3. 如果src使用通配符指定了多个文件，那么此时dest必须是一个以“/”结尾的目录。

4. 如果dest指向的路径没有以“/”结尾，那么这个路径指向的文件将会被src指定的文件覆盖。

5. 如果dest指向的路径不存在，那么此路径中所涉及的父级目录都将会被创建。

6. 如果使用STDIN输入Dockerfile内容，那么COPY命令将失效，例如：

   #+BEGIN_EXAMPLE
     Docker build - < somefile
   #+END_EXAMPLE

   此时COPY命令将无法使用。
*** VOLUME
创建一个可以从本地主机或其他容器挂载的挂载点,一般用来存放数据库和需要保持的数据等

+ VOLUME ["/volume-dir"]
  
注意： *在Dockerfile中声明挂载点后，那么以后对该挂载点中文件的操作都不会生效！* 因此一般来说只会在 =Dockerfile= 结尾处声明挂载点。

*** WORKDIR
为后续的 ~RUN~, ~CMD~, ~ENTRYPOINT~ 指令配置工作目录.

可以使用多个 ~WORKDIR~ 指令,后续命令如果参数是相对路径,则会基于之前命令指定的路径.

+ WORKDIR /path/to/workdir

*** ONBUILD
配置当所创建的镜像作为其它新创建镜像的基础镜像时,所执行的操作指令

使用 ~ONBUILD~ 指令的镜像,推荐在标签中注明,例如 ruby:1.9-onbuild

一个Dockerfile可以有多个 ~ONBUILD~ 指令, 当镜像作为其他镜像的基础镜像时,会依次执行这些指令

+ ONBUILD [INSTRUCTION]

** 容器启动时执行指令
*** CMD

指定启动容器时执行的命令,每个 =Dockerfile= 只能有一条 ~CMD~ 命令. 如果指定了多条命令,只有最后一条会被执行.

如果用户启动容器时候指定了运行的命令,则会覆盖掉 ~CMD~ 指定的命令.

+ CMD ["executable","param1","param2"] :: 使用 =exec= 执行,推荐使用这种方式
+ CMD command param1 param2 :: 在 =/bin/sh= 中执行,提供给需要交互的应用
+ CMD ["param1","param2"] :: 提供给 ~ENTRYPOINT~ 的默认参数；

*** ENTRYPOINT
:PROPERTIES:
:ID:       kr5d4wq0r6h0
:END:
配置容器启动后执行的命令,并且它会被 ~docker run~ 的 =--entrypoint= 参数替代，而不会被 ~docker run~ 提供的直接参数覆盖.

每个Dockerfile中只能有一个 ~ENTRYPOINT~,当指定多个时,只有最后一个起效.

+ ENTRYPOINT ["executable","param1","param2"] :: =exec= 方式执行
+ ENTRYPOINT command param1 param2 :: 使用 =/bin/sh -c= 方式执行

     
当使用 *第一种设定方法* 时，ENTRYPOINT 和 CMD 可以放在一起连用
#+BEGIN_EXAMPLE
  ENTRYPINT["cmd", "parm1"]
  CMD["optional-parm1","optional-parm2"]
#+END_EXAMPLE

而如果 ENTRYPOINT 使用了shell格式，那么CMD指令提供的所有其他参数以及docker run命令运行时指定的额外参数都会被忽略！

在该容器运行时，默认是调用的 =cmd parm1 optional-parm1 optional-parm2=
但若指定了运行参数，则会变成 =cmd parm1 other-parm1 other-parm2=

若使用第二种方法， *则ENTRYPOINT设定的二进制命令会忽略来自于CMD和RUN命令所添加的参数*

为了确保容器可以正确处理 =docker stop= 命令发来的 SIG 信号，Docker建议用第一种方法来启动二进制文件
*** USER
指定运行容器时的用户名或UID,后续的 ~RUN~ 也会使用指定用户.

当服务不需要管理员权限时,可以通过该命令指定运行用户.并且可以在之前创建所需要的用户.

+ USER user-name
  
在没有使用 =--userns-remap= 来映射USER namespace的情况下，容器中的用户和主机上的用户共享同一个用户ID空间。例如
#+BEGIN_SRC shell
  echo "hello" >/tmp/test.txt
  chmod 600 /tmp/test.txt
  sudo chown root:root /tmp/test.txt
  docker run --rm -v /tmp/test.txt:/tmp/test.txt -u nobody ubuntu cat /tmp/test.txt # 会提示无权限
  docker run --rm -v /tmp/test.txt:/tmp/test.txt -u root ubuntu cat /tmp/test.txt # 运行正常

#+END_SRC


* Docker Restful命令
默认情况下Docker监听的是本地unix:///var/run/docker.sock文件。

因此访问Docker Restful命令的一般格式为
#+BEGIN_SRC shell
  curl --unix-socket /var/run/docker.sock http://localhost/${url}
#+END_SRC

或者
#+BEGIN_SRC shell
  curl --unix-socket /var/run/docker.sock -d "XXXXXXX" http://localhost/${url}
#+END_SRC

* Docker Compose
docker-compose可以将多个容器组成一项服务来进行统一管理
#+BEGIN_SRC shell :results org
  docker-compose --help
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
Define and run multi-container applications with Docker.

Usage:
  docker-compose [-f <arg>...] [options] [COMMAND] [ARGS...]
  docker-compose -h|--help

Options:
  -f, --file FILE             Specify an alternate compose file
                              (default: docker-compose.yml)
  -p, --project-name NAME     Specify an alternate project name
                              (default: directory name)
  --verbose                   Show more output
  --log-level LEVEL           Set log level (DEBUG, INFO, WARNING, ERROR, CRITICAL)
  --no-ansi                   Do not print ANSI control characters
  -v, --version               Print version and exit
  -H, --host HOST             Daemon socket to connect to

  --tls                       Use TLS; implied by --tlsverify
  --tlscacert CA_PATH         Trust certs signed only by this CA
  --tlscert CLIENT_CERT_PATH  Path to TLS certificate file
  --tlskey TLS_KEY_PATH       Path to TLS key file
  --tlsverify                 Use TLS and verify the remote
  --skip-hostname-check       Don't check the daemon's hostname against the
                              name specified in the client certificate
  --project-directory PATH    Specify an alternate working directory
                              (default: the path of the Compose file)
  --compatibility             If set, Compose will attempt to convert deploy
                              keys in v3 files to their non-Swarm equivalent

Commands:
  build              Build or rebuild services
  bundle             Generate a Docker bundle from the Compose file
  config             Validate and view the Compose file
  create             Create services
  down               Stop and remove containers, networks, images, and volumes
  events             Receive real time events from containers
  exec               Execute a command in a running container
  help               Get help on a command
  images             List images
  kill               Kill containers
  logs               View output from containers
  pause              Pause services
  port               Print the public port for a port binding
  ps                 List containers
  pull               Pull service images
  push               Push service images
  restart            Restart services
  rm                 Remove stopped containers
  run                Run a one-off command
  scale              Set number of containers for a service
  start              Start services
  stop               Stop services
  top                Display the running processes
  unpause            Unpause services
  up                 Create and start containers
  version            Show the Docker-Compose version information
#+END_SRC
* Docker Machine
Docker Machine是Docker官方提供的一个帮助我们在远程机器上安装Docker和在本地安装带Docker的虚拟机的工具。
我们还可以通过docker=machine命令来对远程主机的Docker进行管理。

Docker Machine自带了很多驱动，这些驱动将不同的虚拟机引擎与云服务商与Docker Machine整合在一起。
Docker Machine自带的驱动有:
#+BEGIN_EXAMPLE
  amazonec2        digitalocean     generic          hyperv           rackspace        virtualbox       vmwarevcloudair
  azure            exoscale         google           openstack        softlayer        vmwarefusion     vmwarevsphere
#+END_EXAMPLE

** 在本地创建带Docker的虚拟机
通过 =docker-machine create= 命令可以创建主机并安装虚拟机，比如下面命令会创建三个使用VirtualBox驱动的主机并且在每台主机上安装好Docker
#+BEGIN_SRC shell :results org
  docker-machine create --driver virtualbox host1
  docker-machine create --driver virtualbox host2
  docker-machine create --driver virtualbox host3
#+END_SRC

#+BEGIN_SRC org
Running pre-create checks...
Creating machine...
(host1) Copying /home/lujun9972/.docker/machine/cache/boot2docker.iso to /home/lujun9972/.docker/machine/machines/host1/boot2docker.iso...
(host1) Creating VirtualBox VM...
(host1) Creating SSH key...
(host1) Starting the VM...
(host1) Check network to re-create if needed...
(host1) Waiting for an IP...
Waiting for machine to be running, this may take a few minutes...
Detecting operating system of created instance...
Waiting for SSH to be available...
Detecting the provisioner...
Provisioning with boot2docker...
Copying certs to the local machine directory...
Copying certs to the remote machine...
Setting Docker configuration on the remote daemon...
Checking connection to Docker...
Docker is up and running!
To see how to connect your Docker Client to the Docker Engine running on this virtual machine, run: docker-machine env host1
Running pre-create checks...
Creating machine...
(host2) Copying /home/lujun9972/.docker/machine/cache/boot2docker.iso to /home/lujun9972/.docker/machine/machines/host2/boot2docker.iso...
(host2) Creating VirtualBox VM...
(host2) Creating SSH key...
(host2) Starting the VM...
(host2) Check network to re-create if needed...
(host2) Waiting for an IP...
Waiting for machine to be running, this may take a few minutes...
Detecting operating system of created instance...
Waiting for SSH to be available...
Detecting the provisioner...
Provisioning with boot2docker...
Copying certs to the local machine directory...
Copying certs to the remote machine...
Setting Docker configuration on the remote daemon...
Checking connection to Docker...
Docker is up and running!
To see how to connect your Docker Client to the Docker Engine running on this virtual machine, run: docker-machine env host2
Running pre-create checks...
Creating machine...
(host3) Copying /home/lujun9972/.docker/machine/cache/boot2docker.iso to /home/lujun9972/.docker/machine/machines/host3/boot2docker.iso...
(host3) Creating VirtualBox VM...
(host3) Creating SSH key...
(host3) Starting the VM...
(host3) Check network to re-create if needed...
(host3) Waiting for an IP...
Waiting for machine to be running, this may take a few minutes...
Detecting operating system of created instance...
Waiting for SSH to be available...
Detecting the provisioner...
Provisioning with boot2docker...
Copying certs to the local machine directory...
Copying certs to the remote machine...
Setting Docker configuration on the remote daemon...
Checking connection to Docker...
Docker is up and running!
To see how to connect your Docker Client to the Docker Engine running on this virtual machine, run: docker-machine env host3
#+END_SRC

同时，你会发现virtualbox创建了名为host1,host2,host3的三台主机
#+BEGIN_SRC shell :results org
  vboxmanage list vms
#+END_SRC 

#+BEGIN_SRC org
"winxp_default_1529148278389_22373" {5d100a8e-a670-4f84-8ea4-eb22f3dab94d}
"win7" {dddcdefb-5002-4bcd-bef2-ee37f0ba6197}
"rhel7.5" {bbf01330-070b-4663-b8e3-52734297c112}
"redis-host" {f5576790-7d12-4ee8-884f-7352c04f4e04}
"rhel_default_1532386536492_17873" {449040f4-21ef-436d-8648-a4026a547875}
"centos_default_1532472936791_11249" {86ffd1ee-681a-4062-a233-e29ac966fc81}
"freebsd" {2924b43b-da8b-4f59-ac32-ee4420923055}
"RHEL7" {33e98062-f82e-49df-9a8a-91b0eb31e80d}
"arch_default_1532990644081_68335" {2d5206ba-c07a-4691-8c3b-63e941113f15}
"ctf-tools_default_1533510374954_98487" {edd5c5d6-95e5-47af-a462-1d66aab8e640}
"host1" {ee738687-3981-4582-b2d3-3540a1cbff1c}
"host2" {d2907cef-5018-4476-a6e8-5e7c1c321cfe}
"host3" {222d485e-26c2-46e8-bc6e-cfc490d4c34a}
#+END_SRC

** 在远程主机上安装Docker

若远程主机是在Docker Machine支持的云服务商的，那么可以直接通过对应的驱动来帮助安装Docker，方法跟上面很类似。

然若远程主机并不是在云服务商上，或者是Docker Machine所不支持的云服务商，那么可以通过 =generic= 驱动来进行安装。

在使用 =generic= 进行远程安装前，我们需要一些准备工作:

1. 在目标主机创建一个无需输入密码即可sudo操作的用户
   #+BEGIN_SRC shell
     sudo adduser ${user}
     sudo usermod -a -G sudo wheel ${user}
     echo "${user} ALL=(ALL:ALL) NOPASSWD: ALL" >>/etc/sudoers
   #+END_SRC

2. 在目标主机上添加密钥认证，使得登陆远程主机不同输入密码
   #+BEGIN_SRC shell
     ssh-copy-id ${user}@${remote_host}
   #+END_SRC

   
准备工作完成后，我们可以在本地主机上运行下面命令
#+BEGIN_SRC shell
  docker-machine create -d generic \
      --generic-ip-address=xxx.xxx.xxx.xxx \
      --generic-ssh-user=${user} \
      --generic-ssh-key ~/.ssh/id_rsa \
      ${name}
#+END_SRC

其中 =${name}= 就是 Docker-Machine 用来管理目标主机上Docker的一个指代名称。

** 管理Docker Machine

*** 查看被管主机信息
Docker Machine可以用来列出、检查和升级被管主机，我们可以通过 =ls= 子命令来获得被管理的机器列表
#+BEGIN_SRC shell :results org
  docker-machine ls
#+END_SRC

#+BEGIN_SRC org
NAME         ACTIVE   DRIVER       STATE     URL                         SWARM   DOCKER        ERRORS
host1        -        virtualbox   Running   tcp://192.168.99.100:2376           v18.06.0-ce   
host2        -        virtualbox   Running   tcp://192.168.99.101:2376           v18.06.0-ce   
host3        -        virtualbox   Running   tcp://192.168.99.102:2376           v18.06.0-ce   
redis-host   -        virtualbox   Stopped                                       Unknown       
#+END_SRC

这个命令列出了每台被管主机的名称、创建时的驱动、状态、以及Docker Daemon访问的URL。
ACTIVE这一列若带星号，则表示这台机器是活跃的，也就是任何在本地运行的docker命令连接上的都是活跃机器上的Docker Daemon。

类似于 =docker=, 我们也可以使用 =inspect= 子命令来查看某台主机的配置
#+BEGIN_SRC shell :results org
  docker-machine inspect --format "{{.Driver.IPAddress}}" host2
#+END_SRC

#+BEGIN_SRC org
192.168.99.101
#+END_SRC

当然，如果只是想看被管主机IP，那么可以直接通过 =ip= 子命令来查看
#+BEGIN_SRC shell :results org
  docker-machine ip host2
#+END_SRC

#+BEGIN_SRC org
192.168.99.101
#+END_SRC


*** 升级被管主机
#+BEGIN_SRC shell :results org
  docker-machine upgrade host1
#+END_SRC

#+BEGIN_SRC org
Waiting for SSH to be available...
Detecting the provisioner...
Upgrading docker...
Stopping machine to do the upgrade...
Upgrading machine "host1"...
Copying /home/lujun9972/.docker/machine/cache/boot2docker.iso to /home/lujun9972/.docker/machine/machines/host1/boot2docker.iso...
Starting machine back up...
(host1) Check network to re-create if needed...
(host1) Waiting for an IP...
Restarting docker...
#+END_SRC

*** 停止被管主机
使用 =stop= 子命令来停止被管主机
#+BEGIN_SRC shell :results org
  docker-machine stop host2
#+END_SRC

#+BEGIN_SRC org
Stopping "host2"...
Machine "host2" was stopped.
#+END_SRC

如果使用 =stop= 子命令迟迟无法关闭被管主机，那么也可以直接使用 =kill= 命令来强制关机

*** 启动被管主机
使用 =start= 子命令来启动被停止的主机
#+BEGIN_SRC shell :results org
  docker-machine start host2
#+END_SRC

#+BEGIN_SRC org
Starting "host2"...
(host2) Check network to re-create if needed...
(host2) Waiting for an IP...
Machine "host2" was started.
Waiting for SSH to be available...
Detecting the provisioner...
Started machines may have new IP addresses. You may need to re-run the `docker-machine env` command.
#+END_SRC

*** 删除被管主机
使用 =rm= 子命令来删除被管主机
#+BEGIN_SRC shell :results org
  yes|docker-machine rm host3
#+END_SRC

#+BEGIN_SRC org
About to remove host3
WARNING: This action will delete both local reference and remote instance.
Are you sure? (y/n): Successfully removed host3
#+END_SRC

再次查看一下virtualbox还剩下哪些主机
#+BEGIN_SRC shell :results org
  vboxmanage list vms
#+END_SRC 

#+BEGIN_SRC org
"winxp_default_1529148278389_22373" {5d100a8e-a670-4f84-8ea4-eb22f3dab94d}
"win7" {dddcdefb-5002-4bcd-bef2-ee37f0ba6197}
"rhel7.5" {bbf01330-070b-4663-b8e3-52734297c112}
"redis-host" {f5576790-7d12-4ee8-884f-7352c04f4e04}
"rhel_default_1532386536492_17873" {449040f4-21ef-436d-8648-a4026a547875}
"centos_default_1532472936791_11249" {86ffd1ee-681a-4062-a233-e29ac966fc81}
"freebsd" {2924b43b-da8b-4f59-ac32-ee4420923055}
"RHEL7" {33e98062-f82e-49df-9a8a-91b0eb31e80d}
"arch_default_1532990644081_68335" {2d5206ba-c07a-4691-8c3b-63e941113f15}
"ctf-tools_default_1533510374954_98487" {edd5c5d6-95e5-47af-a462-1d66aab8e640}
"host1" {ee738687-3981-4582-b2d3-3540a1cbff1c}
"host2" {d2907cef-5018-4476-a6e8-5e7c1c321cfe}
#+END_SRC

host3虚拟机被干掉了。

*** 管理远程Docker
我们只需要更改更改环境变量就能让Docker客户端连接上远程主机上的Docker Daemon来进行操作。

Docker Machine提供了一个 =env= 子命令来告诉你输入哪些命令可以连接到特定的机器上。

#+BEGIN_SRC shell :results org
  docker-machine env host1
#+END_SRC

#+BEGIN_SRC org
export DOCKER_TLS_VERIFY="1"
export DOCKER_HOST="tcp://192.168.99.100:2376"
export DOCKER_CERT_PATH="/home/lujun9972/.docker/machine/machines/host1"
export DOCKER_MACHINE_NAME="host1"
# Run this command to configure your shell: 
# eval $(docker-machine env host1)
#+END_SRC

按照说明，只需要执行 =eval $(docker-machine env host1)=, 之后Docker客户端的操作就都是在 =host1= 主机上进行的了。比如

#+BEGIN_SRC shell :results org
  echo "激活host1前"
  echo "check docker machines"
  docker-machine ls
  echo "check docker images"
  docker images |head -n 5

  echo "激活host1后"
  eval $(docker-machine env host1)
  echo "check docker machines"
  docker-machine ls
  echo "check docker images"
  docker images |head -n 5
#+END_SRC

#+BEGIN_SRC org
激活host1前
check docker machines
NAME         ACTIVE   DRIVER       STATE     URL                         SWARM   DOCKER        ERRORS
host1        -        virtualbox   Running   tcp://192.168.99.100:2376           v18.06.0-ce   
host2        -        virtualbox   Running   tcp://192.168.99.101:2376           v18.06.0-ce   
redis-host   -        virtualbox   Stopped                                       Unknown       
check docker images
REPOSITORY                     TAG                 IMAGE ID            CREATED             SIZE
eaf                            latest              85aaf245545d        14 hours ago        1.97GB
<none>                         <none>              071e13965b57        24 hours ago        1.97GB
<none>                         <none>              2717978972e0        24 hours ago        1.97GB
<none>                         <none>              86ac9d427d3f        24 hours ago        1.97GB
激活host1后
check docker machines
NAME         ACTIVE   DRIVER       STATE     URL                         SWARM   DOCKER        ERRORS
host1        *        virtualbox   Running   tcp://192.168.99.100:2376           v18.06.0-ce   
host2        -        virtualbox   Running   tcp://192.168.99.101:2376           v18.06.0-ce   
redis-host   -        virtualbox   Stopped                                       Unknown       
check docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
#+END_SRC

可以发现，激活host1前和激活host1主机后有两个不同点:

1. 激活host1主机后，ACTIVE这一列，在 =host1= 这一行有一个 =*= 号标识
2. 激活host1主机后，docker images变成空了，因为 =host1= 主机上并没有任何镜像。
