#+INTERLEAVE_PDF: ../../Downloads/性能之巅 洞悉系统、企业与云计算.pdf
#+TITLE: 性能之巅
#+AUTHOR: lujun9972
#+TAGS: linux
#+DATE: [2019-01-03 四 09:20]
#+LANGUAGE:  zh-CN
#+OPTIONS:  H:6 num:nil toc:t \n:nil ::t |:t ^:nil -:nil f:t *:t <:nil
* 操作系统
** 用户栈和内核栈
:PROPERTIES:
:interleave_page_note: 125
:END:
在执行系统调用是，一个进程的线程有两个栈：一个用户级别的栈和一个内核级别的栈。

当线程被阻塞时，用户级别的栈在系统调用期间并不会被改变，因为在内核上下文中执行时，线程用的是一个单独的内核级别的栈。
* 观测工具
** 性能观测工具的分类
:PROPERTIES:
:interleave_page_note: 147
:END:

根据工具是 =系统级别/进程级别= 和 =基于计数/基于跟踪= 这两个维度可以将性能观测工具分成4类:

[[file:./images/screenshot-02.png]]

*** 计数器
内核维护了各种统计数据用于对事件计数，通常计数器实现为无符号的整型，当发生事件时递增。

计数器的使用可以认为是零开销，因为它就在那里，始终由内核维护，唯一的使用开销是从用户空间读取它而已。

系统级别的计数器工具包括:

+ vmstat :: 虚拟内存和物理内存的统计
+ mpstat :: 每个CPU的使用情况
+ iostat :: 每个磁盘IO的使用情况，由块设备接口报告
+ netstat :: 网络接口的统计，TCP/IP栈的统计，以及每个连接的一些统计信息
+ sar :: 各种各样的统计，能归档历史数据

         
进程级别的计数器工具包括:

+ ps :: 查看进程各种统计信息，包括内存和CPU的使用
+ top :: 按一个统计数据排序
+ pmap :: 将进程的内存段和使用统计一起列出

*** 跟踪
跟踪收集每一个事件的数据以供分析。跟踪捕获数据会有CPU开销，还需要不小的存储空间来存放数据，因此可能会拖慢被跟踪的对象。

日志可以被认为是一种默认开启的低频率跟踪。

系统级别的跟踪工具包括:

+ tcpdump :: 网络包跟踪（libpcap库)
+ snoop :: 网络包跟踪工具
+ blktrace :: 块IO跟踪
+ iosnoop :: 基于DTrace的块IO跟踪工具
+ execsnoop :: 基于Dtrace的新进程跟踪工具
+ dtruss :: 基于Dtrace的系统调用缓冲跟踪工具
+ DTrace :: 跟踪内核的内部活动和所有资源的使用情况，支持静态和动态的跟踪
+ SystemTap :: 跟踪内核的内部活动和所有资源的使用情况，支持静态和动态的跟踪
+ perf :: Linux性能事件、静态和动态跟踪的探针

进程级别的跟踪工具包括:

+ strace :: 跟踪Linux系统调用
+ truss :: 跟踪系统调用
+ gdb :: 源码级别的调试器
+ mdb :: 一个具有可扩展性的调试器

*** 剖析(profiling)
profiling通过对目标收集采样或者快照来归纳目标特征

常见的profiler有:

+ oprofile :: Linux系统剖析
+ perf :: Linux性能工具集
+ DTrace :: 程序化剖析，profile provider提供基于时间的剖析，cpc provider提供基于硬件的剖析
+ SystemTap :: 程序化剖析，timer tapset提供基于时间的剖析，perf tapset提供基于硬件的剖析
+ cachegrind :: 源自valgrind工具集，能对硬件缓存的使用做剖析，也能用kcachegrind做数据可视化
+ Intel VTune Amplifier XE :: Linux和Windows的剖析，拥有包括源代码浏览在内的图形界面
+ Oracle Solaris Studio :: 用自带的性能分析器对Solaris和Linux做剖析

此外，编程语言通常有各自的专用分析器

*** 监视
:PROPERTIES:
:interleave_page_note: 150
:END:

最广泛应用的监视工具是sar，它基于计数器，在预定的时间被调用以记录系统计数器的状态

除了sar之外，还有其他的替代，比如System Data Recorder和Collectl

** 观测来源
:PROPERTIES:
:interleave_page_note: 151
:END:

系统性能统计的主要来源包括 =/proc=, =/sys=, =kstat= 等

#+TABLE: 观测来源
| Type               | Linux                      | Solaris         |
|--------------------+----------------------------+-----------------|
| 进程级计数器       | /proc                      | /proc,lxproc    |
| 系统级计数器       | /proc,/sys                 | kstat           |
| 设备驱动和调试信息 | /sys                       | kstat           |
| 进程级跟踪         | ptrace,uprobes             | procfs,dtrace   |
| 性能计数器         | perf_event                 | libcpc          |
| 网络跟踪           | libpcap                    | libdlpi,libpcap |
| 进程级延时指标     | 延时核算                   | 微状态核算      |
| 系统级跟踪         | tracepoints,kprobes,ftrace | dtrace          |

*** /proc
这是一个提供内核统计信息的文件系统接口。 =/proc= 提供很多目录，其中以进程ID命名的目录代表的就是那个进程。
这些目录下的众多文件包含了进程的信息和统计数据，由内核数据结构映射而来。其中，与进程性能观测相关的文件如下:
+ limits :: 实际的资源限制
+ maps :: 映射的内存区域
+ sched :: CPU调度器的各种统计
+ schedstat :: CPU运行时间、延时和时间分片
+ smaps :: 映射内存区域的使用统计
+ stat :: 进程状态和统计，包括总的CPU和内存的使用情况
+ statm :: 以页为单位的内存使用总结
+ status :: stat和statm的信息，用户可读
+ task :: 每个任务的统计目录

Linux将 =/proc= 延伸到了系统级别的统计,与性能观测相关的系统级别的文件包括:
+ cpuinfo :: CPU信息，包括所有虚拟CPU、型号、时钟频率和缓存大小
+ diskstats :: 对所有磁盘设备的磁盘IO统计
+ interrupts :: 每个CPU的中断计数器
+ loadavg :: 负载平均值
+ meminfo :: 系统内存使用明细
+ net/dev :: 网络接口统计
+ net/tcp :: 活跃的TCP套结字信息
+ schedstat :: 系统级别的CPU调度器统计
+ self :: 当前进程ID路径的符号连接
+ slabinfo :: 内核slab分配器缓存统计
+ stat :: 内核和系统资源的统计，CPU、磁盘、分页、交换区、进程
+ zoneinfo :: 内存区信息

关于 =/proc= 的内容可以在 =proc(5)= d的man页和Linux内核文档 =/Documentation/filesystems/proc.txt= 中找到。
Linux中的 =/proc= 的文件系统类型是 =proc=, 而基于Solaris的系统是 =procfs=.

*** /sys
:PROPERTIES:
:interleave_page_note: 156
:END:

Linux还提供了一个sysfs文件系统，挂载在 =/sys=.

#+BEGIN_SRC shell :results org
grep . /sys/devices/system/cpu/cpu0/cache/index*/size
#+END_SRC

#+BEGIN_SRC org
/sys/devices/system/cpu/cpu0/cache/index0/size:32K
/sys/devices/system/cpu/cpu0/cache/index1/size:32K
/sys/devices/system/cpu/cpu0/cache/index2/size:256K
/sys/devices/system/cpu/cpu0/cache/index3/size:3072K
#+END_SRC

这说明CPU0有两个L1缓存，每个都是32KB，还有一个256K的缓存和3M的L3缓存

*** 延时核算
:PROPERTIES:
:interleave_page_note: 159
:END:

开启 =CONFIG_TASK_DELAY_ACCT= 选项的Linux还会跟踪以下状态的时间
+ 调度器延时(CPU) :: 等待轮上CPU的是时间
+ 块IO(IO) :: 等待块IO完成的时间
+ 交换(SWAP) :: 等待内存换页的时间
+ 内存回收(RECLAIM) :: 等待内存回收的时间

*** 其他观测源
:PROPERTIES:
:interleave_page_note: 160
:END:

+ CPU性能计数器 :: 在Linux上通过 =perf_events= 接口，或者系统调用 =perf_event_open(0= ，或者 =perf= 这样的工具来访问
+ 进程级跟踪 :: Linux上可以通过系统调用 =ptrace()= 来控制进程跟踪， =strace= 命令来跟踪系统调用，还有 =uprobes= 来做用户级别的动态跟踪
+ 内核跟踪 :: 在Linux中，tracepoints提供静止的内核探针，kproes提供动态探针。
+ 网络嗅探 :: 在Linux上，嗅探的功能是通过libpcap库和 =/proc/net/dev= 提供的
+ 系统调用 :: 某些系统调用和库函数可以提供性能指标，比如 =getrusage()= 函数可以为进程拿到自己资源的统计信息

** DTrace
:PROPERTIES:
:interleave_page_note: 162
:END:
DTrace的设计是生产环境安全的，拥有极小的性能开销。
DTrace同时支持静态跟踪和动态跟踪，两者功能互补。静态探针有文档完备且稳定的接口，而动态探针能够提供近乎无限的可观测性。
其中，静态跟踪是o通过直接嵌入源代码的静态探针实现的，而动态跟踪是通过内核地址空间的 =live patching= 将函数入口指令修改为引发一个软中断,该软中断会出发指定的action。

DTrace能动态跟踪函数的入口和返回，以及任何在用户空间执行的指令，但这是通过为CPU指令动态建立探针实现的，而CPU指令可能发生改变，因此该接口并不稳定。

*** D语言
DTrace通过一套D语言来设置各个探针，并定义在探针命中时执行的操作。
D语言与awk很像，甚至它也能跟awk一样既能在单行命令中执行，也能写成脚本。D语言的语法形式如下:

#+begin_example
  探针描述 /过滤条件/ {actions}
#+end_example

**** 探针描述
DTrace探针描述分成四个部分:

#+begin_example
  provider:module:function:name
#+end_example

其中， =provider= 是探针的集合，类似于库的概念,
=module= 和 =function= 用来标记探针指示的代码位置，可以用通配符 =*=,或者留空("::"相当于":*:")来表示任意位置。
=name= 则是探针的名字。

可用的provider取决于你的DTrance和操作系统的版本，比较常见的provider有:

+ syscall :: 系统调用自陷表
+ vminfo :: 虚拟内存统计
+ sysinfo :: 系统统计
+ profile :: 任意频率的采样
+ sched :: 内核调度事件
+ proc :: 进程级别事件，比如创建、执行、退出
+ io :: 块设备接口跟踪
+ pid :: 用户级别动态跟踪
+ tcp :: TCP协议事件，网络连接，数据包发送和接受
+ ip :: IP协议事件，发送和接受
+ fbt :: 内核级别动态跟踪
+ 其他高级语言的provider :: 比如Java，JavaScript，Node.js，Perl，Python,Ruby,Tcl等

**** 参数
探针通过参数来获取数据，不同探针接受的参数也不一样。
我们可以通过 =arg0...argN= 来获取这些参数，可以通过 =dtrace -lv= 选项来查看每个provider参数的概要说明。

**** 跟
内置变量awk一样，DTrace默认也提供了一些内置变量，可以在 =过滤条件= 和 =action= 中使用. 常见的内置变量有:

#+TABLE: 常用内置变量

| 变量            | 描述                         |
|-----------------+------------------------------|
| execname        | 执行的进程名字               |
| uid             | 用户ID                       |
| pid             | 进程ID                       |
| timestamp       | 当前时间，为自启动以来的ns数 |
| vtimestamp      | 线程执行时间，单位是ns       |
| arg0...argN     | 探针参数                     |
| arg[0]...arg[N] | 探针参数                     |
| curthread       | 指向当前线程内核结构的指针   |
| probefunc       | 探针触发的function位置       |
| probename       | 探针名称                     |
| curpsinfo       | 当前进程信息                 |

*** 过滤条件
=/过滤条件/= 这一部分是可选的，例如
#+begin_example
  proc:::exec-success /execname == "httpd"/ {trace(pid);}
#+end_example
就会限定指定对 =httpd= 进程执行 =trace(pid)= 这一action

如果省略这一部分，则表示不做过滤。
*** action
action指定了当触发探针时做的操作，常见的action包括:

#+TABLE: 常见action
| action                 | 描述                                                                       |
|------------------------+----------------------------------------------------------------------------|
| trace(arg)             | 输出arg的值                                                                |
| printf(format,arg,...) | 格式化输出arg的值                                                          |
| stringof(addr)         | 返回来自内核空间的字符串                                                   |
| copyinstr(addr)        | 返回来自用户空间的字符串（需要内核执行一次从用户空间到内核空间的复制操作） |
| stack(count)           | 打印内核级别的栈跟踪，如果有count则按count截断                             |
| ustack(count)          | 打印用户级别的栈跟踪，如果有count则按count截断                             |
| func(pc)               | 根据内核程序计数器(pc),返回内核函数名                                      |
| ufunc(pc)              | 根据用户程序计数器(pc),返回用户函数名                                      |
| exit(status)           | 退出DTrace，并返回状态                                                     |
| trunc(@agg,count)      | 截断聚合变量，若没有count则表示清空该聚合变量                              |
| clear(@agg)            | 清空聚合变量中各个键对应的值                                               |
| printa(format,@agg)    | 格式化输出聚合变量中的值                                                               |
*** 变量类型
:PROPERTIES:
:interleave_page_note: 192
:END:
#+TABLE: 变量类型及开销

| 类型               | 前缀   | 作用域         | 开销   | 多CPU是否安全 | 示例             |
|--------------------+--------+----------------+--------+---------------+------------------|
| 聚合变量           | @      | 全局           | 低     | 是            | @x = count();    |
| 带键的聚合变量     | @[]    | 全局           | 低     | 是            | @x[pid]=count(); |
| action子句局部变量 | this-> | action子句内部 | 非常低 | 是            | this->x=1;       |
| 线程局部变量       | self-> | 线程内         | 中等   | 是            | self->x=1;       |
| 标量               | 无     | 全局           | 中下   | 否            | x=1;             |
| 关联数组           | 无     | 全局           | 中上   | 否            | x[y]=1;         |

其中，聚合变量是一种特殊类型的变量，可以由CPU单独计算汇总之后再传递到用户空间。
该变量类型拥有最低的开销，是另一种数据汇总的方法。

下面这些action可以用来填充聚合变量

#+TABLE: 聚合action
| 聚合action                                                 | 描述                                              |
|------------------------------------------------------------+---------------------------------------------------|
| count()                                                    | 发生计数                                          |
| sum(value)                                                 | 对value求和                                       |
| min(value)                                                 | 记录value的最小值                                 |
| max(value)                                                 | 记录value的最大值                                 |
| quantize(value)                                            | 用2的幂次方直方图记录value                        |
| lquantize(value,min,max,step)                              | 用给定最小值、最大值和步进值做线性直方图记录value |
| llquantize(value,factor,min)magnitude,max_magnitude,steps) | 用混合对数/线性直方图记录value                                |
* 应用程序
** 应用程序性能技术
:PROPERTIES:
:interleave_page_note: 184
:END:

提高应用的常用技术包括:

+ 选择IO尺寸
+ 缓存/缓冲区
+ 轮询
+ 并发和并行
+ 非阻塞IO和处理器帮顶
*** 选择IO尺寸
执行IO的开销包括初始化缓冲区、系统调用、上下文切换分配内核元数据、检查进程权限和限制、映射地址到设备、执行内核和驱动代码来执行IO、释放元数据和缓冲区。
其中，初始化缓冲区的开销对于大型IO和小型IO来说都是差不多的，一般来讲每次IO传输的数据越多，效率越高。

增加IO尺寸是应用程序提高吞吐量的常用策略。但过大的IO尺寸会浪费缓存空间
*** 缓存
:PROPERTIES:
:interleave_page_note: 185
:END:

缓存的一个重要方面就是如何保证完整性，确保查询不会返回过期的数据，这被称为存的一致性。

过大的缓冲区可能会增加写延时，这是因为为了等待缓存区被写满，可能需要等待很多的时间。
*** 轮询
轮询是系统等待某一事件发生的技术，该技术在循环中检查事件状态。
轮询中有一些潜在的性能问题:

+ 循环检查导致CPU的开销过高
+ 循环之间的行为可能导致事件发生和下一次检查之间的延时较高。
**** poll()系统调用
poll()系统调用用来检查文件描述符的状态，提供与轮询相似的能力，不过它基于事件的，没有轮询那样的性能负担。

poll()借口将多个文件描述符放在数组中，应用系统扫描整个数组来寻找相应的文件描述符
这个扫描是O(n)的，因此可能会引发性能问题。
**** epoll()
:PROPERTIES:
:interleave_page_note: 188
:END:
Linux中提供了epoll()系统调用，它能够避免这种扫描，时间复杂度是O(1)
Notes for page 188**** 并发和并行
:PROPERTIES:
:interleave_page_note: 186
:END:
并发除了使用同步原语来保障完整性之外，还一般会与hash表一同使用来提高性能。

常见的同步原语有三种类型:

+ 排它锁(mutex) :: 只有锁持有者才能操作，其他线程阻塞并等待CPU
+ 自旋锁 :: 自旋锁允许所持有者操作，其他需要自旋锁的线程则会在CPU上循环自旋，检查锁是否被释放。这样的好处是线程不离开CPU，能够延时低，但是另一方面浪费CPU资源
+ 读写锁 :: 读写锁允许多个读者，但是只能有一个写着。

**** 使用hash表减少锁竞争
创建固定数目的锁，用hash算法来选择哪个锁用于哪个数据结构，这样可以减少锁的竞争。

一般来说，为了最大程度的并行，hash表的桶的数目应该大于或等于CPU的数目。

*** 非阻塞IO
在进程IO是进行阻塞，这种模型存在以下两个性能问题:

1. 由于每一次阻塞就是消耗一个线程/进程，因此对于多路并发的IO就意味着会创建很多的线程/进程，线程/进程的创建和销毁代码巨大。
2. 对于频繁发起的短时IO，会导致频换切换上下文，从而增加CPU资源的消耗。

而非阻塞IO模型则是异步发起IO，不阻塞当前的线程，线程可以执行其他工作。当IO完成后再通过信号通知线程继续下面的工作。

*** 处理器绑定
在使用NUMA的多处理器系统中将进程绑定到某个处理器运行，可以一直使用该CPU的本地存储器，从而减少对内存的IO，提高应用程序的整体性能。

但CPU绑定也会带来风险，比如若其他用户或程序也刚好用到这个绑定的CPU，则可能会引发冲突和调度器延时。

** 编程语言
:PROPERTIES:
:interleave_page_note: 189
:END:
解析器和语言虚拟机一般都有自己专门的工具来做不同级别的性能观测.

对于编译语言我们可以通过编译器优化来提升性能，但优化程度越高，其产生的机器码与源代码之间的映射关系就越模糊，可能会使性能分析变得不那么直观。

GC是常见的性能调整对象，用以降低CPU成本和减少延时时异常值的发生。
比如Java虚拟机就提供了许多可调参数来设置GC类型，GC线程数，堆尺寸最大值、目标堆空闲率等。

** 分析方法

*** 线程状态分析
:PROPERTIES:
:interleave_page_note: 192
:END:
线程状态分析的目的是分辨应用程序线程的时间用在了什么地方。

在线程状态分析时，我们可以把线程状态分成下面几中类型：
+ 执行 :: 正在CPU上执行
+ 可运行 :: CPU时间片耗尽，等待下一次轮询
+ 匿名换页 :: 因内存换页而受阻
+ 睡眠 :: 等待网络、块设备等IO操作完成
+ 锁 :: 等待获取同步锁
+ 空闲 :: 等待工作

提高性能的关键在于减少线程处于前五类状态的时间，针对线程处于哪类状态，我们可以做进一步的研究:
+ 执行 :: 检查线程实在用户态执行还是内核态执行，用profiling对CPU资源消耗情况进行分析，确定哪些代码路径消耗的CPU过大
+ 可运行 :: 这可能意味着应用程序需要更多的CPU资源，检查整个系统的CPU负载以及是否对应用程序做了CPU限制
+ 匿名换页 :: 应用程序缺少主存会引起换页，需要检查整个系统的内存使用情况，是否对应用程序做了不合理的内存限制
+ 睡眠 :: 分析到底是哪些资源导致应用程序阻塞，IO是否异常
+ 锁 :: 识别那些线程持有锁，确定线程持锁这么长时间的原因。

Linux系统为我们提供了下面这些工具进行分析:
+ 使用 =top= 命令可以查看各个进程的CPU消耗情况
+ 内核的 =schedstat= 功能会追踪可运行的线程，并将信息显示在 =/proc/$pid/schedstat= 中
+ =perf sched= 工具也提供了用于了解可运行线程与等待线程所花时间的指标
+ =pidstat -d= 可以判断一个进程实在执行磁盘IO还是睡眠
+ =iotop= 能够查看各个进程的io情况
+ 若某个应用程序的睡眠时间很长（达到秒级），则可以用pstack输出堆栈快照来调查原因。

*** CPU剖析
剖析的目标是要判断应用程序是如何消耗CPU资源的。一个有效的技术是对CPU上的用户栈跟踪做采样并将采样结果联系起来。
这些栈信息能够让告诉我们代码的执行路径，从而揭示出应用程序消耗CPU的原因。

针对解释语言和虚拟机语言的CPU剖析是很难的，因为从执行的代码到原始的程序之间并没有简单的映射关系。
只能寄希望于

*** 系统调用分析
:PROPERTIES:
:interleave_page_note: 197
:END:
系统调用分析的目标是要找出系统调用的时间花在什么地方，还有系统调用的类型以及使用该系统调用的原因。

**** strace命令
在Linux下可以使用strace命令跟踪系统调用，例如:
#+BEGIN_SRC shell
  strace -ttt -T -p $(pidof emacs)
#+END_SRC

#+BEGIN_EXAMPLE
  [lujun9972@T520 8948]$ sudo strace -ttt -T -p $(pidof emacs)
  strace: Process 6407 attached
  1546945285.834914 pselect6(21, [3 5 6 7 8 10 12 19 20], [], NULL, {tv_sec=2, tv_nsec=500433727}, {NULL, 8}) = 1 (in [7], left {tv_sec=0, tv_nsec=978006169}) <1.522453>
  1546945287.357587 rt_sigprocmask(SIG_BLOCK, [INT], [], 8) = 0 <0.000122>
  1546945287.357868 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0 <0.000045>
  1546945287.358029 accept4(7, {sa_family=AF_UNIX}, [112->2], SOCK_CLOEXEC) = 9 <0.000071>
  1546945287.358181 fcntl(9, F_SETFL, O_RDONLY|O_NONBLOCK) = 0 <0.000011>
  1546945287.358237 getsockname(9, {sa_family=AF_UNIX, sun_path="/tmp/emacs1000/server"}, [112->24]) = 0 <0.000008>
  1546945287.358430 recvmsg(10, {msg_namelen=0}, 0) = -1 EAGAIN (资源暂时不可用) <0.000009>
  1546945287.359993 poll([{fd=8, events=POLLIN}, {fd=10, events=POLLIN}, {fd=12, events=POLLIN}], 3, 0) = 0 (Timeout) <0.000012>
  1546945287.360174 rt_sigprocmask(SIG_BLOCK, [INT], [], 8) = 0 <0.000018>
  1546945287.360250 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0 <0.000010>
  1546945287.360288 pselect6(21, [3 5 6 7 8 9 10 12 19 20], [], NULL, {tv_sec=0, tv_nsec=975134338}, {NULL, 8}) = 1 (in [9], left {tv_sec=0, tv_nsec=975125651}) <0.000023>
  1546945287.360361 rt_sigprocmask(SIG_BLOCK, [INT], [], 8) = 0 <0.000023>
  1546945287.360432 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0 <0.000007>
  1546945287.360474 read(9, "-dir /home/lujun9972/ -current-f"..., 4096) = 332 <0.000016>
  1546945287.360624 getpid()              = 6407 <0.000008>
  1546945287.360659 write(9, "-emacs-pid 6407\n", 16) = 16 <0.000016>
  1546945287.361017 stat("/home/lujun9972", {st_mode=S_IFDIR|0710, st_size=12288, ...}) = 0 <0.000017>
  1546945287.361351 write(9, "-print nil\n", 11) = 11 <0.000015>
  1546945287.361517 close(9)              = 0 <0.000023>
  1546945287.363620 rt_sigprocmask(SIG_BLOCK, [WINCH IO], NULL, 8) = 0 <0.000020>
  1546945287.363783 poll([{fd=10, events=POLLIN|POLLOUT}], 1, -1) = 1 ([{fd=10, revents=POLLOUT}]) <0.000012>
  1546945287.363836 writev(10, [{iov_base=";\0\5\0\325\1\340\2\0\0\0\0x\3\202\2\315\1\22\0C\0\5\0H\1\340\2\325\1\340\2"..., iov_len=148}, {iov_base=NULL, iov_len=0}, {iov_base="", iov_len=0}], 3) = 148 <0.000020>
#+END_EXAMPLE

其中:

+ -ttt :: 在第一栏输出UNIX时间戳，以秒为单位，精确度可以到毫秒级
+ -T :: 在最后一栏输出系统调用的时间，以秒为单位，精确到毫秒级别
+ -p $PID :: 跟踪某个PID的进程

上述形式的strace没一行都表示一个系统调用。若只想输出系统调用活动的统计信息可以使用 =-c= 选项
#+BEGIN_SRC shell :results org
  strace -c date 2>&1
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
2019年 01月 08日 星期二 19:11:10 HKT
% time     seconds  usecs/call     calls    errors syscall
------ ----------- ----------- --------- --------- ----------------
 20.00    0.000032           5         6           close
 18.75    0.000030           7         4           openat
 17.50    0.000028           4         6           fstat
 15.00    0.000024          24         1           write
 10.62    0.000017           2         6           read
  6.88    0.000011           1         8           mmap
  6.88    0.000011           3         3           brk
  4.38    0.000007           1         4           lseek
  0.00    0.000000           0         4           mprotect
  0.00    0.000000           0         1           munmap
  0.00    0.000000           0         1         1 access
  0.00    0.000000           0         1           execve
  0.00    0.000000           0         2         1 arch_prctl
------ ----------- ----------- --------- --------- ----------------
100.00    0.000160                    47         2 total
#+END_SRC

其中:
+ time :: 显示系统CPU时间花在哪里的百分比
+ seconds :: 总的系统CPU时间，单位是秒
+ usecs/call :: 每次调用的平均系统CPU时间，单位是毫秒
+ calls :: 整个strace过程中系统嗲用的次数
+ syscall :: 系统调用的名字
**** truss
:PROPERTIES:
:interleave_page_note: 199
:END:
在Solaris系统上使用truss命令来分析系统调用,例如
#+BEGIN_SRC shell
  truss -dE -p $(pidof emacs)
#+END_SRC

这里的选项：
+ -d :: 输出命令启动后的秒数
+ -E :: 输出系统调用的耗时，单位为秒
+ -p PID :: 指定跟踪的进程

同样的，truss也使用 =-c= 选项进行系统调用的统计总结:
#+BEGIN_SRC shell
  truss -c dd if=/dev/zero of=/dev/null bs=1k count=10k
#+END_SRC

truss还可以使用 =-u= 选项对用户级函数进行动态跟踪，例如跟踪 =printf= 调用:
#+BEGIN_SRC shell
  truss -u 'libc:*printf*' uptime
#+END_SRC

**** 缓存跟踪
:PROPERTIES:
:interleave_page_note: 201
:END:

与断点跟踪相比，缓存跟踪并不会中断目标程序的执行，而是将监控程序缓存在内核中。

在perf中可以通过trace子命令来执行系统调用的缓存跟踪:
#+BEGIN_SRC shell :results org :dir /sudo::/tmp
  sudo perf trace touch a 2>&1
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
         ? (         ): touch/26378  ... [[33mcontinued[m]: execve()) = 0
     0.080 ( 0.006 ms): touch/26378 brk(                                                                  ) = 0x55d62ec22000
     0.093 ( 0.004 ms): touch/26378 arch_prctl(option: 12289, arg2: 140723363955488                       ) = -1 EINVAL Invalid argument
     0.134 ( 0.010 ms): touch/26378 access(filename: 0xe6f043a0, mode: R                                  ) = -1 ENOENT No such file or directory
     0.153 ([33m 0.011 ms[m): touch/26378 openat(dfd: CWD, filename: 0xe6f01891, flags: CLOEXEC                 ) = 3
     0.169 ( 0.005 ms): touch/26378 fstat(fd: 3, statbuf: 0x7ffcb61eb500                                  ) = 0
     0.178 ([33m 0.011 ms[m): touch/26378 mmap(len: 308934, prot: READ, flags: PRIVATE, fd: 3                   ) = 0x7f89e6e93000
     0.193 ( 0.004 ms): touch/26378 close(fd: 3                                                           ) = 0
     0.231 ( 0.009 ms): touch/26378 openat(dfd: CWD, filename: 0xe6f0ac70, flags: CLOEXEC                 ) = 3
     0.244 ( 0.006 ms): touch/26378 read(fd: 3, buf: 0x7ffcb61eb6c8, count: 832                           ) = 832
     0.255 ( 0.004 ms): touch/26378 lseek(fd: 3, offset: 792, whence: SET                                 ) = 792
     0.262 ( 0.004 ms): touch/26378 read(fd: 3, buf: 0x7ffcb61eb580, count: 68                            ) = 68
     0.271 ( 0.004 ms): touch/26378 fstat(fd: 3, statbuf: 0x7ffcb61eb560                                  ) = 0
     0.279 ( 0.008 ms): touch/26378 mmap(len: 8192, prot: READ|WRITE, flags: PRIVATE|ANONYMOUS            ) = 0x7f89e6e91000
     0.298 ( 0.004 ms): touch/26378 lseek(fd: 3, offset: 792, whence: SET                                 ) = 792
     0.305 ( 0.004 ms): touch/26378 read(fd: 3, buf: 0x7ffcb61eb1d0, count: 68                            ) = 68
     0.313 ( 0.003 ms): touch/26378 lseek(fd: 3, offset: 864, whence: SET                                 ) = 864
     0.320 ( 0.004 ms): touch/26378 read(fd: 3, buf: 0x7ffcb61eb1f0, count: 32                            ) = 32
     0.328 ([33m 0.010 ms[m): touch/26378 mmap(len: 1848896, prot: READ, flags: PRIVATE|DENYWRITE, fd: 3        ) = 0x7f89e6ccd000
     0.343 ([33m 0.019 ms[m): touch/26378 mprotect(start: 0x7f89e6cef000, len: 1671168                          ) = 0
     0.366 ([33m 0.017 ms[m): touch/26378 mmap(addr: 0x7f89e6cef000, len: 1355776, prot: EXEC|READ, flags: PRIVATE|FIXED|DENYWRITE, fd: 3, off: 139264) = 0x7f89e6cef000
     0.388 ([33m 0.010 ms[m): touch/26378 mmap(addr: 0x7f89e6e3a000, len: 311296, prot: READ, flags: PRIVATE|FIXED|DENYWRITE, fd: 3, off: 1495040) = 0x7f89e6e3a000
     0.402 ([33m 0.013 ms[m): touch/26378 mmap(addr: 0x7f89e6e87000, len: 24576, prot: READ|WRITE, flags: PRIVATE|FIXED|DENYWRITE, fd: 3, off: 1806336) = 0x7f89e6e87000
     0.427 ([33m 0.011 ms[m): touch/26378 mmap(addr: 0x7f89e6e8d000, len: 13888, prot: READ|WRITE, flags: PRIVATE|FIXED|ANONYMOUS) = 0x7f89e6e8d000
     0.455 ( 0.004 ms): touch/26378 close(fd: 3                                                           ) = 0
     0.557 ( 0.006 ms): touch/26378 arch_prctl(option: 4098, arg2: 140230261286272                        ) = 0
     0.691 ([33m 0.016 ms[m): touch/26378 mprotect(start: 0x7f89e6e87000, len: 16384, prot: READ                ) = 0
     0.760 ( 0.010 ms): touch/26378 mprotect(start: 0x55d62e37e000, len: 4096, prot: READ                 ) = 0
     0.781 ([33m 0.011 ms[m): touch/26378 mprotect(start: 0x7f89e6f08000, len: 4096, prot: READ                 ) = 0
     0.797 ([33m 0.029 ms[m): touch/26378 munmap(addr: 0x7f89e6e93000, len: 308934                              ) = 0
     1.004 ( 0.005 ms): touch/26378 brk(                                                                  ) = 0x55d62ec22000
     1.013 ( 0.008 ms): touch/26378 brk(brk: 0x55d62ec43000                                               ) = 0x55d62ec43000
     1.036 ([33m 0.011 ms[m): touch/26378 openat(dfd: CWD, filename: 0xe6e588a0, flags: CLOEXEC                 ) = 3
     1.052 ( 0.004 ms): touch/26378 fstat(fd: 3, statbuf: 0x7f89e6e8c920                                  ) = 0
     1.060 ([33m 0.011 ms[m): touch/26378 mmap(len: 6180864, prot: READ, flags: PRIVATE, fd: 3                  ) = 0x7f89e66e8000
     1.084 ( 0.004 ms): touch/26378 close(fd: 3                                                           ) = 0
     1.159 ([33m 0.011 ms[m): touch/26378 openat(dfd: CWD, filename: 0xb61ecea9, flags: CREAT|NOCTTY|NONBLOCK|WRONLY, mode: IRUGO|IWUGO) = 3
     1.175 ( 0.004 ms): touch/26378 dup2(oldfd: 3                                                         ) = 0
     1.183 ( 0.003 ms): touch/26378 close(fd: 3                                                           ) = 0
     1.190 ( 0.007 ms): touch/26378 utimensat(                                                            ) = 0
     1.200 ( 0.003 ms): touch/26378 close(                                                                ) = 0
     1.220 ( 0.004 ms): touch/26378 close(fd: 1                                                           ) = 0
     1.229 ( 0.003 ms): touch/26378 close(fd: 2                                                           ) = 0
     1.251 (         ): touch/26378 exit_group(                                                           )
#+END_SRC

*** I/O剖析
:PROPERTIES:
:interleave_page_note: 203
:END:

与CPU剖析作用类似，I/O剖析判断的是I/O相关的系统调用（比如read(),write()）执行的原因和方式。

比如下面dtrace命令跟踪PostgreSQL的read()系统调用，并收集用户级别的栈跟踪:
#+BEGIN_SRC shell
  dtrace -n 'syscall::read:entry /execname == "postgres"/ {@[ustack()] = count();}'
#+END_SRC

*** USE方法
:PROPERTIES:
:interleave_page_note: 204
:END:

USE方法通过检查资源的使用率，饱和度和发生的错误来判断某一资源是否成为瓶颈。

例如若系统为文件描述符设置了一个数量上限，则相应的指标为:

+ 使用率 :: 使用中文件描述符的数量，与系统设置上限的比率
+ 饱和度 :: 等待文件描述符分配的线程数
+ 错误 :: 分配失败，提示EFILE，打开太多文件。

*** 锁分析
:PROPERTIES:
:interleave_page_note: 205
:END:

对于多线程的应用程序，锁可能会成为阻碍并发和扩展性的瓶颈。

对于自旋锁来说，当锁出现竞争时，CPU使用率也会发生变化。
通过对CPU进行栈跟踪通常能识别出来。

*** 静态性能调优
:PROPERTIES:
:interleave_page_note: 208
:END:

静态性能调优是通过对程序运行环境的检查，看是否有优化的空间，例如:

+ 运行的程序是什么版本？是否有更新版本？发布说明是否提及性能提高
+ 应用程序有哪些已知的性能问题？有可供搜索的bug数据库吗？
+ 应用程序是怎么配置的？能通过调整配置优化速度吗？
+ 应用程序利用了缓存吗？缓存大小如何？
+ 应用程序是并发运行吗？线程池大小如何？
+ 应用程序是在调试模式下运行吗？
+ 应用程序用到了哪些程序库？他们的版本是什么？
+ 应用程序用的是怎样的内存分配器
+ 应用程序用大页面做堆吗？
+ 应用程序是编译的吗？编译器版本是什么？优化选项有哪些？
+ 应用程序遇到错误了吗？发生错误后会运行在降级模式吗？
+ 有没有系统资源方面的限制？

* CPU
:PROPERTIES:
:interleave_page_note: 212
:END:

正在排队和就绪运行的软件线程数量是一个很重要的性能指标，表示了CPU的饱和度。
花在等待CPU运行上的时间又被称为运行队列延时或者分发器队列延时。

对于多处理器系统，内核通常为每个CPU提供了一个运行队列，并尽量使每个线程每次都放在同一个队列。
这是因为CPU缓存中很可能保存了该线程的数据，同时在NUMA系统中，这会提高内存本地性，从而提高系统性能。

** CPU相关指标
:PROPERTIES:
:interleave_page_note: 217
:END:

*** CPI(每指令周期数)/IPC(每周期指令数)
高CPI说明CPU经常陷入停滞，比如在等待内存访问，这种情况下更快的CPU并不能提高速度

*** 使用率
CPU使用率通过测量一段时间内CPU忙于执行工作的时间比率获得，以百分比表示。
比较违反直觉的是，CPU使用率的测量包括了内存滞留周期，也就是说CPU停滞等待IO也可能会导致高使用率。

*** 用户时间与内核时间之比
:PROPERTIES:
:interleave_page_note: 218
:END:
CPU花在用户态应用程序代码的时间称为用户时间，而执行内核态代码的时间称为内核时间。 内核时间包括系统调用、内核线程和中断的时间。
挡在整个系统范围内进行测量时，用户时间和内核时间之笔揭示了运行的负载类型。

计算密集型的应用程序几乎会把大量的时间用在用户态代码上，用户/内核时间可以接近99/1.

IO密集型的应用程序则需要频繁调用内核代码进行IO操作，用户/内核时间比可以降到70/30.

*** 饱和度
一个100%使用率的CPU被称为是饱和的，因为线程会遇到调度器延时，必须等待才能在CPU上运行。

不过由于Linux支持抢占式线程，因此CPU饱和并不意味着一定影响速度。


** CPU架构
:PROPERTIES:
:interleave_page_note: 221
:END:

CPU硬件包括了处理器和它的子系统，以及多处理器之间的CPU互联

*** 处理器
一颗通用双核处理器的组件如下图所示:
[[file:./images/screenshot-01.png]]
其中组建包括:
+ 控制器 :: CPU的心脏，运行指令预取、解码、管理执行以及存储结果
+ P-cache :: 预取缓存，每个CPU一个
+ W-cache :: 写缓存，每个CPU一个
+ 时钟 :: CPU时钟信号生成器
+ 时间戳计数器 :: 为了高精度、由时钟递增
+ 微代码ROM :: 快速把指令转换成电路信号
+ 温度传感器 :: 温度监控，有些CPU将温度传感器作为动态超频的依据
+ 网络接口 :: 有些CPU为了高性能，会将网路接口集成到芯片中。

*** CPU缓存
CPU缓存级别层次如下所示:
[[file:./images/screenshot-03.png]]

+ 一级指令缓存(I$)，延时大概几个CPU周期
+ 一级数据缓存(D$)，延时大概几个CPU周期
+ 转译后备缓冲器(TLB),缓存虚拟内存到物理内存的转换结果
+ 二级缓存(E$)，延时大概几十个CPU周期
+ 三级缓存(可选)

为了减少访问缓存的延时，一般会将缓存做到处理器内部

缓存带来的一个问题就是缓存一致性：即当一个CPU修改了内存后，所有的其他CPU缓存也需要知道它们的缓存拷贝已经失效，需要被丢弃。
*** CPU性能计数器
CPU性能计数器是用于计数低级CPU活动的处理器寄存器
*** 内核空闲线程
:PROPERTIES:
:interleave_page_note: 233
:END:
内核空闲线程是只在没有其他可运行线程的时候才在CPU上运行，它的优先级最低，通常被设计为通知CPU停止执行或者减速执行以节省资源。
CPU会在下一次硬件中断发生时醒来。
** CPU分析和调优的方法
:PROPERTIES:
:interleave_page_note: 234
:END:
*** 工具法
工具法就是把可用的工具全都用一遍，检查他们提供的关键项指标。

+ uptime :: 检查负载平均数，若负责平均数超过CPU数量则通常代表CPU饱和
+ vmstat :: 检查内存空闲余量。少于10%可能会有问题
+ mpstat :: 检查是否存在单个CPU繁忙
+ top/prstat :: 查看哪个进程和用户是CPU消耗大户
+ pidstat/prstat :: 查看CPU消耗大户的用户/系统时间的占比情况
+ perf/dtrace/stap/oprofile :: 剖析CPU使用的堆栈跟踪，了解为什么使用这么多CPU
+ perf/cpustat :: 测量CPI
*** USE方法
:PROPERTIES:
:interleave_page_note: 235
:END:
USE方法可以在性能调查早期进行，用来发现所有组件内的瓶颈和错误。

对每个CPU检查下面内容:
+ 使用率 :: 每个CPU繁忙的时间，可能存在一个CPU繁忙，其他CPU空闲的情况
+ 饱和度 :: 可运行线程排队等待CPU的数量
+ 错误 :: CPU是否有相关错误发生，比如有些操作系统在CPU发生错误时可能会关闭CPU，因此可以检查CPU是否都在线。
*** 归纳负载特征
:PROPERTIES:
:interleave_page_note: 236
:END:

+ CPU使用率与饱和度，反映了CPU的请求负载
+ 用户时间和系统时间占比,反映了负载类型
+ 系统调用频率
+ 自愿上下文切换频率
+ 中断频率

IO消耗型负载因为线程阻塞等待IO，从而有更高的系统时间、中断频率以及自愿上下文切换频率
**** 负载特征归纳检查清单
+ 整个系统范围内的CPU使用率是多少？每个CPU的使用率呢？
+ CPU负载的并发程度如何？是单线程吗？有多少线程
+ 哪个应用程序或用户在用CPU，用了多少？
+ 哪个内核线程在用CPU？用了多少？
+ CPU中断频率高吗？
+ CPU互联频率高吗？
+ CPU被用来做什么(用户和内核的调用路径)?
*** Profile
通过定期对CPU进行采样可以大致分析出CPU的代码执行路径。
*** CPU周期分析
通过使用CPU性能计数器(CPC),我们能够以周期级别理解CPU使用率。
这可以展示消耗在一级、二级、三级缓存未命中，内存IO以及资源IO上的停滞周期以及花在浮点运算和其他活动上的周期数。
拿到这些信息后就可以通过调整编译器选项或修改代码来提高性能。

周期分析从测量CPI开始，若CPI较高，则继续调查停滞周期的类型;如果CPI较低，就寻找减少指令数量的方法。

 除了测量计数器的值之外，还可以配置CPC，在超出某个值时中断内核，例如每10000此二级缓存未命中，就中断一次内核以获取栈回溯。
*** 静态性能调优
关于CPU性能，检查下列方面的静态信息：
+ 有多少CPU可用？多少核，每个核多少线程？
+ CPU的缓存多大？是共享缓存吗？
+ CPU时钟频率是多少，支持动态加速功能吗？
+ BIOS中启用/禁止了哪些CPU相关特性？
+ 这款型号的处理器是否有已知的BUG？
+ 操作系统是否对应用的CPU使用做了限制(资源控制)？
+ 进程优先级是多少?
*** 优先级调试
UNIX提供了 =nice()= 系统调用，用于调整进程优先级。 nice值越高，则表示进程优先级越低。
一般监控代理程序和定期备份程序可以有较低的优先级。

除了nice值，操作系统还为进程提供了更高级的控制，比如更改调度类或者调度器策略。
例如实时调度类允许进程抢占所有的其他工作，这样可以消除调度器延时，但若进程本身陷入死循环则所有其他进程都无法使用CPU
*** CPU绑定
:PROPERTIES:
:interleave_page_note: 240
:END:
另一个CPU性能调优的方法是把进程/线程绑定在单个CPU或一组CPU上，这可以增加进程CPU缓存命中率，提高内存IO性能，对于NUMA系统还可以提高内存本地性。

CPU绑定有两种方式:
+ 进程绑定 :: 配置一个进程只在某个CPU或某组CPU中的某一个上运行
+ 独占CPU组 :: 通过 =cpuse= 指定某组CPU只能运行指定的进程，由于其他进程不能使用CPU从而能够提高CPU缓存的效率。
*** 微型基准测试
CPU微信基准测试对一个简单操作进行多次测量计算操作时间。这些操作可能包括：
+ CPU指令: 整数运算、浮点运算、分支和其他指令
+ 内存访问: 调查不同CPU缓存的延时和主存吞吐量
+ 高级语言: 测量高级语言中不同指令的耗时
+ 操作系统: 测量调用操作系统各API所消耗的时间
** CPU性能分析工具
:PROPERTIES:
:interleave_page_note: 242
:END:

#+TABLE: CPU分析工具
| Linux        | Solaris | 描述                       |
|--------------+---------+----------------------------|
| uptime       | uptime  | 平均负载                   |
| vmstat       | vmstat  | 系统范围内的CPU平均负载    |
| mpstat       | mpstat  | 单个CPU统计信息            |
| sar          | sar     | 历史统计信息               |
| ps           | ps      | 进程状态                   |
| top          | prstat  | 监控每个进程/线程CPU使用量 |
| pidstat      | prstat  | 每个进程/线程CPU用量分解   |
| time         | ptime   | 计算命令执行耗时           |
| DTrace，perf | DTrace  | CPU剖析和跟踪              |
| perf         | cpustat | CPU性能计数器分析                |
*** uptime
#+BEGIN_SRC shell :results org
  uptime
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
 15:38:00 up 1 day,  5:57,  1 user,  load average: 0.39, 0.46, 0.44
#+END_SRC

最后三个数字是1、5、15分钟内的平均负载。通过比较这三个数字，可以判断负载的趋势。
这个值的意义在于，当平均负载大于CPU数量时表示CPU不足以服务线程，有些线程需要等待;如果平均负载小于CPU数量，则代表CPU还有一些余量。
*** vmstat
vmstat本是虚拟内存统计信息命令，但其最后几列输出了系统全局范围的CPU平均负载。
#+BEGIN_SRC shell :results org
  vmstat 1 5
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b 交换 空闲 缓冲 缓存   si   so    bi    bo   in   cs us sy id wa st
 0  0 2602512 109852  27496 342096    2    4    32    13   20   34  6  3 91  1  0
 0  0 2602512 109836  27496 342100    0    0     0     0  430 1169  1  2 97  0  0
 0  0 2602512 109836  27496 342100    0    0     0     0  455 1385  1  2 97  0  0
 0  0 2602512 109836  27496 342100    0    0     0     0  409 1207  1  1 98  0  0
 1  0 2602512 110088  27496 342100    0    0     0     0  517 1482  2  1 97  0  0
#+END_SRC

其中 *输出的第一行表示的是系统启动以来的总信息，其他行显示的才是当前值*

各列的意义如下:

+ r :: 等待运行的线程数。
+ us :: 用户态时间
+ sy :: 系统态时间
+ id :: 空闲时间
+ wa :: 线程被阻塞等待磁盘IO的CPU空闲时间
+ st :: CPU其他开销
*** mpstat
:PROPERTIES:
:interleave_page_note: 245
:END:
多处理器统计信息工具 =mpstat= 能够报告每个CPU的统计信息。

#+BEGIN_SRC shell :results org
  mpstat -P ALL 
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
Linux 4.20.3-arch1-1-ARCH (T520) 	2019年01月24日 	_x86_64_	(4 CPU)

15时56分56秒  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
15时56分56秒  all    3.68    2.33    1.99    0.56    0.32    0.23    0.00    0.00    0.00   90.91
15时56分56秒    0    3.59    2.73    2.07    0.47    0.29    0.25    0.00    0.00    0.00   90.61
15时56分56秒    1    3.71    2.61    1.88    0.41    0.22    0.20    0.00    0.00    0.00   90.97
15时56分56秒    2    3.65    2.04    2.17    0.49    0.34    0.23    0.00    0.00    0.00   91.08
15时56分56秒    3    3.76    1.93    1.83    0.86    0.43    0.23    0.00    0.00    0.00   90.96
#+END_SRC

这里 =-P ALL= 会输出每个CPU的报告，其输出列的说明如下:

+ CPU :: 逻辑CPU ID，all表示总结信息
+ %usr :: 用户态比率
+ %nice :: 以nice优先级运行的进程用户态比率
+ %sys :: 内核态比率
+ %iowait :: IO等待比率
+ %irq :: CPU处理硬件中断的比率
+ %soft :: CPU处理软件中断的比率
+ %steal :: 耗费在服务其他租户上的比率
+ %quest :: percentage of time spent in  involuntary  wait by  the  virtual  CPU  or CPUs while the hypervisor was servicing another virtual processor.
+ %idle :: the percentage of time spent by the CPU or CPUs to run a virtual processor
*** sar 
:PROPERTIES:
:interleave_page_note: 247
:END:

sar可以用来观察系统当前活动，以及归档报告历史统计信息。sar的用法为:
#+BEGIN_SRC shell :results org
  sar --help
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
用法: sar [ 选项 ] [ <时间间隔> [ <次数> ] ]
主要选项和报告（报告名以方括号分隔）：
	-B	分页状况 [A_PAGE]
	-b	I/O 和传输速率信息状况 [A_IO]
	-d	块设备状况 [A_DISK]
	-F [ MOUNT ]
		文件系统统计信息 [A_FS]
	-H	巨大页面利用率 [A_HUGE]
	-I { <中断列表> | SUM | ALL }
		中断信息状况 [A_IRQ]
	-m { <关键字> [,...] | ALL }
		电源管理统计信息 [A_PWR_...]
		关键字：
		CPU	CPU 瞬时时钟频率
		FAN	风扇速度
\t\tFREQ\tCPU 平均时钟频率
		IN	输入电压
		TEMP	设备温度
\t\tUSB\t连接的 USB 设备
	-n { <关键字> [,...] | ALL }
		网络统计信息 [A_NET_...]
		关键字：
		DEV	网络接口
		EDEV	网络接口（错误）
		NFS	NFS 客户端
		NFSD	NFS 服务端
		SOCK	Sockets	(v4)
		IP	IP 流	(v4)
		EIP	IP 流	(v4)（错误）
		ICMP	ICMP 流	(v4)
		EICMP	ICMP 流	(v4)（错误）
		TCP	TCP 流	(v4)
		ETCP	TCP 流	(v4) (错误)
		UDP	UDP 流	(v4)
		SOCK6	Sockets	(v6)
		IP6	IP 流	(v6)
		EIP6	IP 流	(v6)（错误）
		ICMP6	ICMP 流	(v6)
		EICMP6	ICMP 流	(v6) (错误)
		UDP6	UDP 流	(v6)
		FC	Fibre channel HBAs
		SOFT	基于软件的网络处理

	-q	队列长度和平均负载统计信息 [A_QUEUE]
	-r [ ALL ]
		内存利用率信息 [A_MEMORY]
	-S	交换空间利用率信息 [A_MEMORY]
	-u [ ALL ]
		CPU 利用率信息 [A_CPU]
	-v	内核表统计信息 [A_KTABLES]
	-W	交换信息 [A_SWAP]
	-w	任务创建与系统切换信息 [A_PCSW]
	-y	TTY 设备信息 [A_SERIAL]
#+END_SRC
*** ps
ps命令能够列出进程的细节信息，包括CPU使用率
#+BEGIN_SRC shell :results org
  ps aux |head
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.1  0.2 190100  7676 ?        Ss   15:47   0:03 /sbin/init
root         2  0.0  0.0      0     0 ?        S    15:47   0:00 [kthreadd]
root         3  0.0  0.0      0     0 ?        I<   15:47   0:00 [rcu_gp]
root         4  0.0  0.0      0     0 ?        I<   15:47   0:00 [rcu_par_gp]
root         6  0.0  0.0      0     0 ?        I<   15:47   0:00 [kworker/0:0H-kblockd]
root         8  0.0  0.0      0     0 ?        I<   15:47   0:00 [mm_percpu_wq]
root         9  0.0  0.0      0     0 ?        S    15:47   0:00 [ksoftirqd/0]
root        10  0.0  0.0      0     0 ?        I    15:47   0:00 [rcu_preempt]
root        11  0.0  0.0      0     0 ?        S    15:47   0:00 [rcuc/0]
#+END_SRC

其中 =TIME= 列显示了进程从创建开始消耗的CPU总时间(用户态+系统态),格式为"小时:分钟:秒"

=%CPU= 列显示了前一秒内所有CPU上的使用率之合，因此在多核系统上该值可能超过100%
*** top
使用top命令可以方便查看占用CPU使用率最高的几个进程。
但需要注意的是,由于 =top= 对 =/proc= 拍快照，它会错过一些寿命较短的进程。

top有一个变种:atop,其使用进程核算计算来捕获短寿命进程的存在，然后把这些进程加入显示。
*** pidstat
:PROPERTIES:
:interleave_page_note: 250
:END:

pidstat工具能够输出每个进程使用的CPU数量、CPU用户态和系统态的时间比，默认情况下只循环输出活动进程的信息:
#+BEGIN_SRC shell :results org
  pidstat 1 2
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
Linux 4.20.5-arch1-1-ARCH (T520) 	2019年01月30日 	_x86_64_	(4 CPU)

16时44分41秒   UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
16时44分42秒     0       422    0.00    0.98    0.00    0.00    0.98     2  irq/29-iwlwifi
16时44分42秒     0       971    0.00    0.98    0.00    0.00    0.98     2  dockerd
16时44分42秒     0       974    0.98    0.00    0.00    0.00    0.98     3  lxd
16时44分42秒     0      1021    0.98    0.00    0.00    0.00    0.98     0  containerd
16时44分42秒  1000      1561    0.00    0.98    0.00    0.00    0.98     2  Xorg
16时44分42秒  1000      2811    0.98    0.98    0.00    0.00    1.96     1  nutstore
16时44分42秒  1000      4351    1.96    0.00    0.00    0.00    1.96     2  firefox
16时44分42秒  1000      4798    0.98    0.98    0.00    0.00    1.96     0  Web Content
16时44分42秒  1000      4808    0.00    0.98    0.00    0.00    0.98     2  Web Content

16时44分42秒   UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
16时44分43秒     0      1021    0.00    1.00    0.00    0.00    1.00     0  containerd
16时44分43秒  1000      4499    1.00    0.00    0.00    0.00    1.00     2  Web Content
16时44分43秒  1000      4572    1.00    0.00    0.00    0.00    1.00     2  WebExtensions
16时44分43秒  1000      5776    0.00    2.00    0.00    0.00    2.00     1  pidstat

平均时间:   UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
平均时间:     0       422    0.00    0.50    0.00    0.00    0.50     -  irq/29-iwlwifi
平均时间:     0       971    0.00    0.50    0.00    0.00    0.50     -  dockerd
平均时间:     0       974    0.50    0.00    0.00    0.00    0.50     -  lxd
平均时间:     0      1021    0.50    0.50    0.00    0.00    0.99     -  containerd
平均时间:  1000      1561    0.00    0.50    0.00    0.00    0.50     -  Xorg
平均时间:  1000      2811    0.50    0.50    0.00    0.00    0.99     -  nutstore
平均时间:  1000      4351    0.99    0.00    0.00    0.00    0.99     -  firefox
平均时间:  1000      4499    0.50    0.00    0.00    0.50    0.50     -  Web Content
平均时间:  1000      4572    0.50    0.00    0.00    0.00    0.50     -  WebExtensions
平均时间:  1000      4798    0.50    0.50    0.00    0.00    0.99     -  Web Content
平均时间:  1000      4808    0.00    0.50    0.00    0.00    0.50     -  Web Content
平均时间:  1000      5776    0.00    0.99    0.00    0.00    0.99     -  pidstat
#+END_SRC

使用 =-p ALL= 能输出所有进程信息，而不仅仅是活动进程信息。

选项 =-t= 会输出每个线程的统计信息

#+BEGIN_SRC shell :results org
  pidstat -t 1 2
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
Linux 4.20.5-arch1-1-ARCH (T520) 	2019年01月30日 	_x86_64_	(4 CPU)

16时46分56秒   UID      TGID       TID    %usr %system  %guest   %wait    %CPU   CPU  Command
16时46分57秒     0       422         -    0.00    0.98    0.00    0.00    0.98     2  irq/29-iwlwifi
16时46分57秒     0         -       422    0.00    0.98    0.00    0.00    0.98     2  |__irq/29-iwlwifi
16时46分57秒     0         -      1040    0.00    0.98    0.00    0.00    0.98     1  |__dockerd
16时46分57秒     0       974         -    0.98    0.00    0.00    0.00    0.98     0  lxd
16时46分57秒     0         -       974    0.98    0.00    0.00    0.00    0.98     0  |__lxd
16时46分57秒     0         -      1003    0.98    0.00    0.00    0.00    0.98     3  |__lxd
16时46分57秒     0         -      1008    0.00    0.98    0.00    0.00    0.98     2  |__lxd
16时46分57秒  1000         -      1277    0.98    0.00    0.00    0.00    0.98     0  |__emacs
16时46分57秒  1000      1561         -    0.00    0.98    0.00    0.98    0.98     2  Xorg
16时46分57秒  1000         -      1561    0.00    0.98    0.00    0.98    0.98     2  |__Xorg
16时46分57秒  1000         -      2906    0.00    0.98    0.00    0.00    0.98     3  |__nutstore
16时46分57秒  1000      4351         -    1.96    0.00    0.00    0.00    1.96     0  firefox
16时46分57秒  1000         -      4351    0.98    0.00    0.00    0.00    0.98     0  |__firefox
16时46分57秒  1000         -      4356    0.00    0.98    0.00    0.00    0.98     0  |__Timer
16时46分57秒  1000         -      4397    0.98    0.00    0.00    0.00    0.98     1  |__Compositor
16时46分57秒  1000         -      4433    0.98    0.00    0.00    0.00    0.98     2  |__Web Content
16时46分57秒  1000      4499         -    0.98    0.00    0.00    0.98    0.98     2  Web Content
16时46分57秒  1000      4808         -    0.98    0.00    0.00    0.00    0.98     3  Web Content
16时46分57秒  1000         -      4828    0.00    0.98    0.00    0.00    0.98     0  |__Timer
16时46分57秒  1000      5856         -    1.96    0.98    0.00    0.00    2.94     1  pidstat
16时46分57秒  1000         -      5856    1.96    0.98    0.00    0.00    2.94     1  |__pidstat

16时46分57秒   UID      TGID       TID    %usr %system  %guest   %wait    %CPU   CPU  Command
16时46分58秒     0         -        20    0.00    1.00    0.00    0.00    1.00     1  |__rcuc/1
16时46分58秒     0         -        42    0.00    1.00    0.00    0.00    1.00     2  |__kworker/2:1-mm_percpu_wq
16时46分58秒     0       971         -    1.00    0.00    0.00    0.00    1.00     0  dockerd
16时46分58秒     0      1021         -    1.00    0.00    0.00    0.00    1.00     0  containerd
16时46分58秒  1000      1277         -    0.00    1.00    0.00    0.00    1.00     0  emacs
16时46分58秒  1000      4351         -    1.00    0.00    0.00    0.00    1.00     0  firefox
16时46分58秒  1000      4433         -    0.00    1.00    0.00    1.00    1.00     3  Web Content
16时46分58秒  1000         -      4433    0.00    1.00    0.00    1.00    1.00     3  |__Web Content
16时46分58秒  1000         -      4499    1.00    0.00    0.00    0.00    1.00     0  |__Web Content
16时46分58秒  1000         -      4502    1.00    0.00    0.00    0.00    1.00     0  |__JS Watchdog
16时46分58秒  1000         -      4572    0.00    1.00    0.00    0.00    1.00     2  |__WebExtensions
16时46分58秒  1000      4798         -    1.00    0.00    0.00    0.00    1.00     2  Web Content
16时46分58秒  1000         -      4798    1.00    0.00    0.00    0.00    1.00     2  |__Web Content
16时46分58秒  1000      4808         -    0.00    1.00    0.00    0.00    1.00     2  Web Content
16时46分58秒  1000         -      4808    1.00    1.00    0.00    0.00    2.00     2  |__Web Content
16时46分58秒  1000      5856         -    1.00    2.00    0.00    0.00    3.00     1  pidstat
16时46分58秒  1000         -      5856    1.00    2.00    0.00    0.00    3.00     1  |__pidstat

平均时间:   UID      TGID       TID    %usr %system  %guest   %wait    %CPU   CPU  Command
平均时间:     0         -        20    0.00    0.50    0.00    0.00    0.50     -  |__rcuc/1
平均时间:     0         -        42    0.00    0.50    0.00    0.00    0.50     -  |__kworker/2:1-mm_percpu_wq
平均时间:     0       422         -    0.00    0.50    0.00    0.00    0.50     -  irq/29-iwlwifi
平均时间:     0         -       422    0.00    0.50    0.00    0.00    0.50     -  |__irq/29-iwlwifi
平均时间:     0       971         -    0.50    0.00    0.00    0.00    0.50     -  dockerd
平均时间:     0         -      1040    0.00    0.50    0.00    0.00    0.50     -  |__dockerd
平均时间:     0       974         -    0.50    0.00    0.00    0.00    0.50     -  lxd
平均时间:     0         -       974    0.50    0.00    0.00    0.00    0.50     -  |__lxd
平均时间:     0         -      1003    0.50    0.00    0.00    0.00    0.50     -  |__lxd
平均时间:     0         -      1008    0.00    0.50    0.00    0.00    0.50     -  |__lxd
平均时间:     0      1021         -    0.50    0.00    0.00    0.00    0.50     -  containerd
平均时间:  1000      1277         -    0.00    0.50    0.00    0.00    0.50     -  emacs
平均时间:  1000         -      1277    0.50    0.00    0.00    0.00    0.50     -  |__emacs
平均时间:  1000      1561         -    0.00    0.50    0.00    0.50    0.50     -  Xorg
平均时间:  1000         -      1561    0.00    0.50    0.00    0.50    0.50     -  |__Xorg
平均时间:  1000         -      2906    0.00    0.50    0.00    0.00    0.50     -  |__nutstore
平均时间:  1000      4351         -    1.49    0.00    0.00    0.00    1.49     -  firefox
平均时间:  1000         -      4351    0.50    0.00    0.00    0.00    0.50     -  |__firefox
平均时间:  1000         -      4356    0.00    0.50    0.00    0.00    0.50     -  |__Timer
平均时间:  1000         -      4397    0.50    0.00    0.00    0.00    0.50     -  |__Compositor
平均时间:  1000      4433         -    0.00    0.50    0.00    0.50    0.50     -  Web Content
平均时间:  1000         -      4433    0.50    0.50    0.00    0.50    0.99     -  |__Web Content
平均时间:  1000      4499         -    0.50    0.00    0.00    0.50    0.50     -  Web Content
平均时间:  1000         -      4499    0.50    0.00    0.00    0.50    0.50     -  |__Web Content
平均时间:  1000         -      4502    0.50    0.00    0.00    0.00    0.50     -  |__JS Watchdog
平均时间:  1000         -      4572    0.00    0.50    0.00    0.00    0.50     -  |__WebExtensions
平均时间:  1000      4798         -    0.50    0.00    0.00    0.00    0.50     -  Web Content
平均时间:  1000         -      4798    0.50    0.00    0.00    0.00    0.50     -  |__Web Content
平均时间:  1000      4808         -    0.50    0.50    0.00    0.00    0.99     -  Web Content
平均时间:  1000         -      4808    0.50    0.50    0.00    0.00    0.99     -  |__Web Content
平均时间:  1000         -      4828    0.00    0.50    0.00    0.00    0.50     -  |__Timer
平均时间:  1000      5856         -    1.49    1.49    0.00    0.00    2.97     -  pidstat
平均时间:  1000         -      5856    1.49    1.49    0.00    0.00    2.97     -  |__pidstat
#+END_SRC
*** time
:PROPERTIES:
:interleave_page_note: 252
:END:

time用来运行命令，并报告CPU用量:
#+BEGIN_EXAMPLE
  [lujun9972@T520 wowebook]$ time sleep 1

  real	0m1.007s
  user	0m0.004s
  sys	0m0.000s
#+END_EXAMPLE

其中 =real= 表示运行该命令运行完的实际等待时间是 =1.007s=
其中 =0.004s= 花在用户态上， =0.000s= 花在系统态上，还有 =1.003s= 的时间CPU被阻塞。
*** perf 
:PROPERTIES:
:interleave_page_note: 259
:END:
perf是一整套剖析和跟踪的工具，它有多个子命令，每个子命令都是一个工具。

#+TABLE: perf子命令

| 命令      | 描述                                                 |
|-----------+------------------------------------------------------|
| annotate  | 读取perf.data（由perf record创建）并显示注释过的代码 |
| diff      | 读取两个perf.data文件并显示两份剖析信息之间的差异    |
| evlist    | 列出一个perf.data文件里的事件名称                    |
| inject    | 过滤以加强事件流，在其中加入额外信息                 |
| kmem      | 跟踪/测量kvm客户机操作系统的工具                     |
| list      | 列出所有的符号事件类型                               |
| lock      | 分析锁事件                                           |
| probe     | 定义新的动态跟踪点                                   |
| record    | 运行一个命令，并把剖析信息记录在perf.data中          |
| report    | 读取perf.data并显示剖析信息                          |
| sched     | 跟踪/测量调度器属性（延时）的工具                    |
| script    | 读取perf.data并显示跟踪输出                          |
| stat      | 运行一个命令并收集性能计数器统计信息                 |
| timechart | 可视化某一个负载期间系统总体性能的工具               |
| top       | 系统剖析工具                                               |
**** 系统剖析
perf可以用来剖析CPU调用路径，对CPU时间如何消耗在内核和用户空间进行概括总结。
这项工作由record命令完成，该命令以一定间隔进行取样，并导出到一个perf.data文件中，然后使用report命令查看文件。

下面例子中，所有CPU(-a)以997Hz的频率(-F 997)对调用栈(-g)取样10s(sleep 10)
#+BEGIN_SRC shell :dir /sudo::/tmp :results org
  sudo perf record -a -g -F 997 sleep 10
#+END_SRC

然后使用report命令来讲结果输出到标准输入(--stdio)
#+BEGIN_SRC shell :dir /sudo::/tmp :results org
  sudo perf report --stdio |head -n 20
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
# To display the perf.data header info, please use --header/--header-only options.
#
#
# Total Lost Samples: 0
#
# Samples: 8K of event 'cycles:ppp'
# Event count (approx.): 3391285697
#
# Children      Self  Command          Shared Object               Symbol                                                                                                                           
# ........  ........  ...............  ..........................  .................................................................................................................................
#
    52.70%     0.00%  swapper          [kernel.kallsyms]           [k] secondary_startup_64
            |
            ---secondary_startup_64
               |          
               |--39.07%--start_secondary
               |          cpu_startup_entry
               |          |          
               |           --39.06%--do_idle
               |                     |          
#+END_SRC
**** 进程剖析
:PROPERTIES:
:interleave_page_note: 261
:END:
除了剖析系统中所有CPU外，我们也可以对单个进程进行剖析。

下面命令执行了command并创建文件perf.data
#+BEGIN_SRC shell
  sudo perf record -g command
#+END_SRC
**** 调度器延时
sched命令记录并报告调度器统计信息，例如:
#+BEGIN_SRC shell :dir /sudo::/tmp :results org
  sudo perf sched record sleep 5
  sudo perf sched latency|cat
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org

 -----------------------------------------------------------------------------------------------------------------
  Task                  |   Runtime ms  | Switches | Average delay ms | Maximum delay ms | Maximum delay at       |
 -----------------------------------------------------------------------------------------------------------------
  jbd2/sda2-8:256       |      1.236 ms |        9 | avg:    0.096 ms | max:    0.148 ms | max at:  12660.605688 s
  khugepaged:48         |      0.000 ms |        1 | avg:    0.092 ms | max:    0.092 ms | max at:  12661.015205 s
  ksoftirqd/1:21        |      0.026 ms |        1 | avg:    0.067 ms | max:    0.067 ms | max at:  12659.170227 s
  perf:18804            |      3.165 ms |        1 | avg:    0.066 ms | max:    0.066 ms | max at:  12663.046480 s
  emacsclient:18806     |      5.941 ms |        1 | avg:    0.062 ms | max:    0.062 ms | max at:  12659.148839 s
  WebExtensions:2668    |     16.179 ms |       33 | avg:    0.060 ms | max:    0.091 ms | max at:  12659.782529 s
  rtkit-daemon:(2)      |      0.086 ms |        2 | avg:    0.052 ms | max:    0.076 ms | max at:  12660.462113 s
  iprt-VBoxTscThr:297   |      0.002 ms |        1 | avg:    0.052 ms | max:    0.052 ms | max at:  12659.948431 s
  kworker/3:1H-kb:249   |      0.000 ms |        1 | avg:    0.052 ms | max:    0.052 ms | max at:  12660.588465 s
  usb-storage:17140     |      0.419 ms |        6 | avg:    0.049 ms | max:    0.066 ms | max at:  12660.161970 s
  Web Content:(4)       |    111.227 ms |      204 | avg:    0.048 ms | max:    0.166 ms | max at:  12658.753336 s
  kworker/2:2-eve:233   |      0.118 ms |        8 | avg:    0.047 ms | max:    0.071 ms | max at:  12658.668522 s
  kworker/1:1-eve:56    |      0.177 ms |       13 | avg:    0.047 ms | max:    0.087 ms | max at:  12662.081861 s
  Chrome_~dThread:(5)   |      1.938 ms |        9 | avg:    0.046 ms | max:    0.062 ms | max at:  12658.343273 s
  rcu_preempt:10        |      0.000 ms |       69 | avg:    0.045 ms | max:    0.078 ms | max at:  12659.165194 s
  kworker/u16:0-e:17977 |      6.500 ms |      130 | avg:    0.045 ms | max:    0.090 ms | max at:  12659.039050 s
  kworker/3:2-eve:14850 |      0.319 ms |        8 | avg:    0.044 ms | max:    0.066 ms | max at:  12659.948456 s
  kworker/0:2-eve:213   |      0.580 ms |       14 | avg:    0.043 ms | max:    0.103 ms | max at:  12661.628560 s
  ksoftirqd/3:35        |      0.082 ms |        4 | avg:    0.042 ms | max:    0.053 ms | max at:  12662.262789 s
  Compositor:2551       |    505.629 ms |      362 | avg:    0.039 ms | max:    0.189 ms | max at:  12661.088443 s
  firefox:2503          |     86.426 ms |      335 | avg:    0.036 ms | max:    0.137 ms | max at:  12662.305606 s
  xscreensaver:1838     |      0.388 ms |        2 | avg:    0.036 ms | max:    0.048 ms | max at:  12658.784807 s
  emacs:1272            |      1.411 ms |        5 | avg:    0.035 ms | max:    0.053 ms | max at:  12660.777312 s
  kworker/u17:2-r:884   |      0.337 ms |        7 | avg:    0.034 ms | max:    0.062 ms | max at:  12661.802490 s
  migration/3:33        |      0.000 ms |        1 | avg:    0.033 ms | max:    0.033 ms | max at:  12660.454733 s
  Xorg:1556             |     60.852 ms |      311 | avg:    0.033 ms | max:    0.110 ms | max at:  12660.955077 s
  migration/1:19        |      0.000 ms |        1 | avg:    0.029 ms | max:    0.029 ms | max at:  12660.454706 s
  Gecko_IOThread:2508   |      1.302 ms |        9 | avg:    0.028 ms | max:    0.078 ms | max at:  12662.108214 s
  SCTP timer:(2)        |     49.491 ms |      985 | avg:    0.028 ms | max:    0.140 ms | max at:  12658.732885 s
  migration/2:26        |      0.000 ms |        1 | avg:    0.027 ms | max:    0.027 ms | max at:  12660.454727 s
  dockerd:(9)           |     19.911 ms |      298 | avg:    0.027 ms | max:    0.519 ms | max at:  12658.598484 s
  ksoftirqd/2:28        |      0.403 ms |       18 | avg:    0.026 ms | max:    0.053 ms | max at:  12658.753252 s
  Timer:(6)             |     59.257 ms |      662 | avg:    0.026 ms | max:    0.879 ms | max at:  12659.738562 s
  JS Watchdog:(6)       |      1.453 ms |       28 | avg:    0.025 ms | max:    0.091 ms | max at:  12661.606624 s
  journal-offline:(2)   |      1.514 ms |       13 | avg:    0.025 ms | max:    0.115 ms | max at:  12660.602353 s
  InotifyEventThr:5445  |      2.367 ms |       50 | avg:    0.025 ms | max:    0.062 ms | max at:  12658.058499 s
  nutstore:(9)          |     18.590 ms |      217 | avg:    0.024 ms | max:    0.084 ms | max at:  12662.158416 s
  lxd:(9)               |     40.865 ms |      522 | avg:    0.024 ms | max:    1.477 ms | max at:  12660.742444 s
  Softwar~cThread:2550  |     33.328 ms |      302 | avg:    0.024 ms | max:    0.066 ms | max at:  12659.504224 s
  jbd2/sda3-8:439       |      0.391 ms |        3 | avg:    0.024 ms | max:    0.035 ms | max at:  12661.658040 s
  ksoftirqd/0:9         |      0.142 ms |        8 | avg:    0.024 ms | max:    0.056 ms | max at:  12660.721098 s
  systemd-journal:282   |      0.391 ms |        1 | avg:    0.023 ms | max:    0.023 ms | max at:  12660.590444 s
  containerd:(9)        |     16.213 ms |      232 | avg:    0.023 ms | max:    0.363 ms | max at:  12660.103693 s
  irq/29-iwlwifi:454    |      0.000 ms |      225 | avg:    0.022 ms | max:    0.090 ms | max at:  12661.498451 s
  kworker/u16:1-e:17055 |      0.666 ms |       18 | avg:    0.022 ms | max:    0.067 ms | max at:  12661.628603 s
  migration/0:13        |      0.000 ms |        1 | avg:    0.020 ms | max:    0.020 ms | max at:  12660.454696 s
  kworker/0:1H-ev:243   |      0.104 ms |        2 | avg:    0.018 ms | max:    0.024 ms | max at:  12659.524745 s
  sleep:18805           |      1.399 ms |        2 | avg:    0.017 ms | max:    0.031 ms | max at:  12663.045993 s
  rcuc/1:20             |      0.000 ms |        1 | avg:    0.016 ms | max:    0.016 ms | max at:  12659.170273 s
  rcuc/0:11             |      0.000 ms |        5 | avg:    0.016 ms | max:    0.029 ms | max at:  12662.235134 s
  rcuc/2:27             |      0.000 ms |       17 | avg:    0.016 ms | max:    0.028 ms | max at:  12660.901805 s
  awesome:1830          |     12.056 ms |        6 | avg:    0.012 ms | max:    0.017 ms | max at:  12659.143990 s
  kworker/1:1H-kb:255   |      0.114 ms |        4 | avg:    0.012 ms | max:    0.031 ms | max at:  12659.735099 s
  kworker/2:1H-kb:234   |      0.236 ms |       12 | avg:    0.012 ms | max:    0.037 ms | max at:  12660.600666 s
  rcuc/3:34             |      0.000 ms |        4 | avg:    0.011 ms | max:    0.014 ms | max at:  12658.081183 s
  redshift:1837         |      0.646 ms |        3 | avg:    0.009 ms | max:    0.011 ms | max at:  12659.524992 s
 -----------------------------------------------------------------------------------------------------------------
  TOTAL:                |   1063.877 ms |     5188 |
 ---------------------------------------------------

#+END_SRC

上面显示了跟踪时期平均和最大的调度器延时
**** stat
stat命令基于CPC为CPU周期行为提供了一个概要总结

sched命令记录并报告调度器统计信息，例如:
#+BEGIN_SRC shell :dir /sudo::/tmp :results org
  sudo perf stat sleep 1 2>&1
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org

 Performance counter stats for 'sleep 1':

              1.38 msec task-clock                #    0.001 CPUs utilized          
                 1      context-switches          # 1000.000 M/sec                  
                 0      cpu-migrations            #    0.000 K/sec                  
                66      page-faults               # 66000.000 M/sec                 
         1,429,995      cycles                    # 1429995.000 GHz                 
           976,043      stalled-cycles-frontend   # [31m  68.25%[m frontend cycles idle   
           758,074      stalled-cycles-backend    # [35m  53.01%[m backend cycles idle    
           971,478      instructions              #    0.68  insn per cycle         
                                                  #    1.00  stalled cycles per insn
           197,852      branches                  # 197852000.000 M/sec             
             9,409      branch-misses             #    4.76% of all branches        

       1.002253564 seconds time elapsed

       0.002061000 seconds user
       0.000000000 seconds sys


#+END_SRC

统计信息中包括了上下文切换次数、周期书和指令计数等信息。

使用 =list= 子命令可以列出其他可以检查的计数器
#+BEGIN_SRC shell :results org
  perf list |head
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
  branch-instructions OR branches                    [Hardware event]
  branch-misses                                      [Hardware event]
  bus-cycles                                         [Hardware event]
  cache-misses                                       [Hardware event]
  cache-references                                   [Hardware event]
  cpu-cycles OR cycles                               [Hardware event]
  instructions                                       [Hardware event]
  ref-cycles                                         [Hardware event]
  stalled-cycles-backend OR idle-cycles-backend      [Hardware event]
  stalled-cycles-frontend OR idle-cycles-frontend    [Hardware event]
#+END_SRC

注意那些 =Hardware event= 和 =Hardware cache event= 是否可用取决于处理器架构

这些事件可以使用选项 =-e= 来指定，例如:
#+BEGIN_SRC shell :dir /sudo::/tmp :results org
  sudo perf stat -e instructions,cycles,L1-dcache-load-misses,branch-misses sleep 1 2>&1
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org

 Performance counter stats for 'sleep 1':

           947,672      instructions              #    0.71  insn per cycle                                            
         1,336,684      cycles                                                      
            16,242      L1-dcache-load-misses                                       
             9,272      branch-misses                                               

       1.001847125 seconds time elapsed

       0.001674000 seconds user
       0.000000000 seconds sys


#+END_SRC
**** 软件跟踪
=perf record -e= 可以与各种软件性能探测点配合，用来跟踪内核调度器的活动。
这些测量点包括了软件事件和跟踪点事件(静态探测器),这些测量点可以通过 =perf list= 列出
#+BEGIN_SRC shell :results org
  perf list |grep -i "Software\|Tracepoint"
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
  alignment-faults                                   [Software event]
  bpf-output                                         [Software event]
  context-switches OR cs                             [Software event]
  cpu-clock                                          [Software event]
  cpu-migrations OR migrations                       [Software event]
  dummy                                              [Software event]
  emulation-faults                                   [Software event]
  major-faults                                       [Software event]
  minor-faults                                       [Software event]
  page-faults OR faults                              [Software event]
  task-clock                                         [Software event]
       [Not software-prefetch load dispatches that hit FB allocated for
       [Not software-prefetch load dispatches that hit FB allocated for
        software prefetch]
#+END_SRC

#+BEGIN_SRC shell :dir /sudo::/tmp :results org
  sudo perf record -a -g -e context-switches sleep 1
  sudo perf report --stdio |cat
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
# To display the perf.data header info, please use --header/--header-only options.
#
#
# Total Lost Samples: 0
#
# Samples: 1  of event 'context-switches'
# Event count (approx.): 1
#
# Children      Self  Command  Shared Object      Symbol                         
# ........  ........  .......  .................  ...............................
#
   100.00%   100.00%  sleep    [kernel.kallsyms]  [k] schedule
            |
            ---__nanosleep
               _raw_spin_unlock_irqrestore
               schedule

   100.00%     0.00%  sleep    libc-2.28.so       [.] __nanosleep
            |
            ---__nanosleep
               _raw_spin_unlock_irqrestore
               schedule

   100.00%     0.00%  sleep    [kernel.kallsyms]  [k] _raw_spin_unlock_irqrestore
            |
            ---_raw_spin_unlock_irqrestore
               schedule



#
# (Tip: Skip collecting build-id when recording: perf record -B)
#
#+END_SRC
**** 其他工具

+ oprofile :: 最初的CPU剖析工具
+ htop :: 包括了CPU用量的ASCII柱状图，比最初的top有更强大的交互模式
+ atop :: 包括了更多的系统级统计信息，使用进程核算统计能够捕捉短命进程的存在
+ /proc/cpuinfo :: 可以获得处理器详细信息，包括时钟频率和特征标志位
+ valgrind :: 一个内存调试和剖析工具组。它包括了callgrind,一个跟踪函数调用并生成调用图的工具，可以通过kcachegrind可视化
*** 可视化
:PROPERTIES:
:interleave_page_note: 266
:END:

**** 折线图

**** 使用率热图
使用率与时间的相对关系可以展示成一张热图，每个像素的饱和度代表有多少个CPU在这个时间范围内时这个使用率

**** 亚秒偏移量热图
CPU活动一般以微秒/毫秒为度量单位，报告一秒内品均值会列出很多有用信息。

该类热图每列表示一秒内CPU的变动情况，通过在Y轴上放置亚秒偏移量，每个偏移量上通过像素饱和度来显示非空闲CPU。

**** 火焰图
火焰图可视化了栈帧的剖析信息，可以清楚地理解CPU消耗在哪个代码路径，它具有如下特点:

+ 每个框代表栈里的一个函数
+ Y轴表示栈的深度,顶部的框表示在CPU上执行的函数。下面的是它的父函数及其各级祖先调用者,表示栈回溯
+ X轴横跨整个取样数据，但它没有任何意义，而不是表示时间流逝
+ 框的宽度表示函数在CPU上运行，或是它的上级函数在CPU上运行的时间。更宽的函数框可能比窄框函数慢，也可能时因为调用频繁
+ 如果是多线程运行，而且抽样时并发的情况，抽样计数可能会超过总时间。

