#+INTERLEAVE_PDF: ../../Downloads/性能之巅 洞悉系统、企业与云计算.pdf
#+TITLE: 性能之巅
#+AUTHOR: lujun9972
#+TAGS: linux
#+DATE: [2019-01-03 四 09:20]
#+LANGUAGE:  zh-CN
#+OPTIONS:  H:6 num:nil toc:t \n:nil ::t |:t ^:nil -:nil f:t *:t <:nil
* 操作系统
** 用户栈和内核栈
:PROPERTIES:
:interleave_page_note: 125
:END:
在执行系统调用是，一个进程的线程有两个栈：一个用户级别的栈和一个内核级别的栈。

当线程被阻塞时，用户级别的栈在系统调用期间并不会被改变，因为在内核上下文中执行时，线程用的是一个单独的内核级别的栈。
* 观测工具
** 性能观测工具的分类
:PROPERTIES:
:interleave_page_note: 147
:END:

根据工具是 =系统级别/进程级别= 和 =基于计数/基于跟踪= 这两个维度可以将性能观测工具分成4类:

[[file:./images/screenshot-02.png]]

*** 计数器
内核维护了各种统计数据用于对事件计数，通常计数器实现为无符号的整型，当发生事件时递增。

计数器的使用可以认为是零开销，因为它就在那里，始终由内核维护，唯一的使用开销是从用户空间读取它而已。

系统级别的计数器工具包括:

+ vmstat :: 虚拟内存和物理内存的统计
+ mpstat :: 每个CPU的使用情况
+ iostat :: 每个磁盘IO的使用情况，由块设备接口报告
+ netstat :: 网络接口的统计，TCP/IP栈的统计，以及每个连接的一些统计信息
+ sar :: 各种各样的统计，能归档历史数据

         
进程级别的计数器工具包括:

+ ps :: 查看进程各种统计信息，包括内存和CPU的使用
+ top :: 按一个统计数据排序
+ pmap :: 将进程的内存段和使用统计一起列出

*** 跟踪
跟踪收集每一个事件的数据以供分析。跟踪捕获数据会有CPU开销，还需要不小的存储空间来存放数据，因此可能会拖慢被跟踪的对象。

日志可以被认为是一种默认开启的低频率跟踪。

系统级别的跟踪工具包括:

+ tcpdump :: 网络包跟踪（libpcap库)
+ snoop :: 网络包跟踪工具
+ blktrace :: 块IO跟踪
+ iosnoop :: 基于DTrace的块IO跟踪工具
+ execsnoop :: 基于Dtrace的新进程跟踪工具
+ dtruss :: 基于Dtrace的系统调用缓冲跟踪工具
+ DTrace :: 跟踪内核的内部活动和所有资源的使用情况，支持静态和动态的跟踪
+ SystemTap :: 跟踪内核的内部活动和所有资源的使用情况，支持静态和动态的跟踪
+ perf :: Linux性能事件、静态和动态跟踪的探针

进程级别的跟踪工具包括:

+ strace :: 跟踪Linux系统调用
+ truss :: 跟踪系统调用
+ gdb :: 源码级别的调试器
+ mdb :: 一个具有可扩展性的调试器

*** 剖析(profiling)
profiling通过对目标收集采样或者快照来归纳目标特征

常见的profiler有:

+ oprofile :: Linux系统剖析
+ perf :: Linux性能工具集
+ DTrace :: 程序化剖析，profile provider提供基于时间的剖析，cpc provider提供基于硬件的剖析
+ SystemTap :: 程序化剖析，timer tapset提供基于时间的剖析，perf tapset提供基于硬件的剖析
+ cachegrind :: 源自valgrind工具集，能对硬件缓存的使用做剖析，也能用kcachegrind做数据可视化
+ Intel VTune Amplifier XE :: Linux和Windows的剖析，拥有包括源代码浏览在内的图形界面
+ Oracle Solaris Studio :: 用自带的性能分析器对Solaris和Linux做剖析

此外，编程语言通常有各自的专用分析器

*** 监视
:PROPERTIES:
:interleave_page_note: 150
:END:

最广泛应用的监视工具是sar，它基于计数器，在预定的时间被调用以记录系统计数器的状态

除了sar之外，还有其他的替代，比如System Data Recorder和Collectl

** 观测来源
:PROPERTIES:
:interleave_page_note: 151
:END:

系统性能统计的主要来源包括 =/proc=, =/sys=, =kstat= 等

#+TABLE: 观测来源
| Type               | Linux                      | Solaris         |
|--------------------+----------------------------+-----------------|
| 进程级计数器       | /proc                      | /proc,lxproc    |
| 系统级计数器       | /proc,/sys                 | kstat           |
| 设备驱动和调试信息 | /sys                       | kstat           |
| 进程级跟踪         | ptrace,uprobes             | procfs,dtrace   |
| 性能计数器         | perf_event                 | libcpc          |
| 网络跟踪           | libpcap                    | libdlpi,libpcap |
| 进程级延时指标     | 延时核算                   | 微状态核算      |
| 系统级跟踪         | tracepoints,kprobes,ftrace | dtrace          |

*** /proc
这是一个提供内核统计信息的文件系统接口。 =/proc= 提供很多目录，其中以进程ID命名的目录代表的就是那个进程。
这些目录下的众多文件包含了进程的信息和统计数据，由内核数据结构映射而来。其中，与进程性能观测相关的文件如下:
+ limits :: 实际的资源限制
+ maps :: 映射的内存区域
+ sched :: CPU调度器的各种统计
+ schedstat :: CPU运行时间、延时和时间分片
+ smaps :: 映射内存区域的使用统计
+ stat :: 进程状态和统计，包括总的CPU和内存的使用情况
+ statm :: 以页为单位的内存使用总结
+ status :: stat和statm的信息，用户可读
+ task :: 每个任务的统计目录

Linux将 =/proc= 延伸到了系统级别的统计,与性能观测相关的系统级别的文件包括:
+ cpuinfo :: CPU信息，包括所有虚拟CPU、型号、时钟频率和缓存大小
+ diskstats :: 对所有磁盘设备的磁盘IO统计
+ interrupts :: 每个CPU的中断计数器
+ loadavg :: 负载平均值
+ meminfo :: 系统内存使用明细
+ net/dev :: 网络接口统计
+ net/tcp :: 活跃的TCP套结字信息
+ schedstat :: 系统级别的CPU调度器统计
+ self :: 当前进程ID路径的符号连接
+ slabinfo :: 内核slab分配器缓存统计
+ stat :: 内核和系统资源的统计，CPU、磁盘、分页、交换区、进程
+ zoneinfo :: 内存区信息

关于 =/proc= 的内容可以在 =proc(5)= d的man页和Linux内核文档 =/Documentation/filesystems/proc.txt= 中找到。
Linux中的 =/proc= 的文件系统类型是 =proc=, 而基于Solaris的系统是 =procfs=.

*** /sys
:PROPERTIES:
:interleave_page_note: 156
:END:

Linux还提供了一个sysfs文件系统，挂载在 =/sys=.

#+BEGIN_SRC shell :results org
grep . /sys/devices/system/cpu/cpu0/cache/index*/size
#+END_SRC

#+BEGIN_SRC org
/sys/devices/system/cpu/cpu0/cache/index0/size:32K
/sys/devices/system/cpu/cpu0/cache/index1/size:32K
/sys/devices/system/cpu/cpu0/cache/index2/size:256K
/sys/devices/system/cpu/cpu0/cache/index3/size:3072K
#+END_SRC

这说明CPU0有两个L1缓存，每个都是32KB，还有一个256K的缓存和3M的L3缓存

*** 延时核算
:PROPERTIES:
:interleave_page_note: 159
:END:

开启 =CONFIG_TASK_DELAY_ACCT= 选项的Linux还会跟踪以下状态的时间
+ 调度器延时(CPU) :: 等待轮上CPU的是时间
+ 块IO(IO) :: 等待块IO完成的时间
+ 交换(SWAP) :: 等待内存换页的时间
+ 内存回收(RECLAIM) :: 等待内存回收的时间

*** 其他观测源
:PROPERTIES:
:interleave_page_note: 160
:END:

+ CPU性能计数器 :: 在Linux上通过 =perf_events= 接口，或者系统调用 =perf_event_open(0= ，或者 =perf= 这样的工具来访问
+ 进程级跟踪 :: Linux上可以通过系统调用 =ptrace()= 来控制进程跟踪， =strace= 命令来跟踪系统调用，还有 =uprobes= 来做用户级别的动态跟踪
+ 内核跟踪 :: 在Linux中，tracepoints提供静止的内核探针，kproes提供动态探针。
+ 网络嗅探 :: 在Linux上，嗅探的功能是通过libpcap库和 =/proc/net/dev= 提供的
+ 系统调用 :: 某些系统调用和库函数可以提供性能指标，比如 =getrusage()= 函数可以为进程拿到自己资源的统计信息

** DTrace
:PROPERTIES:
:interleave_page_note: 162
:END:
DTrace的设计是生产环境安全的，拥有极小的性能开销。
DTrace同时支持静态跟踪和动态跟踪，两者功能互补。静态探针有文档完备且稳定的接口，而动态探针能够提供近乎无限的可观测性。
其中，静态跟踪是o通过直接嵌入源代码的静态探针实现的，而动态跟踪是通过内核地址空间的 =live patching= 将函数入口指令修改为引发一个软中断,该软中断会出发指定的action。

DTrace能动态跟踪函数的入口和返回，以及任何在用户空间执行的指令，但这是通过为CPU指令动态建立探针实现的，而CPU指令可能发生改变，因此该接口并不稳定。

*** D语言
DTrace通过一套D语言来设置各个探针，并定义在探针命中时执行的操作。
D语言与awk很像，甚至它也能跟awk一样既能在单行命令中执行，也能写成脚本。D语言的语法形式如下:

#+begin_example
  探针描述 /过滤条件/ {actions}
#+end_example

**** 探针描述
DTrace探针描述分成四个部分:

#+begin_example
  provider:module:function:name
#+end_example

其中， =provider= 是探针的集合，类似于库的概念,
=module= 和 =function= 用来标记探针指示的代码位置，可以用通配符 =*=,或者留空("::"相当于":*:")来表示任意位置。
=name= 则是探针的名字。

可用的provider取决于你的DTrance和操作系统的版本，比较常见的provider有:

+ syscall :: 系统调用自陷表
+ vminfo :: 虚拟内存统计
+ sysinfo :: 系统统计
+ profile :: 任意频率的采样
+ sched :: 内核调度事件
+ proc :: 进程级别事件，比如创建、执行、退出
+ io :: 块设备接口跟踪
+ pid :: 用户级别动态跟踪
+ tcp :: TCP协议事件，网络连接，数据包发送和接受
+ ip :: IP协议事件，发送和接受
+ fbt :: 内核级别动态跟踪
+ 其他高级语言的provider :: 比如Java，JavaScript，Node.js，Perl，Python,Ruby,Tcl等

**** 参数
探针通过参数来获取数据，不同探针接受的参数也不一样。
我们可以通过 =arg0...argN= 来获取这些参数，可以通过 =dtrace -lv= 选项来查看每个provider参数的概要说明。

**** 跟
内置变量awk一样，DTrace默认也提供了一些内置变量，可以在 =过滤条件= 和 =action= 中使用. 常见的内置变量有:

#+TABLE: 常用内置变量

| 变量            | 描述                         |
|-----------------+------------------------------|
| execname        | 执行的进程名字               |
| uid             | 用户ID                       |
| pid             | 进程ID                       |
| timestamp       | 当前时间，为自启动以来的ns数 |
| vtimestamp      | 线程执行时间，单位是ns       |
| arg0...argN     | 探针参数                     |
| arg[0]...arg[N] | 探针参数                     |
| curthread       | 指向当前线程内核结构的指针   |
| probefunc       | 探针触发的function位置       |
| probename       | 探针名称                     |
| curpsinfo       | 当前进程信息                 |

*** 过滤条件
=/过滤条件/= 这一部分是可选的，例如
#+begin_example
  proc:::exec-success /execname == "httpd"/ {trace(pid);}
#+end_example
就会限定指定对 =httpd= 进程执行 =trace(pid)= 这一action

如果省略这一部分，则表示不做过滤。
*** action
action指定了当触发探针时做的操作，常见的action包括:

#+TABLE: 常见action
| action                 | 描述                                                                       |
|------------------------+----------------------------------------------------------------------------|
| trace(arg)             | 输出arg的值                                                                |
| printf(format,arg,...) | 格式化输出arg的值                                                          |
| stringof(addr)         | 返回来自内核空间的字符串                                                   |
| copyinstr(addr)        | 返回来自用户空间的字符串（需要内核执行一次从用户空间到内核空间的复制操作） |
| stack(count)           | 打印内核级别的栈跟踪，如果有count则按count截断                             |
| ustack(count)          | 打印用户级别的栈跟踪，如果有count则按count截断                             |
| func(pc)               | 根据内核程序计数器(pc),返回内核函数名                                      |
| ufunc(pc)              | 根据用户程序计数器(pc),返回用户函数名                                      |
| exit(status)           | 退出DTrace，并返回状态                                                     |
| trunc(@agg,count)      | 截断聚合变量，若没有count则表示清空该聚合变量                              |
| clear(@agg)            | 清空聚合变量中各个键对应的值                                               |
| printa(format,@agg)    | 格式化输出聚合变量中的值                                                               |
*** 变量类型
:PROPERTIES:
:interleave_page_note: 192
:END:
#+TABLE: 变量类型及开销

| 类型               | 前缀   | 作用域         | 开销   | 多CPU是否安全 | 示例             |
|--------------------+--------+----------------+--------+---------------+------------------|
| 聚合变量           | @      | 全局           | 低     | 是            | @x = count();    |
| 带键的聚合变量     | @[]    | 全局           | 低     | 是            | @x[pid]=count(); |
| action子句局部变量 | this-> | action子句内部 | 非常低 | 是            | this->x=1;       |
| 线程局部变量       | self-> | 线程内         | 中等   | 是            | self->x=1;       |
| 标量               | 无     | 全局           | 中下   | 否            | x=1;             |
| 关联数组           | 无     | 全局           | 中上   | 否            | x[y]=1;         |

其中，聚合变量是一种特殊类型的变量，可以由CPU单独计算汇总之后再传递到用户空间。
该变量类型拥有最低的开销，是另一种数据汇总的方法。

下面这些action可以用来填充聚合变量

#+TABLE: 聚合action
| 聚合action                                                 | 描述                                              |
|------------------------------------------------------------+---------------------------------------------------|
| count()                                                    | 发生计数                                          |
| sum(value)                                                 | 对value求和                                       |
| min(value)                                                 | 记录value的最小值                                 |
| max(value)                                                 | 记录value的最大值                                 |
| quantize(value)                                            | 用2的幂次方直方图记录value                        |
| lquantize(value,min,max,step)                              | 用给定最小值、最大值和步进值做线性直方图记录value |
| llquantize(value,factor,min)magnitude,max_magnitude,steps) | 用混合对数/线性直方图记录value                                |
* 应用程序
** 应用程序性能技术
:PROPERTIES:
:interleave_page_note: 184
:END:

提高应用的常用技术包括:

+ 选择IO尺寸
+ 缓存/缓冲区
+ 轮询
+ 并发和并行
+ 非阻塞IO和处理器帮顶
*** 选择IO尺寸
执行IO的开销包括初始化缓冲区、系统调用、上下文切换分配内核元数据、检查进程权限和限制、映射地址到设备、执行内核和驱动代码来执行IO、释放元数据和缓冲区。
其中，初始化缓冲区的开销对于大型IO和小型IO来说都是差不多的，一般来讲每次IO传输的数据越多，效率越高。

增加IO尺寸是应用程序提高吞吐量的常用策略。但过大的IO尺寸会浪费缓存空间
*** 缓存
:PROPERTIES:
:interleave_page_note: 185
:END:

缓存的一个重要方面就是如何保证完整性，确保查询不会返回过期的数据，这被称为存的一致性。

过大的缓冲区可能会增加写延时，这是因为为了等待缓存区被写满，可能需要等待很多的时间。
*** 轮询
轮询是系统等待某一事件发生的技术，该技术在循环中检查事件状态。
轮询中有一些潜在的性能问题:

+ 循环检查导致CPU的开销过高
+ 循环之间的行为可能导致事件发生和下一次检查之间的延时较高。
**** poll()系统调用
poll()系统调用用来检查文件描述符的状态，提供与轮询相似的能力，不过它基于事件的，没有轮询那样的性能负担。

poll()借口将多个文件描述符放在数组中，应用系统扫描整个数组来寻找相应的文件描述符
这个扫描是O(n)的，因此可能会引发性能问题。
**** epoll()
:PROPERTIES:
:interleave_page_note: 188
:END:
Linux中提供了epoll()系统调用，它能够避免这种扫描，时间复杂度是O(1)
Notes for page 188**** 并发和并行
:PROPERTIES:
:interleave_page_note: 186
:END:
并发除了使用同步原语来保障完整性之外，还一般会与hash表一同使用来提高性能。

常见的同步原语有三种类型:

+ 排它锁(mutex) :: 只有锁持有者才能操作，其他线程阻塞并等待CPU
+ 自旋锁 :: 自旋锁允许所持有者操作，其他需要自旋锁的线程则会在CPU上循环自旋，检查锁是否被释放。这样的好处是线程不离开CPU，能够延时低，但是另一方面浪费CPU资源
+ 读写锁 :: 读写锁允许多个读者，但是只能有一个写着。

**** 使用hash表减少锁竞争
创建固定数目的锁，用hash算法来选择哪个锁用于哪个数据结构，这样可以减少锁的竞争。

一般来说，为了最大程度的并行，hash表的桶的数目应该大于或等于CPU的数目。

*** 非阻塞IO
在进程IO是进行阻塞，这种模型存在以下两个性能问题:

1. 由于每一次阻塞就是消耗一个线程/进程，因此对于多路并发的IO就意味着会创建很多的线程/进程，线程/进程的创建和销毁代码巨大。
2. 对于频繁发起的短时IO，会导致频换切换上下文，从而增加CPU资源的消耗。

而非阻塞IO模型则是异步发起IO，不阻塞当前的线程，线程可以执行其他工作。当IO完成后再通过信号通知线程继续下面的工作。

*** 处理器绑定
在使用NUMA的多处理器系统中将进程绑定到某个处理器运行，可以一直使用该CPU的本地存储器，从而减少对内存的IO，提高应用程序的整体性能。

但CPU绑定也会带来风险，比如若其他用户或程序也刚好用到这个绑定的CPU，则可能会引发冲突和调度器延时。

** 编程语言
:PROPERTIES:
:interleave_page_note: 189
:END:
解析器和语言虚拟机一般都有自己专门的工具来做不同级别的性能观测.

对于编译语言我们可以通过编译器优化来提升性能，但优化程度越高，其产生的机器码与源代码之间的映射关系就越模糊，可能会使性能分析变得不那么直观。

GC是常见的性能调整对象，用以降低CPU成本和减少延时时异常值的发生。
比如Java虚拟机就提供了许多可调参数来设置GC类型，GC线程数，堆尺寸最大值、目标堆空闲率等。

** 分析方法

*** 线程状态分析
:PROPERTIES:
:interleave_page_note: 192
:END:
线程状态分析的目的是分辨应用程序线程的时间用在了什么地方。

在线程状态分析时，我们可以把线程状态分成下面几中类型：
+ 执行 :: 正在CPU上执行
+ 可运行 :: CPU时间片耗尽，等待下一次轮询
+ 匿名换页 :: 因内存换页而受阻
+ 睡眠 :: 等待网络、块设备等IO操作完成
+ 锁 :: 等待获取同步锁
+ 空闲 :: 等待工作

提高性能的关键在于减少线程处于前五类状态的时间，针对线程处于哪类状态，我们可以做进一步的研究:
+ 执行 :: 检查线程实在用户态执行还是内核态执行，用profiling对CPU资源消耗情况进行分析，确定哪些代码路径消耗的CPU过大
+ 可运行 :: 这可能意味着应用程序需要更多的CPU资源，检查整个系统的CPU负载以及是否对应用程序做了CPU限制
+ 匿名换页 :: 应用程序缺少主存会引起换页，需要检查整个系统的内存使用情况，是否对应用程序做了不合理的内存限制
+ 睡眠 :: 分析到底是哪些资源导致应用程序阻塞，IO是否异常
+ 锁 :: 识别那些线程持有锁，确定线程持锁这么长时间的原因。

Linux系统为我们提供了下面这些工具进行分析:
+ 使用 =top= 命令可以查看各个进程的CPU消耗情况
+ 内核的 =schedstat= 功能会追踪可运行的线程，并将信息显示在 =/proc/$pid/schedstat= 中
+ =perf sched= 工具也提供了用于了解可运行线程与等待线程所花时间的指标
+ =pidstat -d= 可以判断一个进程实在执行磁盘IO还是睡眠
+ =iotop= 能够查看各个进程的io情况
+ 若某个应用程序的睡眠时间很长（达到秒级），则可以用pstack输出堆栈快照来调查原因。

*** CPU剖析
剖析的目标是要判断应用程序是如何消耗CPU资源的。一个有效的技术是对CPU上的用户栈跟踪做采样并将采样结果联系起来。
这些栈信息能够让告诉我们代码的执行路径，从而揭示出应用程序消耗CPU的原因。

针对解释语言和虚拟机语言的CPU剖析是很难的，因为从执行的代码到原始的程序之间并没有简单的映射关系。
只能寄希望于

*** 系统调用分析
:PROPERTIES:
:interleave_page_note: 197
:END:
系统调用分析的目标是要找出系统调用的时间花在什么地方，还有系统调用的类型以及使用该系统调用的原因。

**** strace命令
在Linux下可以使用strace命令跟踪系统调用，例如:
#+BEGIN_SRC shell
  strace -ttt -T -p $(pidof emacs)
#+END_SRC

#+BEGIN_EXAMPLE
  [lujun9972@T520 8948]$ sudo strace -ttt -T -p $(pidof emacs)
  strace: Process 6407 attached
  1546945285.834914 pselect6(21, [3 5 6 7 8 10 12 19 20], [], NULL, {tv_sec=2, tv_nsec=500433727}, {NULL, 8}) = 1 (in [7], left {tv_sec=0, tv_nsec=978006169}) <1.522453>
  1546945287.357587 rt_sigprocmask(SIG_BLOCK, [INT], [], 8) = 0 <0.000122>
  1546945287.357868 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0 <0.000045>
  1546945287.358029 accept4(7, {sa_family=AF_UNIX}, [112->2], SOCK_CLOEXEC) = 9 <0.000071>
  1546945287.358181 fcntl(9, F_SETFL, O_RDONLY|O_NONBLOCK) = 0 <0.000011>
  1546945287.358237 getsockname(9, {sa_family=AF_UNIX, sun_path="/tmp/emacs1000/server"}, [112->24]) = 0 <0.000008>
  1546945287.358430 recvmsg(10, {msg_namelen=0}, 0) = -1 EAGAIN (资源暂时不可用) <0.000009>
  1546945287.359993 poll([{fd=8, events=POLLIN}, {fd=10, events=POLLIN}, {fd=12, events=POLLIN}], 3, 0) = 0 (Timeout) <0.000012>
  1546945287.360174 rt_sigprocmask(SIG_BLOCK, [INT], [], 8) = 0 <0.000018>
  1546945287.360250 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0 <0.000010>
  1546945287.360288 pselect6(21, [3 5 6 7 8 9 10 12 19 20], [], NULL, {tv_sec=0, tv_nsec=975134338}, {NULL, 8}) = 1 (in [9], left {tv_sec=0, tv_nsec=975125651}) <0.000023>
  1546945287.360361 rt_sigprocmask(SIG_BLOCK, [INT], [], 8) = 0 <0.000023>
  1546945287.360432 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0 <0.000007>
  1546945287.360474 read(9, "-dir /home/lujun9972/ -current-f"..., 4096) = 332 <0.000016>
  1546945287.360624 getpid()              = 6407 <0.000008>
  1546945287.360659 write(9, "-emacs-pid 6407\n", 16) = 16 <0.000016>
  1546945287.361017 stat("/home/lujun9972", {st_mode=S_IFDIR|0710, st_size=12288, ...}) = 0 <0.000017>
  1546945287.361351 write(9, "-print nil\n", 11) = 11 <0.000015>
  1546945287.361517 close(9)              = 0 <0.000023>
  1546945287.363620 rt_sigprocmask(SIG_BLOCK, [WINCH IO], NULL, 8) = 0 <0.000020>
  1546945287.363783 poll([{fd=10, events=POLLIN|POLLOUT}], 1, -1) = 1 ([{fd=10, revents=POLLOUT}]) <0.000012>
  1546945287.363836 writev(10, [{iov_base=";\0\5\0\325\1\340\2\0\0\0\0x\3\202\2\315\1\22\0C\0\5\0H\1\340\2\325\1\340\2"..., iov_len=148}, {iov_base=NULL, iov_len=0}, {iov_base="", iov_len=0}], 3) = 148 <0.000020>
#+END_EXAMPLE

其中:

+ -ttt :: 在第一栏输出UNIX时间戳，以秒为单位，精确度可以到毫秒级
+ -T :: 在最后一栏输出系统调用的时间，以秒为单位，精确到毫秒级别
+ -p $PID :: 跟踪某个PID的进程

上述形式的strace没一行都表示一个系统调用。若只想输出系统调用活动的统计信息可以使用 =-c= 选项
#+BEGIN_SRC shell :results org
  strace -c date 2>&1
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
2019年 01月 08日 星期二 19:11:10 HKT
% time     seconds  usecs/call     calls    errors syscall
------ ----------- ----------- --------- --------- ----------------
 20.00    0.000032           5         6           close
 18.75    0.000030           7         4           openat
 17.50    0.000028           4         6           fstat
 15.00    0.000024          24         1           write
 10.62    0.000017           2         6           read
  6.88    0.000011           1         8           mmap
  6.88    0.000011           3         3           brk
  4.38    0.000007           1         4           lseek
  0.00    0.000000           0         4           mprotect
  0.00    0.000000           0         1           munmap
  0.00    0.000000           0         1         1 access
  0.00    0.000000           0         1           execve
  0.00    0.000000           0         2         1 arch_prctl
------ ----------- ----------- --------- --------- ----------------
100.00    0.000160                    47         2 total
#+END_SRC

其中:
+ time :: 显示系统CPU时间花在哪里的百分比
+ seconds :: 总的系统CPU时间，单位是秒
+ usecs/call :: 每次调用的平均系统CPU时间，单位是毫秒
+ calls :: 整个strace过程中系统嗲用的次数
+ syscall :: 系统调用的名字
**** truss
:PROPERTIES:
:interleave_page_note: 199
:END:
在Solaris系统上使用truss命令来分析系统调用,例如
#+BEGIN_SRC shell
  truss -dE -p $(pidof emacs)
#+END_SRC

这里的选项：
+ -d :: 输出命令启动后的秒数
+ -E :: 输出系统调用的耗时，单位为秒
+ -p PID :: 指定跟踪的进程

同样的，truss也使用 =-c= 选项进行系统调用的统计总结:
#+BEGIN_SRC shell
  truss -c dd if=/dev/zero of=/dev/null bs=1k count=10k
#+END_SRC

truss还可以使用 =-u= 选项对用户级函数进行动态跟踪，例如跟踪 =printf= 调用:
#+BEGIN_SRC shell
  truss -u 'libc:*printf*' uptime
#+END_SRC

**** 缓存跟踪
:PROPERTIES:
:interleave_page_note: 201
:END:

与断点跟踪相比，缓存跟踪并不会中断目标程序的执行，而是将监控程序缓存在内核中。

在perf中可以通过trace子命令来执行系统调用的缓存跟踪:
#+BEGIN_SRC shell :results org :dir /sudo::/tmp
  sudo perf trace touch a 2>&1
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
         ? (         ): touch/26378  ... [[33mcontinued[m]: execve()) = 0
     0.080 ( 0.006 ms): touch/26378 brk(                                                                  ) = 0x55d62ec22000
     0.093 ( 0.004 ms): touch/26378 arch_prctl(option: 12289, arg2: 140723363955488                       ) = -1 EINVAL Invalid argument
     0.134 ( 0.010 ms): touch/26378 access(filename: 0xe6f043a0, mode: R                                  ) = -1 ENOENT No such file or directory
     0.153 ([33m 0.011 ms[m): touch/26378 openat(dfd: CWD, filename: 0xe6f01891, flags: CLOEXEC                 ) = 3
     0.169 ( 0.005 ms): touch/26378 fstat(fd: 3, statbuf: 0x7ffcb61eb500                                  ) = 0
     0.178 ([33m 0.011 ms[m): touch/26378 mmap(len: 308934, prot: READ, flags: PRIVATE, fd: 3                   ) = 0x7f89e6e93000
     0.193 ( 0.004 ms): touch/26378 close(fd: 3                                                           ) = 0
     0.231 ( 0.009 ms): touch/26378 openat(dfd: CWD, filename: 0xe6f0ac70, flags: CLOEXEC                 ) = 3
     0.244 ( 0.006 ms): touch/26378 read(fd: 3, buf: 0x7ffcb61eb6c8, count: 832                           ) = 832
     0.255 ( 0.004 ms): touch/26378 lseek(fd: 3, offset: 792, whence: SET                                 ) = 792
     0.262 ( 0.004 ms): touch/26378 read(fd: 3, buf: 0x7ffcb61eb580, count: 68                            ) = 68
     0.271 ( 0.004 ms): touch/26378 fstat(fd: 3, statbuf: 0x7ffcb61eb560                                  ) = 0
     0.279 ( 0.008 ms): touch/26378 mmap(len: 8192, prot: READ|WRITE, flags: PRIVATE|ANONYMOUS            ) = 0x7f89e6e91000
     0.298 ( 0.004 ms): touch/26378 lseek(fd: 3, offset: 792, whence: SET                                 ) = 792
     0.305 ( 0.004 ms): touch/26378 read(fd: 3, buf: 0x7ffcb61eb1d0, count: 68                            ) = 68
     0.313 ( 0.003 ms): touch/26378 lseek(fd: 3, offset: 864, whence: SET                                 ) = 864
     0.320 ( 0.004 ms): touch/26378 read(fd: 3, buf: 0x7ffcb61eb1f0, count: 32                            ) = 32
     0.328 ([33m 0.010 ms[m): touch/26378 mmap(len: 1848896, prot: READ, flags: PRIVATE|DENYWRITE, fd: 3        ) = 0x7f89e6ccd000
     0.343 ([33m 0.019 ms[m): touch/26378 mprotect(start: 0x7f89e6cef000, len: 1671168                          ) = 0
     0.366 ([33m 0.017 ms[m): touch/26378 mmap(addr: 0x7f89e6cef000, len: 1355776, prot: EXEC|READ, flags: PRIVATE|FIXED|DENYWRITE, fd: 3, off: 139264) = 0x7f89e6cef000
     0.388 ([33m 0.010 ms[m): touch/26378 mmap(addr: 0x7f89e6e3a000, len: 311296, prot: READ, flags: PRIVATE|FIXED|DENYWRITE, fd: 3, off: 1495040) = 0x7f89e6e3a000
     0.402 ([33m 0.013 ms[m): touch/26378 mmap(addr: 0x7f89e6e87000, len: 24576, prot: READ|WRITE, flags: PRIVATE|FIXED|DENYWRITE, fd: 3, off: 1806336) = 0x7f89e6e87000
     0.427 ([33m 0.011 ms[m): touch/26378 mmap(addr: 0x7f89e6e8d000, len: 13888, prot: READ|WRITE, flags: PRIVATE|FIXED|ANONYMOUS) = 0x7f89e6e8d000
     0.455 ( 0.004 ms): touch/26378 close(fd: 3                                                           ) = 0
     0.557 ( 0.006 ms): touch/26378 arch_prctl(option: 4098, arg2: 140230261286272                        ) = 0
     0.691 ([33m 0.016 ms[m): touch/26378 mprotect(start: 0x7f89e6e87000, len: 16384, prot: READ                ) = 0
     0.760 ( 0.010 ms): touch/26378 mprotect(start: 0x55d62e37e000, len: 4096, prot: READ                 ) = 0
     0.781 ([33m 0.011 ms[m): touch/26378 mprotect(start: 0x7f89e6f08000, len: 4096, prot: READ                 ) = 0
     0.797 ([33m 0.029 ms[m): touch/26378 munmap(addr: 0x7f89e6e93000, len: 308934                              ) = 0
     1.004 ( 0.005 ms): touch/26378 brk(                                                                  ) = 0x55d62ec22000
     1.013 ( 0.008 ms): touch/26378 brk(brk: 0x55d62ec43000                                               ) = 0x55d62ec43000
     1.036 ([33m 0.011 ms[m): touch/26378 openat(dfd: CWD, filename: 0xe6e588a0, flags: CLOEXEC                 ) = 3
     1.052 ( 0.004 ms): touch/26378 fstat(fd: 3, statbuf: 0x7f89e6e8c920                                  ) = 0
     1.060 ([33m 0.011 ms[m): touch/26378 mmap(len: 6180864, prot: READ, flags: PRIVATE, fd: 3                  ) = 0x7f89e66e8000
     1.084 ( 0.004 ms): touch/26378 close(fd: 3                                                           ) = 0
     1.159 ([33m 0.011 ms[m): touch/26378 openat(dfd: CWD, filename: 0xb61ecea9, flags: CREAT|NOCTTY|NONBLOCK|WRONLY, mode: IRUGO|IWUGO) = 3
     1.175 ( 0.004 ms): touch/26378 dup2(oldfd: 3                                                         ) = 0
     1.183 ( 0.003 ms): touch/26378 close(fd: 3                                                           ) = 0
     1.190 ( 0.007 ms): touch/26378 utimensat(                                                            ) = 0
     1.200 ( 0.003 ms): touch/26378 close(                                                                ) = 0
     1.220 ( 0.004 ms): touch/26378 close(fd: 1                                                           ) = 0
     1.229 ( 0.003 ms): touch/26378 close(fd: 2                                                           ) = 0
     1.251 (         ): touch/26378 exit_group(                                                           )
#+END_SRC

*** I/O剖析
:PROPERTIES:
:interleave_page_note: 203
:END:

与CPU剖析作用类似，I/O剖析判断的是I/O相关的系统调用（比如read(),write()）执行的原因和方式。

比如下面dtrace命令跟踪PostgreSQL的read()系统调用，并收集用户级别的栈跟踪:
#+BEGIN_SRC shell
  dtrace -n 'syscall::read:entry /execname == "postgres"/ {@[ustack()] = count();}'
#+END_SRC

*** USE方法
:PROPERTIES:
:interleave_page_note: 204
:END:

USE方法通过检查资源的使用率，饱和度和发生的错误来判断某一资源是否成为瓶颈。

例如若系统为文件描述符设置了一个数量上限，则相应的指标为:

+ 使用率 :: 使用中文件描述符的数量，与系统设置上限的比率
+ 饱和度 :: 等待文件描述符分配的线程数
+ 错误 :: 分配失败，提示EFILE，打开太多文件。

*** 锁分析
:PROPERTIES:
:interleave_page_note: 205
:END:

对于多线程的应用程序，锁可能会成为阻碍并发和扩展性的瓶颈。

对于自旋锁来说，当锁出现竞争时，CPU使用率也会发生变化。
通过对CPU进行栈跟踪通常能识别出来。

*** 静态性能调优
:PROPERTIES:
:interleave_page_note: 208
:END:

静态性能调优是通过对程序运行环境的检查，看是否有优化的空间，例如:

+ 运行的程序是什么版本？是否有更新版本？发布说明是否提及性能提高
+ 应用程序有哪些已知的性能问题？有可供搜索的bug数据库吗？
+ 应用程序是怎么配置的？能通过调整配置优化速度吗？
+ 应用程序利用了缓存吗？缓存大小如何？
+ 应用程序是并发运行吗？线程池大小如何？
+ 应用程序是在调试模式下运行吗？
+ 应用程序用到了哪些程序库？他们的版本是什么？
+ 应用程序用的是怎样的内存分配器
+ 应用程序用大页面做堆吗？
+ 应用程序是编译的吗？编译器版本是什么？优化选项有哪些？
+ 应用程序遇到错误了吗？发生错误后会运行在降级模式吗？
+ 有没有系统资源方面的限制？

* CPU
:PROPERTIES:
:interleave_page_note: 212
:END:

正在排队和就绪运行的软件线程数量是一个很重要的性能指标，表示了CPU的饱和度。
花在等待CPU运行上的时间又被称为运行队列延时或者分发器队列延时。

对于多处理器系统，内核通常为每个CPU提供了一个运行队列，并尽量使每个线程每次都放在同一个队列。
这是因为CPU缓存中很可能保存了该线程的数据，同时在NUMA系统中，这会提高内存本地性，从而提高系统性能。

** CPU相关指标
:PROPERTIES:
:interleave_page_note: 217
:END:

*** CPI(每指令周期数)/IPC(每周期指令数)
高CPI说明CPU经常陷入停滞，比如在等待内存访问，这种情况下更快的CPU并不能提高速度

*** 使用率
CPU使用率通过测量一段时间内CPU忙于执行工作的时间比率获得，以百分比表示。
比较违反直觉的是，CPU使用率的测量包括了内存滞留周期，也就是说CPU停滞等待IO也可能会导致高使用率。

*** 用户时间与内核时间之比
:PROPERTIES:
:interleave_page_note: 218
:END:
CPU花在用户态应用程序代码的时间称为用户时间，而执行内核态代码的时间称为内核时间。 内核时间包括系统调用、内核线程和中断的时间。
挡在整个系统范围内进行测量时，用户时间和内核时间之笔揭示了运行的负载类型。

计算密集型的应用程序几乎会把大量的时间用在用户态代码上，用户/内核时间可以接近99/1.

IO密集型的应用程序则需要频繁调用内核代码进行IO操作，用户/内核时间比可以降到70/30.

*** 饱和度
一个100%使用率的CPU被称为是饱和的，因为线程会遇到调度器延时，必须等待才能在CPU上运行。

不过由于Linux支持抢占式线程，因此CPU饱和并不意味着一定影响速度。


** CPU架构
:PROPERTIES:
:interleave_page_note: 221
:END:

CPU硬件包括了处理器和它的子系统，以及多处理器之间的CPU互联

*** 处理器
一颗通用双核处理器的组件如下图所示:
[[file:./images/screenshot-01.png]]
其中组建包括:
+ 控制器 :: CPU的心脏，运行指令预取、解码、管理执行以及存储结果
+ P-cache :: 预取缓存，每个CPU一个
+ W-cache :: 写缓存，每个CPU一个
+ 时钟 :: CPU时钟信号生成器
+ 时间戳计数器 :: 为了高精度、由时钟递增
+ 微代码ROM :: 快速把指令转换成电路信号
+ 温度传感器 :: 温度监控，有些CPU将温度传感器作为动态超频的依据
+ 网络接口 :: 有些CPU为了高性能，会将网路接口集成到芯片中。

*** CPU缓存
CPU缓存级别层次如下所示:
[[file:./images/screenshot-03.png]]

+ 一级指令缓存(I$)，延时大概几个CPU周期
+ 一级数据缓存(D$)，延时大概几个CPU周期
+ 转译后备缓冲器(TLB),缓存虚拟内存到物理内存的转换结果
+ 二级缓存(E$)，延时大概几十个CPU周期
+ 三级缓存(可选)

为了减少访问缓存的延时，一般会将缓存做到处理器内部

缓存带来的一个问题就是缓存一致性：即当一个CPU修改了内存后，所有的其他CPU缓存也需要知道它们的缓存拷贝已经失效，需要被丢弃。
*** CPU性能计数器
CPU性能计数器是用于计数低级CPU活动的处理器寄存器
*** 内核空闲线程
:PROPERTIES:
:interleave_page_note: 233
:END:
内核空闲线程是只在没有其他可运行线程的时候才在CPU上运行，它的优先级最低，通常被设计为通知CPU停止执行或者减速执行以节省资源。
CPU会在下一次硬件中断发生时醒来。
** CPU分析和调优的方法
:PROPERTIES:
:interleave_page_note: 234
:END:
*** 工具法
工具法就是把可用的工具全都用一遍，检查他们提供的关键项指标。

+ uptime :: 检查负载平均数，若负责平均数超过CPU数量则通常代表CPU饱和
+ vmstat :: 检查内存空闲余量。少于10%可能会有问题
+ mpstat :: 检查是否存在单个CPU繁忙
+ top/prstat :: 查看哪个进程和用户是CPU消耗大户
+ pidstat/prstat :: 查看CPU消耗大户的用户/系统时间的占比情况
+ perf/dtrace/stap/oprofile :: 剖析CPU使用的堆栈跟踪，了解为什么使用这么多CPU
+ perf/cpustat :: 测量CPI
*** USE方法
:PROPERTIES:
:interleave_page_note: 235
:END:
USE方法可以在性能调查早期进行，用来发现所有组件内的瓶颈和错误。

对每个CPU检查下面内容:
+ 使用率 :: 每个CPU繁忙的时间，可能存在一个CPU繁忙，其他CPU空闲的情况
+ 饱和度 :: 可运行线程排队等待CPU的数量
+ 错误 :: CPU是否有相关错误发生，比如有些操作系统在CPU发生错误时可能会关闭CPU，因此可以检查CPU是否都在线。
*** 归纳负载特征
:PROPERTIES:
:interleave_page_note: 236
:END:

+ CPU使用率与饱和度，反映了CPU的请求负载
+ 用户时间和系统时间占比,反映了负载类型
+ 系统调用频率
+ 自愿上下文切换频率
+ 中断频率

IO消耗型负载因为线程阻塞等待IO，从而有更高的系统时间、中断频率以及自愿上下文切换频率
**** 负载特征归纳检查清单
+ 整个系统范围内的CPU使用率是多少？每个CPU的使用率呢？
+ CPU负载的并发程度如何？是单线程吗？有多少线程
+ 哪个应用程序或用户在用CPU，用了多少？
+ 哪个内核线程在用CPU？用了多少？
+ CPU中断频率高吗？
+ CPU互联频率高吗？
+ CPU被用来做什么(用户和内核的调用路径)?
*** Profile
通过定期对CPU进行采样可以大致分析出CPU的代码执行路径。
*** CPU周期分析
通过使用CPU性能计数器(CPC),我们能够以周期级别理解CPU使用率。
这可以展示消耗在一级、二级、三级缓存未命中，内存IO以及资源IO上的停滞周期以及花在浮点运算和其他活动上的周期数。
拿到这些信息后就可以通过调整编译器选项或修改代码来提高性能。

周期分析从测量CPI开始，若CPI较高，则继续调查停滞周期的类型;如果CPI较低，就寻找减少指令数量的方法。

 除了测量计数器的值之外，还可以配置CPC，在超出某个值时中断内核，例如每10000此二级缓存未命中，就中断一次内核以获取栈回溯。
*** 静态性能调优
关于CPU性能，检查下列方面的静态信息：
+ 有多少CPU可用？多少核，每个核多少线程？
+ CPU的缓存多大？是共享缓存吗？
+ CPU时钟频率是多少，支持动态加速功能吗？
+ BIOS中启用/禁止了哪些CPU相关特性？
+ 这款型号的处理器是否有已知的BUG？
+ 操作系统是否对应用的CPU使用做了限制(资源控制)？
+ 进程优先级是多少?
*** 优先级调试
UNIX提供了 =nice()= 系统调用，用于调整进程优先级。 nice值越高，则表示进程优先级越低。
一般监控代理程序和定期备份程序可以有较低的优先级。

除了nice值，操作系统还为进程提供了更高级的控制，比如更改调度类或者调度器策略。
例如实时调度类允许进程抢占所有的其他工作，这样可以消除调度器延时，但若进程本身陷入死循环则所有其他进程都无法使用CPU
*** CPU绑定
:PROPERTIES:
:interleave_page_note: 240
:END:
另一个CPU性能调优的方法是把进程/线程绑定在单个CPU或一组CPU上，这可以增加进程CPU缓存命中率，提高内存IO性能，对于NUMA系统还可以提高内存本地性。

CPU绑定有两种方式:
+ 进程绑定 :: 配置一个进程只在某个CPU或某组CPU中的某一个上运行
+ 独占CPU组 :: 通过 =cpuse= 指定某组CPU只能运行指定的进程，由于其他进程不能使用CPU从而能够提高CPU缓存的效率。
*** 微型基准测试
CPU微信基准测试对一个简单操作进行多次测量计算操作时间。这些操作可能包括：
+ CPU指令: 整数运算、浮点运算、分支和其他指令
+ 内存访问: 调查不同CPU缓存的延时和主存吞吐量
+ 高级语言: 测量高级语言中不同指令的耗时
+ 操作系统: 测量调用操作系统各API所消耗的时间
** CPU性能分析工具
:PROPERTIES:
:interleave_page_note: 242
:END:

#+TABLE: CPU分析工具
| Linux        | Solaris | 描述                       |
|--------------+---------+----------------------------|
| uptime       | uptime  | 平均负载                   |
| vmstat       | vmstat  | 系统范围内的CPU平均负载    |
| mpstat       | mpstat  | 单个CPU统计信息            |
| sar          | sar     | 历史统计信息               |
| ps           | ps      | 进程状态                   |
| top          | prstat  | 监控每个进程/线程CPU使用量 |
| pidstat      | prstat  | 每个进程/线程CPU用量分解   |
| time         | ptime   | 计算命令执行耗时           |
| DTrace，perf | DTrace  | CPU剖析和跟踪              |
| perf         | cpustat | CPU性能计数器分析                |
*** uptime
#+BEGIN_SRC shell :results org
  uptime
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
 15:38:00 up 1 day,  5:57,  1 user,  load average: 0.39, 0.46, 0.44
#+END_SRC

最后三个数字是1、5、15分钟内的平均负载。通过比较这三个数字，可以判断负载的趋势。
这个值的意义在于，当平均负载大于CPU数量时表示CPU不足以服务线程，有些线程需要等待;如果平均负载小于CPU数量，则代表CPU还有一些余量。
*** vmstat
vmstat本是虚拟内存统计信息命令，但其最后几列输出了系统全局范围的CPU平均负载。
#+BEGIN_SRC shell :results org
  vmstat 1 5
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b 交换 空闲 缓冲 缓存   si   so    bi    bo   in   cs us sy id wa st
 0  0 2602512 109852  27496 342096    2    4    32    13   20   34  6  3 91  1  0
 0  0 2602512 109836  27496 342100    0    0     0     0  430 1169  1  2 97  0  0
 0  0 2602512 109836  27496 342100    0    0     0     0  455 1385  1  2 97  0  0
 0  0 2602512 109836  27496 342100    0    0     0     0  409 1207  1  1 98  0  0
 1  0 2602512 110088  27496 342100    0    0     0     0  517 1482  2  1 97  0  0
#+END_SRC

其中 *输出的第一行表示的是系统启动以来的总信息，其他行显示的才是当前值*

各列的意义如下:

+ r :: 等待运行的线程数。
+ us :: 用户态时间
+ sy :: 系统态时间
+ id :: 空闲时间
+ wa :: 线程被阻塞等待磁盘IO的CPU空闲时间
+ st :: CPU其他开销
*** mpstat
:PROPERTIES:
:interleave_page_note: 245
:END:
多处理器统计信息工具 =mpstat= 能够报告每个CPU的统计信息。

#+BEGIN_SRC shell :results org
  mpstat -P ALL 
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
Linux 4.20.3-arch1-1-ARCH (T520) 	2019年01月24日 	_x86_64_	(4 CPU)

15时56分56秒  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
15时56分56秒  all    3.68    2.33    1.99    0.56    0.32    0.23    0.00    0.00    0.00   90.91
15时56分56秒    0    3.59    2.73    2.07    0.47    0.29    0.25    0.00    0.00    0.00   90.61
15时56分56秒    1    3.71    2.61    1.88    0.41    0.22    0.20    0.00    0.00    0.00   90.97
15时56分56秒    2    3.65    2.04    2.17    0.49    0.34    0.23    0.00    0.00    0.00   91.08
15时56分56秒    3    3.76    1.93    1.83    0.86    0.43    0.23    0.00    0.00    0.00   90.96
#+END_SRC

这里 =-P ALL= 会输出每个CPU的报告，其输出列的说明如下:

+ CPU :: 逻辑CPU ID，all表示总结信息
+ %usr :: 用户态比率
+ %nice :: 以nice优先级运行的进程用户态比率
+ %sys :: 内核态比率
+ %iowait :: IO等待比率
+ %irq :: CPU处理硬件中断的比率
+ %soft :: CPU处理软件中断的比率
+ %steal :: 耗费在服务其他租户上的比率
+ %quest :: percentage of time spent in  involuntary  wait by  the  virtual  CPU  or CPUs while the hypervisor was servicing another virtual processor.
+ %idle :: the percentage of time spent by the CPU or CPUs to run a virtual processor
*** sar 
:PROPERTIES:
:interleave_page_note: 247
:END:

sar可以用来观察系统当前活动，以及归档报告历史统计信息。sar的用法为:
#+BEGIN_SRC shell :results org
  sar --help
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
用法: sar [ 选项 ] [ <时间间隔> [ <次数> ] ]
主要选项和报告（报告名以方括号分隔）：
	-B	分页状况 [A_PAGE]
	-b	I/O 和传输速率信息状况 [A_IO]
	-d	块设备状况 [A_DISK]
	-F [ MOUNT ]
		文件系统统计信息 [A_FS]
	-H	巨大页面利用率 [A_HUGE]
	-I { <中断列表> | SUM | ALL }
		中断信息状况 [A_IRQ]
	-m { <关键字> [,...] | ALL }
		电源管理统计信息 [A_PWR_...]
		关键字：
		CPU	CPU 瞬时时钟频率
		FAN	风扇速度
\t\tFREQ\tCPU 平均时钟频率
		IN	输入电压
		TEMP	设备温度
\t\tUSB\t连接的 USB 设备
	-n { <关键字> [,...] | ALL }
		网络统计信息 [A_NET_...]
		关键字：
		DEV	网络接口
		EDEV	网络接口（错误）
		NFS	NFS 客户端
		NFSD	NFS 服务端
		SOCK	Sockets	(v4)
		IP	IP 流	(v4)
		EIP	IP 流	(v4)（错误）
		ICMP	ICMP 流	(v4)
		EICMP	ICMP 流	(v4)（错误）
		TCP	TCP 流	(v4)
		ETCP	TCP 流	(v4) (错误)
		UDP	UDP 流	(v4)
		SOCK6	Sockets	(v6)
		IP6	IP 流	(v6)
		EIP6	IP 流	(v6)（错误）
		ICMP6	ICMP 流	(v6)
		EICMP6	ICMP 流	(v6) (错误)
		UDP6	UDP 流	(v6)
		FC	Fibre channel HBAs
		SOFT	基于软件的网络处理

	-q	队列长度和平均负载统计信息 [A_QUEUE]
	-r [ ALL ]
		内存利用率信息 [A_MEMORY]
	-S	交换空间利用率信息 [A_MEMORY]
	-u [ ALL ]
		CPU 利用率信息 [A_CPU]
	-v	内核表统计信息 [A_KTABLES]
	-W	交换信息 [A_SWAP]
	-w	任务创建与系统切换信息 [A_PCSW]
	-y	TTY 设备信息 [A_SERIAL]
#+END_SRC
*** ps
ps命令能够列出进程的细节信息，包括CPU使用率
#+BEGIN_SRC shell :results org
  ps aux |head
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.1  0.2 190100  7676 ?        Ss   15:47   0:03 /sbin/init
root         2  0.0  0.0      0     0 ?        S    15:47   0:00 [kthreadd]
root         3  0.0  0.0      0     0 ?        I<   15:47   0:00 [rcu_gp]
root         4  0.0  0.0      0     0 ?        I<   15:47   0:00 [rcu_par_gp]
root         6  0.0  0.0      0     0 ?        I<   15:47   0:00 [kworker/0:0H-kblockd]
root         8  0.0  0.0      0     0 ?        I<   15:47   0:00 [mm_percpu_wq]
root         9  0.0  0.0      0     0 ?        S    15:47   0:00 [ksoftirqd/0]
root        10  0.0  0.0      0     0 ?        I    15:47   0:00 [rcu_preempt]
root        11  0.0  0.0      0     0 ?        S    15:47   0:00 [rcuc/0]
#+END_SRC

其中 =TIME= 列显示了进程从创建开始消耗的CPU总时间(用户态+系统态),格式为"小时:分钟:秒"

=%CPU= 列显示了前一秒内所有CPU上的使用率之合，因此在多核系统上该值可能超过100%
*** top
使用top命令可以方便查看占用CPU使用率最高的几个进程。
但需要注意的是,由于 =top= 对 =/proc= 拍快照，它会错过一些寿命较短的进程。

top有一个变种:atop,其使用进程核算计算来捕获短寿命进程的存在，然后把这些进程加入显示。
*** pidstat
:PROPERTIES:
:interleave_page_note: 250
:END:

pidstat工具能够输出每个进程使用的CPU数量、CPU用户态和系统态的时间比，默认情况下只循环输出活动进程的信息:
#+BEGIN_SRC shell :results org
  pidstat 1 2
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
Linux 4.20.5-arch1-1-ARCH (T520) 	2019年01月30日 	_x86_64_	(4 CPU)

16时44分41秒   UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
16时44分42秒     0       422    0.00    0.98    0.00    0.00    0.98     2  irq/29-iwlwifi
16时44分42秒     0       971    0.00    0.98    0.00    0.00    0.98     2  dockerd
16时44分42秒     0       974    0.98    0.00    0.00    0.00    0.98     3  lxd
16时44分42秒     0      1021    0.98    0.00    0.00    0.00    0.98     0  containerd
16时44分42秒  1000      1561    0.00    0.98    0.00    0.00    0.98     2  Xorg
16时44分42秒  1000      2811    0.98    0.98    0.00    0.00    1.96     1  nutstore
16时44分42秒  1000      4351    1.96    0.00    0.00    0.00    1.96     2  firefox
16时44分42秒  1000      4798    0.98    0.98    0.00    0.00    1.96     0  Web Content
16时44分42秒  1000      4808    0.00    0.98    0.00    0.00    0.98     2  Web Content

16时44分42秒   UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
16时44分43秒     0      1021    0.00    1.00    0.00    0.00    1.00     0  containerd
16时44分43秒  1000      4499    1.00    0.00    0.00    0.00    1.00     2  Web Content
16时44分43秒  1000      4572    1.00    0.00    0.00    0.00    1.00     2  WebExtensions
16时44分43秒  1000      5776    0.00    2.00    0.00    0.00    2.00     1  pidstat

平均时间:   UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
平均时间:     0       422    0.00    0.50    0.00    0.00    0.50     -  irq/29-iwlwifi
平均时间:     0       971    0.00    0.50    0.00    0.00    0.50     -  dockerd
平均时间:     0       974    0.50    0.00    0.00    0.00    0.50     -  lxd
平均时间:     0      1021    0.50    0.50    0.00    0.00    0.99     -  containerd
平均时间:  1000      1561    0.00    0.50    0.00    0.00    0.50     -  Xorg
平均时间:  1000      2811    0.50    0.50    0.00    0.00    0.99     -  nutstore
平均时间:  1000      4351    0.99    0.00    0.00    0.00    0.99     -  firefox
平均时间:  1000      4499    0.50    0.00    0.00    0.50    0.50     -  Web Content
平均时间:  1000      4572    0.50    0.00    0.00    0.00    0.50     -  WebExtensions
平均时间:  1000      4798    0.50    0.50    0.00    0.00    0.99     -  Web Content
平均时间:  1000      4808    0.00    0.50    0.00    0.00    0.50     -  Web Content
平均时间:  1000      5776    0.00    0.99    0.00    0.00    0.99     -  pidstat
#+END_SRC

使用 =-p ALL= 能输出所有进程信息，而不仅仅是活动进程信息。

选项 =-t= 会输出每个线程的统计信息

#+BEGIN_SRC shell :results org
  pidstat -t 1 2
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
Linux 4.20.5-arch1-1-ARCH (T520) 	2019年01月30日 	_x86_64_	(4 CPU)

16时46分56秒   UID      TGID       TID    %usr %system  %guest   %wait    %CPU   CPU  Command
16时46分57秒     0       422         -    0.00    0.98    0.00    0.00    0.98     2  irq/29-iwlwifi
16时46分57秒     0         -       422    0.00    0.98    0.00    0.00    0.98     2  |__irq/29-iwlwifi
16时46分57秒     0         -      1040    0.00    0.98    0.00    0.00    0.98     1  |__dockerd
16时46分57秒     0       974         -    0.98    0.00    0.00    0.00    0.98     0  lxd
16时46分57秒     0         -       974    0.98    0.00    0.00    0.00    0.98     0  |__lxd
16时46分57秒     0         -      1003    0.98    0.00    0.00    0.00    0.98     3  |__lxd
16时46分57秒     0         -      1008    0.00    0.98    0.00    0.00    0.98     2  |__lxd
16时46分57秒  1000         -      1277    0.98    0.00    0.00    0.00    0.98     0  |__emacs
16时46分57秒  1000      1561         -    0.00    0.98    0.00    0.98    0.98     2  Xorg
16时46分57秒  1000         -      1561    0.00    0.98    0.00    0.98    0.98     2  |__Xorg
16时46分57秒  1000         -      2906    0.00    0.98    0.00    0.00    0.98     3  |__nutstore
16时46分57秒  1000      4351         -    1.96    0.00    0.00    0.00    1.96     0  firefox
16时46分57秒  1000         -      4351    0.98    0.00    0.00    0.00    0.98     0  |__firefox
16时46分57秒  1000         -      4356    0.00    0.98    0.00    0.00    0.98     0  |__Timer
16时46分57秒  1000         -      4397    0.98    0.00    0.00    0.00    0.98     1  |__Compositor
16时46分57秒  1000         -      4433    0.98    0.00    0.00    0.00    0.98     2  |__Web Content
16时46分57秒  1000      4499         -    0.98    0.00    0.00    0.98    0.98     2  Web Content
16时46分57秒  1000      4808         -    0.98    0.00    0.00    0.00    0.98     3  Web Content
16时46分57秒  1000         -      4828    0.00    0.98    0.00    0.00    0.98     0  |__Timer
16时46分57秒  1000      5856         -    1.96    0.98    0.00    0.00    2.94     1  pidstat
16时46分57秒  1000         -      5856    1.96    0.98    0.00    0.00    2.94     1  |__pidstat

16时46分57秒   UID      TGID       TID    %usr %system  %guest   %wait    %CPU   CPU  Command
16时46分58秒     0         -        20    0.00    1.00    0.00    0.00    1.00     1  |__rcuc/1
16时46分58秒     0         -        42    0.00    1.00    0.00    0.00    1.00     2  |__kworker/2:1-mm_percpu_wq
16时46分58秒     0       971         -    1.00    0.00    0.00    0.00    1.00     0  dockerd
16时46分58秒     0      1021         -    1.00    0.00    0.00    0.00    1.00     0  containerd
16时46分58秒  1000      1277         -    0.00    1.00    0.00    0.00    1.00     0  emacs
16时46分58秒  1000      4351         -    1.00    0.00    0.00    0.00    1.00     0  firefox
16时46分58秒  1000      4433         -    0.00    1.00    0.00    1.00    1.00     3  Web Content
16时46分58秒  1000         -      4433    0.00    1.00    0.00    1.00    1.00     3  |__Web Content
16时46分58秒  1000         -      4499    1.00    0.00    0.00    0.00    1.00     0  |__Web Content
16时46分58秒  1000         -      4502    1.00    0.00    0.00    0.00    1.00     0  |__JS Watchdog
16时46分58秒  1000         -      4572    0.00    1.00    0.00    0.00    1.00     2  |__WebExtensions
16时46分58秒  1000      4798         -    1.00    0.00    0.00    0.00    1.00     2  Web Content
16时46分58秒  1000         -      4798    1.00    0.00    0.00    0.00    1.00     2  |__Web Content
16时46分58秒  1000      4808         -    0.00    1.00    0.00    0.00    1.00     2  Web Content
16时46分58秒  1000         -      4808    1.00    1.00    0.00    0.00    2.00     2  |__Web Content
16时46分58秒  1000      5856         -    1.00    2.00    0.00    0.00    3.00     1  pidstat
16时46分58秒  1000         -      5856    1.00    2.00    0.00    0.00    3.00     1  |__pidstat

平均时间:   UID      TGID       TID    %usr %system  %guest   %wait    %CPU   CPU  Command
平均时间:     0         -        20    0.00    0.50    0.00    0.00    0.50     -  |__rcuc/1
平均时间:     0         -        42    0.00    0.50    0.00    0.00    0.50     -  |__kworker/2:1-mm_percpu_wq
平均时间:     0       422         -    0.00    0.50    0.00    0.00    0.50     -  irq/29-iwlwifi
平均时间:     0         -       422    0.00    0.50    0.00    0.00    0.50     -  |__irq/29-iwlwifi
平均时间:     0       971         -    0.50    0.00    0.00    0.00    0.50     -  dockerd
平均时间:     0         -      1040    0.00    0.50    0.00    0.00    0.50     -  |__dockerd
平均时间:     0       974         -    0.50    0.00    0.00    0.00    0.50     -  lxd
平均时间:     0         -       974    0.50    0.00    0.00    0.00    0.50     -  |__lxd
平均时间:     0         -      1003    0.50    0.00    0.00    0.00    0.50     -  |__lxd
平均时间:     0         -      1008    0.00    0.50    0.00    0.00    0.50     -  |__lxd
平均时间:     0      1021         -    0.50    0.00    0.00    0.00    0.50     -  containerd
平均时间:  1000      1277         -    0.00    0.50    0.00    0.00    0.50     -  emacs
平均时间:  1000         -      1277    0.50    0.00    0.00    0.00    0.50     -  |__emacs
平均时间:  1000      1561         -    0.00    0.50    0.00    0.50    0.50     -  Xorg
平均时间:  1000         -      1561    0.00    0.50    0.00    0.50    0.50     -  |__Xorg
平均时间:  1000         -      2906    0.00    0.50    0.00    0.00    0.50     -  |__nutstore
平均时间:  1000      4351         -    1.49    0.00    0.00    0.00    1.49     -  firefox
平均时间:  1000         -      4351    0.50    0.00    0.00    0.00    0.50     -  |__firefox
平均时间:  1000         -      4356    0.00    0.50    0.00    0.00    0.50     -  |__Timer
平均时间:  1000         -      4397    0.50    0.00    0.00    0.00    0.50     -  |__Compositor
平均时间:  1000      4433         -    0.00    0.50    0.00    0.50    0.50     -  Web Content
平均时间:  1000         -      4433    0.50    0.50    0.00    0.50    0.99     -  |__Web Content
平均时间:  1000      4499         -    0.50    0.00    0.00    0.50    0.50     -  Web Content
平均时间:  1000         -      4499    0.50    0.00    0.00    0.50    0.50     -  |__Web Content
平均时间:  1000         -      4502    0.50    0.00    0.00    0.00    0.50     -  |__JS Watchdog
平均时间:  1000         -      4572    0.00    0.50    0.00    0.00    0.50     -  |__WebExtensions
平均时间:  1000      4798         -    0.50    0.00    0.00    0.00    0.50     -  Web Content
平均时间:  1000         -      4798    0.50    0.00    0.00    0.00    0.50     -  |__Web Content
平均时间:  1000      4808         -    0.50    0.50    0.00    0.00    0.99     -  Web Content
平均时间:  1000         -      4808    0.50    0.50    0.00    0.00    0.99     -  |__Web Content
平均时间:  1000         -      4828    0.00    0.50    0.00    0.00    0.50     -  |__Timer
平均时间:  1000      5856         -    1.49    1.49    0.00    0.00    2.97     -  pidstat
平均时间:  1000         -      5856    1.49    1.49    0.00    0.00    2.97     -  |__pidstat
#+END_SRC
*** time
:PROPERTIES:
:interleave_page_note: 252
:END:

time用来运行命令，并报告CPU用量:
#+BEGIN_EXAMPLE
  [lujun9972@T520 wowebook]$ time sleep 1

  real	0m1.007s
  user	0m0.004s
  sys	0m0.000s
#+END_EXAMPLE

其中 =real= 表示运行该命令运行完的实际等待时间是 =1.007s=
其中 =0.004s= 花在用户态上， =0.000s= 花在系统态上，还有 =1.003s= 的时间CPU被阻塞。
*** perf 
:PROPERTIES:
:interleave_page_note: 259
:END:
perf是一整套剖析和跟踪的工具，它有多个子命令，每个子命令都是一个工具。

#+TABLE: perf子命令

| 命令      | 描述                                                 |
|-----------+------------------------------------------------------|
| annotate  | 读取perf.data（由perf record创建）并显示注释过的代码 |
| diff      | 读取两个perf.data文件并显示两份剖析信息之间的差异    |
| evlist    | 列出一个perf.data文件里的事件名称                    |
| inject    | 过滤以加强事件流，在其中加入额外信息                 |
| kmem      | 跟踪/测量kvm客户机操作系统的工具                     |
| list      | 列出所有的符号事件类型                               |
| lock      | 分析锁事件                                           |
| probe     | 定义新的动态跟踪点                                   |
| record    | 运行一个命令，并把剖析信息记录在perf.data中          |
| report    | 读取perf.data并显示剖析信息                          |
| sched     | 跟踪/测量调度器属性（延时）的工具                    |
| script    | 读取perf.data并显示跟踪输出                          |
| stat      | 运行一个命令并收集性能计数器统计信息                 |
| timechart | 可视化某一个负载期间系统总体性能的工具               |
| top       | 系统剖析工具                                               |
**** 系统剖析
perf可以用来剖析CPU调用路径，对CPU时间如何消耗在内核和用户空间进行概括总结。
这项工作由record命令完成，该命令以一定间隔进行取样，并导出到一个perf.data文件中，然后使用report命令查看文件。

下面例子中，所有CPU(-a)以997Hz的频率(-F 997)对调用栈(-g)取样10s(sleep 10)
#+BEGIN_SRC shell :dir /sudo::/tmp :results org
  sudo perf record -a -g -F 997 sleep 10
#+END_SRC

然后使用report命令来讲结果输出到标准输入(--stdio)
#+BEGIN_SRC shell :dir /sudo::/tmp :results org
  sudo perf report --stdio |head -n 20
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
# To display the perf.data header info, please use --header/--header-only options.
#
#
# Total Lost Samples: 0
#
# Samples: 8K of event 'cycles:ppp'
# Event count (approx.): 3391285697
#
# Children      Self  Command          Shared Object               Symbol                                                                                                                           
# ........  ........  ...............  ..........................  .................................................................................................................................
#
    52.70%     0.00%  swapper          [kernel.kallsyms]           [k] secondary_startup_64
            |
            ---secondary_startup_64
               |          
               |--39.07%--start_secondary
               |          cpu_startup_entry
               |          |          
               |           --39.06%--do_idle
               |                     |          
#+END_SRC
**** 进程剖析
:PROPERTIES:
:interleave_page_note: 261
:END:
除了剖析系统中所有CPU外，我们也可以对单个进程进行剖析。

下面命令执行了command并创建文件perf.data
#+BEGIN_SRC shell
  sudo perf record -g command
#+END_SRC
**** 调度器延时
sched命令记录并报告调度器统计信息，例如:
#+BEGIN_SRC shell :dir /sudo::/tmp :results org
  sudo perf sched record sleep 5
  sudo perf sched latency|cat
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org

 -----------------------------------------------------------------------------------------------------------------
  Task                  |   Runtime ms  | Switches | Average delay ms | Maximum delay ms | Maximum delay at       |
 -----------------------------------------------------------------------------------------------------------------
  jbd2/sda2-8:256       |      1.236 ms |        9 | avg:    0.096 ms | max:    0.148 ms | max at:  12660.605688 s
  khugepaged:48         |      0.000 ms |        1 | avg:    0.092 ms | max:    0.092 ms | max at:  12661.015205 s
  ksoftirqd/1:21        |      0.026 ms |        1 | avg:    0.067 ms | max:    0.067 ms | max at:  12659.170227 s
  perf:18804            |      3.165 ms |        1 | avg:    0.066 ms | max:    0.066 ms | max at:  12663.046480 s
  emacsclient:18806     |      5.941 ms |        1 | avg:    0.062 ms | max:    0.062 ms | max at:  12659.148839 s
  WebExtensions:2668    |     16.179 ms |       33 | avg:    0.060 ms | max:    0.091 ms | max at:  12659.782529 s
  rtkit-daemon:(2)      |      0.086 ms |        2 | avg:    0.052 ms | max:    0.076 ms | max at:  12660.462113 s
  iprt-VBoxTscThr:297   |      0.002 ms |        1 | avg:    0.052 ms | max:    0.052 ms | max at:  12659.948431 s
  kworker/3:1H-kb:249   |      0.000 ms |        1 | avg:    0.052 ms | max:    0.052 ms | max at:  12660.588465 s
  usb-storage:17140     |      0.419 ms |        6 | avg:    0.049 ms | max:    0.066 ms | max at:  12660.161970 s
  Web Content:(4)       |    111.227 ms |      204 | avg:    0.048 ms | max:    0.166 ms | max at:  12658.753336 s
  kworker/2:2-eve:233   |      0.118 ms |        8 | avg:    0.047 ms | max:    0.071 ms | max at:  12658.668522 s
  kworker/1:1-eve:56    |      0.177 ms |       13 | avg:    0.047 ms | max:    0.087 ms | max at:  12662.081861 s
  Chrome_~dThread:(5)   |      1.938 ms |        9 | avg:    0.046 ms | max:    0.062 ms | max at:  12658.343273 s
  rcu_preempt:10        |      0.000 ms |       69 | avg:    0.045 ms | max:    0.078 ms | max at:  12659.165194 s
  kworker/u16:0-e:17977 |      6.500 ms |      130 | avg:    0.045 ms | max:    0.090 ms | max at:  12659.039050 s
  kworker/3:2-eve:14850 |      0.319 ms |        8 | avg:    0.044 ms | max:    0.066 ms | max at:  12659.948456 s
  kworker/0:2-eve:213   |      0.580 ms |       14 | avg:    0.043 ms | max:    0.103 ms | max at:  12661.628560 s
  ksoftirqd/3:35        |      0.082 ms |        4 | avg:    0.042 ms | max:    0.053 ms | max at:  12662.262789 s
  Compositor:2551       |    505.629 ms |      362 | avg:    0.039 ms | max:    0.189 ms | max at:  12661.088443 s
  firefox:2503          |     86.426 ms |      335 | avg:    0.036 ms | max:    0.137 ms | max at:  12662.305606 s
  xscreensaver:1838     |      0.388 ms |        2 | avg:    0.036 ms | max:    0.048 ms | max at:  12658.784807 s
  emacs:1272            |      1.411 ms |        5 | avg:    0.035 ms | max:    0.053 ms | max at:  12660.777312 s
  kworker/u17:2-r:884   |      0.337 ms |        7 | avg:    0.034 ms | max:    0.062 ms | max at:  12661.802490 s
  migration/3:33        |      0.000 ms |        1 | avg:    0.033 ms | max:    0.033 ms | max at:  12660.454733 s
  Xorg:1556             |     60.852 ms |      311 | avg:    0.033 ms | max:    0.110 ms | max at:  12660.955077 s
  migration/1:19        |      0.000 ms |        1 | avg:    0.029 ms | max:    0.029 ms | max at:  12660.454706 s
  Gecko_IOThread:2508   |      1.302 ms |        9 | avg:    0.028 ms | max:    0.078 ms | max at:  12662.108214 s
  SCTP timer:(2)        |     49.491 ms |      985 | avg:    0.028 ms | max:    0.140 ms | max at:  12658.732885 s
  migration/2:26        |      0.000 ms |        1 | avg:    0.027 ms | max:    0.027 ms | max at:  12660.454727 s
  dockerd:(9)           |     19.911 ms |      298 | avg:    0.027 ms | max:    0.519 ms | max at:  12658.598484 s
  ksoftirqd/2:28        |      0.403 ms |       18 | avg:    0.026 ms | max:    0.053 ms | max at:  12658.753252 s
  Timer:(6)             |     59.257 ms |      662 | avg:    0.026 ms | max:    0.879 ms | max at:  12659.738562 s
  JS Watchdog:(6)       |      1.453 ms |       28 | avg:    0.025 ms | max:    0.091 ms | max at:  12661.606624 s
  journal-offline:(2)   |      1.514 ms |       13 | avg:    0.025 ms | max:    0.115 ms | max at:  12660.602353 s
  InotifyEventThr:5445  |      2.367 ms |       50 | avg:    0.025 ms | max:    0.062 ms | max at:  12658.058499 s
  nutstore:(9)          |     18.590 ms |      217 | avg:    0.024 ms | max:    0.084 ms | max at:  12662.158416 s
  lxd:(9)               |     40.865 ms |      522 | avg:    0.024 ms | max:    1.477 ms | max at:  12660.742444 s
  Softwar~cThread:2550  |     33.328 ms |      302 | avg:    0.024 ms | max:    0.066 ms | max at:  12659.504224 s
  jbd2/sda3-8:439       |      0.391 ms |        3 | avg:    0.024 ms | max:    0.035 ms | max at:  12661.658040 s
  ksoftirqd/0:9         |      0.142 ms |        8 | avg:    0.024 ms | max:    0.056 ms | max at:  12660.721098 s
  systemd-journal:282   |      0.391 ms |        1 | avg:    0.023 ms | max:    0.023 ms | max at:  12660.590444 s
  containerd:(9)        |     16.213 ms |      232 | avg:    0.023 ms | max:    0.363 ms | max at:  12660.103693 s
  irq/29-iwlwifi:454    |      0.000 ms |      225 | avg:    0.022 ms | max:    0.090 ms | max at:  12661.498451 s
  kworker/u16:1-e:17055 |      0.666 ms |       18 | avg:    0.022 ms | max:    0.067 ms | max at:  12661.628603 s
  migration/0:13        |      0.000 ms |        1 | avg:    0.020 ms | max:    0.020 ms | max at:  12660.454696 s
  kworker/0:1H-ev:243   |      0.104 ms |        2 | avg:    0.018 ms | max:    0.024 ms | max at:  12659.524745 s
  sleep:18805           |      1.399 ms |        2 | avg:    0.017 ms | max:    0.031 ms | max at:  12663.045993 s
  rcuc/1:20             |      0.000 ms |        1 | avg:    0.016 ms | max:    0.016 ms | max at:  12659.170273 s
  rcuc/0:11             |      0.000 ms |        5 | avg:    0.016 ms | max:    0.029 ms | max at:  12662.235134 s
  rcuc/2:27             |      0.000 ms |       17 | avg:    0.016 ms | max:    0.028 ms | max at:  12660.901805 s
  awesome:1830          |     12.056 ms |        6 | avg:    0.012 ms | max:    0.017 ms | max at:  12659.143990 s
  kworker/1:1H-kb:255   |      0.114 ms |        4 | avg:    0.012 ms | max:    0.031 ms | max at:  12659.735099 s
  kworker/2:1H-kb:234   |      0.236 ms |       12 | avg:    0.012 ms | max:    0.037 ms | max at:  12660.600666 s
  rcuc/3:34             |      0.000 ms |        4 | avg:    0.011 ms | max:    0.014 ms | max at:  12658.081183 s
  redshift:1837         |      0.646 ms |        3 | avg:    0.009 ms | max:    0.011 ms | max at:  12659.524992 s
 -----------------------------------------------------------------------------------------------------------------
  TOTAL:                |   1063.877 ms |     5188 |
 ---------------------------------------------------

#+END_SRC

上面显示了跟踪时期平均和最大的调度器延时
**** stat
stat命令基于CPC为CPU周期行为提供了一个概要总结

sched命令记录并报告调度器统计信息，例如:
#+BEGIN_SRC shell :dir /sudo::/tmp :results org
  sudo perf stat sleep 1 2>&1
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org

 Performance counter stats for 'sleep 1':

              1.38 msec task-clock                #    0.001 CPUs utilized          
                 1      context-switches          # 1000.000 M/sec                  
                 0      cpu-migrations            #    0.000 K/sec                  
                66      page-faults               # 66000.000 M/sec                 
         1,429,995      cycles                    # 1429995.000 GHz                 
           976,043      stalled-cycles-frontend   # [31m  68.25%[m frontend cycles idle   
           758,074      stalled-cycles-backend    # [35m  53.01%[m backend cycles idle    
           971,478      instructions              #    0.68  insn per cycle         
                                                  #    1.00  stalled cycles per insn
           197,852      branches                  # 197852000.000 M/sec             
             9,409      branch-misses             #    4.76% of all branches        

       1.002253564 seconds time elapsed

       0.002061000 seconds user
       0.000000000 seconds sys


#+END_SRC

统计信息中包括了上下文切换次数、周期书和指令计数等信息。

使用 =list= 子命令可以列出其他可以检查的计数器
#+BEGIN_SRC shell :results org
  perf list |head
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
  branch-instructions OR branches                    [Hardware event]
  branch-misses                                      [Hardware event]
  bus-cycles                                         [Hardware event]
  cache-misses                                       [Hardware event]
  cache-references                                   [Hardware event]
  cpu-cycles OR cycles                               [Hardware event]
  instructions                                       [Hardware event]
  ref-cycles                                         [Hardware event]
  stalled-cycles-backend OR idle-cycles-backend      [Hardware event]
  stalled-cycles-frontend OR idle-cycles-frontend    [Hardware event]
#+END_SRC

注意那些 =Hardware event= 和 =Hardware cache event= 是否可用取决于处理器架构

这些事件可以使用选项 =-e= 来指定，例如:
#+BEGIN_SRC shell :dir /sudo::/tmp :results org
  sudo perf stat -e instructions,cycles,L1-dcache-load-misses,branch-misses sleep 1 2>&1
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org

 Performance counter stats for 'sleep 1':

           947,672      instructions              #    0.71  insn per cycle                                            
         1,336,684      cycles                                                      
            16,242      L1-dcache-load-misses                                       
             9,272      branch-misses                                               

       1.001847125 seconds time elapsed

       0.001674000 seconds user
       0.000000000 seconds sys


#+END_SRC
**** 软件跟踪
=perf record -e= 可以与各种软件性能探测点配合，用来跟踪内核调度器的活动。
这些测量点包括了软件事件和跟踪点事件(静态探测器),这些测量点可以通过 =perf list= 列出
#+BEGIN_SRC shell :results org
  perf list |grep -i "Software\|Tracepoint"
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
  alignment-faults                                   [Software event]
  bpf-output                                         [Software event]
  context-switches OR cs                             [Software event]
  cpu-clock                                          [Software event]
  cpu-migrations OR migrations                       [Software event]
  dummy                                              [Software event]
  emulation-faults                                   [Software event]
  major-faults                                       [Software event]
  minor-faults                                       [Software event]
  page-faults OR faults                              [Software event]
  task-clock                                         [Software event]
       [Not software-prefetch load dispatches that hit FB allocated for
       [Not software-prefetch load dispatches that hit FB allocated for
        software prefetch]
#+END_SRC

#+BEGIN_SRC shell :dir /sudo::/tmp :results org
  sudo perf record -a -g -e context-switches sleep 1
  sudo perf report --stdio |cat
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
# To display the perf.data header info, please use --header/--header-only options.
#
#
# Total Lost Samples: 0
#
# Samples: 1  of event 'context-switches'
# Event count (approx.): 1
#
# Children      Self  Command  Shared Object      Symbol                         
# ........  ........  .......  .................  ...............................
#
   100.00%   100.00%  sleep    [kernel.kallsyms]  [k] schedule
            |
            ---__nanosleep
               _raw_spin_unlock_irqrestore
               schedule

   100.00%     0.00%  sleep    libc-2.28.so       [.] __nanosleep
            |
            ---__nanosleep
               _raw_spin_unlock_irqrestore
               schedule

   100.00%     0.00%  sleep    [kernel.kallsyms]  [k] _raw_spin_unlock_irqrestore
            |
            ---_raw_spin_unlock_irqrestore
               schedule



#
# (Tip: Skip collecting build-id when recording: perf record -B)
#
#+END_SRC
**** 其他工具

+ oprofile :: 最初的CPU剖析工具
+ htop :: 包括了CPU用量的ASCII柱状图，比最初的top有更强大的交互模式
+ atop :: 包括了更多的系统级统计信息，使用进程核算统计能够捕捉短命进程的存在
+ /proc/cpuinfo :: 可以获得处理器详细信息，包括时钟频率和特征标志位
+ valgrind :: 一个内存调试和剖析工具组。它包括了callgrind,一个跟踪函数调用并生成调用图的工具，可以通过kcachegrind可视化
*** 可视化
:PROPERTIES:
:interleave_page_note: 266
:END:

**** 折线图

**** 使用率热图
使用率与时间的相对关系可以展示成一张热图，每个像素的饱和度代表有多少个CPU在这个时间范围内时这个使用率

**** 亚秒偏移量热图
CPU活动一般以微秒/毫秒为度量单位，报告一秒内品均值会列出很多有用信息。

该类热图每列表示一秒内CPU的变动情况，通过在Y轴上放置亚秒偏移量，每个偏移量上通过像素饱和度来显示非空闲CPU。

**** 火焰图
火焰图可视化了栈帧的剖析信息，可以清楚地理解CPU消耗在哪个代码路径，它具有如下特点:

+ 每个框代表栈里的一个函数
+ Y轴表示栈的深度,顶部的框表示在CPU上执行的函数。下面的是它的父函数及其各级祖先调用者,表示栈回溯
+ X轴横跨整个取样数据，但它没有任何意义，而不是表示时间流逝
+ 框的宽度表示函数在CPU上运行，或是它的上级函数在CPU上运行的时间。更宽的函数框可能比窄框函数慢，也可能时因为调用频繁
+ 如果是多线程运行，而且抽样时并发的情况，抽样计数可能会超过总时间。

** 调优
:PROPERTIES:
:interleave_page_note: 271
:END:

*** 编译器优化项

*** 调度优先级与调度类
nice命令可以用来调整进程优先级。正nice值调低优先级，负nice值调高优先级,范围为-20到19
#+BEGIN_SRC shell
  nice -n 19 command
#+END_SRC

使用renice命令则可以更改一个正在运行进程的优先级
#+BEGIN_SRC shell
  sudo renice -n -10 $$
#+END_SRC

Linux上的chrt命令可以显示并直接设置优先级和调度策略。
调度优先级也可以通过 =setpriority()= 系统调用来设置，而优先级和调度策略可以通过 =sched_setscheduler()= 来设置。

*** 调度器选项
内核一般都允许对调度器进行配置，在Linux上可以设置下面选项

| 选项                     | 描述                            | 默认值 |
|--------------------------+---------------------------------+--------|
| CONFIG_CGROUP_SCHED      | 允许任务编组，以组为单位分配CPU | y      |
| CONFIG_FAIR_GROUP_SCHED  | 允许编组CFS任务                 | y      |
| CONFIG_RT_GROUP_SCHED    | 允许编组实时任务                | y      |
| CONFIG_SCHED_AUTOGROUP   | 自动识别并构建任务组            | y      |
| CONFIG_SCHED_SMT         | 超线程支持                      | y      |
| CONFIG_SCHED_MC          | 多核支持                        | y      |
| CONFIG_HZ                | 设置内核时钟频率(时钟中断)      | 1000   |
| CONFIG_NO_HZ             | 无tick内核行为                  | y      |
| CONFIG_SCHED_HRTICK      | 使用高精度定时器                | y      |
| CONFIG_PREEMPT           | 全内核抢占(除了自旋锁和中断)    | n      |
| CONFIG_PREEMPT_NONE      | 无抢占                          | n      |
| CONFIG_PREEMPT_VOLUNTARY | 在自愿内核代码点进行抢占        | y      |

其他可调参数可以在 =/proc/sys/kernel/sched*= 中看到


*** 进程绑定
一个进程可以绑定在一个或多个CPU上，这样可以通过提高CPU缓存命中率和内存本地性来提高性能。

在Linux上，通过taskset来进行进程绑定,例如下面命令限定emacs只能在2-3号(从0开始计数)CPU上跑
#+BEGIN_SRC shell :results org
  taskset -pc 2-3 $(pidof emacs)
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
pid 1261 的当前亲和力列表：0-3
pid 1261 的新亲和力列表：2,3
#+END_SRC

*** 独占CPU组
Linux提供了CPU组，允许对CPU编组并为其分配进程。
这跟进程绑定类似，可以提高性能，但它还能起到CPU组独占的作用。

下面命令可以创建一个独占组
#+BEGIN_SRC shell
  mkdir /dev/cpuset
  mount -t cpuset cpuset /dev/cpuset
  cd /dev/cpuset
  mkdir prodset                   # 创建一个名为prodset的CPU组
  echo 2-3 > cpus                 # 分配
  echo 1 > cpu_exclusive          # 设置prodset CPU组的排它性，这样它就不会再分配CPU给其他进程
  echo 1159 > tasks               # 分配PID 1159 到 prodset
#+END_SRC

详细信息参见 =man cpuset=

*** 资源控制
Linux通过cgroups可以对进程和进程组控制资源用量。

*** 处理器选项(BIOS调优)

BIOS上可以通过一些设置来启用、禁用和调优处理器级别的特征。

* 内存
:PROPERTIES:
:interleave_page_note: 278
:END:

内存影响系统性能的因素主要包括：

+ 由于内存耗尽引起的内存与磁盘交换数据
+ 分配和释放内存的CPU开销
+ 复制内存的CPU开销
+ 管理内存地址空间映射的CPU开销
+ 内存本地性


** 文件系统换页与匿名换页
*** 文件系统换页
文件系统换页由读写位于内存中的映射文件(mmap())页所引发，这是很正常的行为不会拖慢系统性能。

若文件系统页在内存中被修改过，则页面换出的同时要求将改页写会磁盘。否则只需要释放该页内存即可。
*** 匿名换页
匿名换页将进程堆和栈的私有数据迁移到物理交换设备或交换文件，这种换页会拖慢性能。

当应用程序访问被调出的页时，会被读页的磁盘IO阻塞。但匿名页面换出时可能并不会直接影响应用程序性能，因为它是由内核异步执行的。
** 分配器
:PROPERTIES:
:interleave_page_note: 296
:END:
虚拟内存空间中通常由分配器来进行实际内存分配，用户态库或者内核程序向程序员提供简单的内存使用接口(malloc,free等)

分配器对性能有显著影响，一个程序通常会提供多个可选择的用户态分配器库。
分配器可以利用线程对象缓存等技术来提高性能，但也会由于分配碎片化而损害性能。

内存分配器一般有如下特征:

+ 提供便于使用的API: 如何malloc和free操作
+ 高效的内存使用: 分配器会尽可能合并未使用的内存区域，减少碎片化
+ 性能: 内存分配很频繁，而且在多线程环境里可能会由于竞争同步而导致性能太差。因此分配器的实现尽可能不使用锁，并且利用线程级或CPU级的缓存来提高内存本地性。
+ 可观测性: 分配可能会提供统计数据和拍错模式以显示如何被调用，以及调用分配的代码路径

常见的分配器有:

+ 内核级分配器: slab分配器以及SLUB分配器
+ 用户级分配器: libmalloc,libumem,mtmalloc
** 主存架构
:PROPERTIES:
:interleave_page_note: 285
:END:
*** UMA(均匀访问模型)
[[file:./images/screenshot-04.png]]
通过共享系统总线，每个CPU访问所有内存都有均匀的访存延时,该架构又称为SMP(对称多处理器架构)

*** NUMA(非均匀访问模型)
[[file:./images/screenshot-05.png]]
这种架构中，对内存的访问时间随着CPU的位置不同而变化。

CPU1可以通过它的内存总线直接对DRAM A发起IO操作，这被称为本地内存。

CPU1听过CPU2以及CPU互联(2跳)对DRAM B发起IO操作，这被称为远程内存，访问延时更高。

*** CPU与内存之间总线连接方式
+ 共享系统总线: 正如UMA架构所示，多个处理器通过一个共享系统总线、一个内存桥控制器访问内存。
+ 直连: 单个处理器通过内存总线直接连接内存
+ 互联: 如NUMA所示，每个处理器通过一个内存总线与各自的内存直连，处理器之间则通过CPU互联来连接。

** 内存优化和调优的方法
:PROPERTIES:
:interleave_page_note: 298
:END:
*** 应用工具
应用工具可以检查下面指标:
+ 页扫描 :: 使用 =sar -B= 并检查pgscan列可以寻找过长时间的页扫描(超过10秒),这是内存压力的预兆
+ 换页 :: 使用 =vmstat= 并检查 =si= 和 =so= 列可以发现内存是否发生换页，换页是系统内存低的进一步征兆
+ 可用内存变化情况 :: 每秒运行vmstat检查free列的变化情况
+ OOM :: 在 =/var/log/message= 日志或 =dmesg= 中搜索 "Out of memory"
+ 查看哪些进程或用户占用了最多的物理内存和虚拟内存 :: top/prstat
+ 跟踪内存分配的栈,确认内存使用原因 :: dtrace/stap/perf
*** USE方法
USE方法可以用来定位瓶颈和所有组件的错误。它检查系统的如下指标:

+ 使用率 :: 多少内存被使用、多少内存仍可用。物理内存和虚拟内存都需要检查
+ 饱和度 :: 衡量内存压力，页扫描、换页、交换和OOM出现的频率
+ 错误 :: 失败的内存分配

之所以要检查虚拟内存的使用率，其实跟系统是否支持过度提交有关。
对于哪些不支持过度提交系统，一旦虚拟内存耗尽，内存分配就会失败。
*** 内存信息的基准特征统计
+ 系统的物理和虚拟内存使用率
+ 内存饱和度分析:换页、交换、触发OOM Killer的频率
+ 内核和文件系统缓存使用情况
+ 每个进程的物理和虚拟内存使用情况
+ 是否存在内存资源控制

为了更细致地理解内存使用特征，还可以了解下面这些信息:
+ 内核内存用于何处？每个slab用于何处？
+ 文件系统缓存中活跃与不活跃的比例是多少
+ 进程内存用于何处
+ 进程为何分配内存,调用路径是什么
+ 内核为何分配内存，调用路径是什么
+ 哪些进程持续地出现页面换出/交换
+ 哪些进程曾经被页面换出/交换
+ 进程或内核是否有内存泄露
+ NUMA系统中，内存是否合理分配到合适的结点中去
+ CPU和内存的停滞周期频率是多少
+ 相对于远程内存IO，执行了多少本地内存IO
*** 静态配置检查
:PROPERTIES:
:interleave_page_note: 302
:END:

对于内存性能，可以从下面几个方面进行静态配置检查:

+ 内存有多少
+ 配置了应用程序允许使用多少内存，比如JVM
+ 应用程序使用哪个分配器
+ 内存的速度是多少？
+ 系统架构是NUMA还是UMA？
+ 操作系统支持NUMA吗？
+ 有多少内存总线？
+ CPU缓存的数量和大小是多少？
+ 是否配置了使用大页面
+ 操作系统是否支持过度提交，是否允许过度提交
+ 是否通过cgroup等操作限制了软件的内存使用量？
+ 是否使用了其他的内存可调参数？
** 内存分析工具说明:

#+NAME: 内存分析工具
| Linux   | Solaris   | 描述                   |
|---------+-----------+------------------------|
| vmstat  | vmstat    | 虚拟和物理内存统计信息 |
| sar     | sar       | 历史统计信息           |
| slabtop | ::kmastat | 内核块分配统计信息     |
| ps      | ps        | 进程状态               |
| top     | prstat    | 监控每个进程内存使用率 |
| pmap    | pmap      | 进程地址空间统计信息   |
| DTrace  | DTrace    | 内存分配跟踪           |

*** vmstat

vmstat是虚拟内存统计信息命令，它提供包括当前内存和换页在内的内存健康程度总览.

#+BEGIN_SRC shell :results org
  vmstat 1 5
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b 交换 空闲 缓冲 缓存   si   so    bi    bo   in   cs us sy id wa st
 0  0 690432 142620  20104 477696    0    1    70    31   82  562  7  5 88  0  0
 0  0 690432 151440  20104 477812    0    0     0     0 3567 10524  2  3 95  0  0
 0  0 690432 150172  20104 477812    0    0     0     0 3436 10289  3  3 94  0  0
 0  0 690432 158300  20104 477748    0    0     0     0 3568 10502  2  3 94  0  0
 0  0 690432 151000  20104 477748    0    0    72     0 3401 9870  4  3 94  0  0
#+END_SRC

数据列的单位为KB:
+ swap(交换) :: 交换出的内存量
+ free(空闲) :: 空闲的可用内存
+ buffer(缓冲) :: 用于缓冲的内存
+ cache(缓存) :: 用于页缓存的内存
+ si(swap in) :: 正在换页换入的内存
+ so(swap out) :: 正在换页换出的内存

如果si和so列一直非0，那么说明系统正在承受内存压力，并且在换页到交换设备或文件中

现在系统的内存量一般比较大，使用KB走位内存很容易导致数据列不齐，可以通过 =-S= 选项修改输出单位
#+BEGIN_SRC shell :results org
  vmstat -Sm 1 5
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b 交换 空闲 缓冲 缓存   si   so    bi    bo   in   cs us sy id wa st
 1  0    708    111     18    470    0    0    68    31  109  644  6  5 88  0  0
 0  0    708    111     18    470    0    0     0    24 3037 10015  3  4 92  0  0
 0  0    726    131     17    447    0    0     0   148 2939 9759  5  7 89  0  0
 0  0    726    131     17    447    0    0    52     0 2886 10025  2  4 93  0  0
 0  0    726    132     17    447    0    0     0    36 2506 8793  2  4 94  0  0
#+END_SRC

选项 =-a= 可以输出非活动和活动页缓存的明细:
#+BEGIN_SRC shell :results org
  vmstat -a -Sm 1 5
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b 交换 空闲 不活动 活动   si   so    bi    bo   in   cs us sy id wa st
 0  0    737    154    880   2278    0    0    68    31  114  660  6  5 88  0  0
 0  0    737    164    880   2269    0    0     0     0 3583 10575  4  4 92  0  0
 0  0    737    155    880   2278    0    0    16     0 3199 10180  6  5 89  0  0
 3  0    737    147    880   2287    0    0     0     0 2790 9758  4  4 92  0  0
 1  0    737    147    880   2286    0    0    60     0 3066 10443  3  5 92  0  0
#+END_SRC

vmstat 还支持使用 =-s= 获取内存统计信息， =-d= 和 =-D= 获取磁盘统计信息，使用 =-p= 获取分区统计信息


*** sar
:PROPERTIES:
:interleave_page_note: 306
:END:

sar可以用来观测当前活动并且能配置保存和报告历史统计数据。

Linux版本的sar支持如下选项提供内存统计信息:

**** -B :: 换页统计信息
| 统计信息  | 描述                                     | 单位    |
|-----------+------------------------------------------+---------|
| pgpgin/s  | 页面换入                                 | KB/s    |
| pgpgout/s | 页面换出                                 | KB/s    |
| fault/s   | 换页                                     | 次数/s  |
| pgfree/s  | 页面加入空闲链表                         | 次数/s  |
| pgscank/s | 被后台页面换出守护进程(kswapd)扫描过页面 | 次数/s  |
| pgscand/s | 直接页面扫描                             | 次数/s  |
| pgsteal/s | 页面及交换高速缓存回收                   | 次数/s  |
| %vmeff    | pgsteal/页面扫描比率，显示页面回收的效率 | 次数/秒 |

%vmeff 是衡量页面回收效率的一个有趣指标，高数值意味着成功地从非活动列表中回收页(健康)
低数值意味着系统在挣扎。根据 man 手册的说明，100%是高数值，少于30%则是地数值。
**** -H :: 大页面统计信息
| 统计信息  | 描述                 | 单位 |
|-----------+----------------------+------|
| hbhugfree | 空闲巨型页面存储器   | KB   |
| hbhugused | 占用的巨型页面存储器 | KB   |

**** -r :: 内存使用率
| 统计信息  | 描述                                         | 单位   |
|-----------+----------------------------------------------+--------|
| kbmemfree | 空闲存储器                                   | KB     |
| kbmemused | 占用存储器                                   | KB     |
| kbbuffers | 缓冲高速缓存尺寸                             | KB     |
| kbcached  | 页面高速缓存尺寸                             | KB     |
| kbcommit  | 提交的主存储器，服务当前工作负载需要量的估计 | KB     |
| %commit   | 为当前工作负载提交的主存储器，估计值         | 百分比 |
| kbactive  | 活动列表存储器尺寸                           | KB     |
| kbinact   | 非活动列表存储器尺寸                         | KB     |

**** -R :: 内存统计信息
| 统计信息 | 描述                           | 单位    |
|----------+--------------------------------+---------|
| frpg/s   | 释放的存储器页面，负值表示分配 | 页面/秒 |
| bufpg/s  | 缓冲高速缓存增加值             | 页面/秒 |
| campg/s  | 页面高速缓存增加值             | 页面/秒 |
**** -S :: 交换空间统计信息
| 统计信息  | 描述               | 单位 |
|-----------+--------------------+------|
| kbswpfree | 释放交换分区       | KB   |
| kbswpused | 占用交换分区       | KB   |
| kbswpcad  | 高速缓存的交换空间 | KB   |
**** -W :: 交换统计信息
| 统计信息  | 描述     | 单位   |
|-----------+----------+--------|
| pswpin/s  | 页面换入 | 页面/s |
| pswpout/s | 叶敏换出 | 页面/s   |
*** slabtop
:PROPERTIES:
:interleave_page_note: 309
:END:
slabtop可以通过slab分配器实时输出内核slab缓存使用情况
#+BEGIN_SRC shell :results org :dir /sudo::
  sudo slabtop -o |head
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
 Active / Total Objects (% used)    : 457428 / 566892 (80.7%)
 Active / Total Slabs (% used)      : 18239 / 18239 (100.0%)
 Active / Total Caches (% used)     : 106 / 138 (76.8%)
 Active / Total Size (% used)       : 134870.55K / 179260.05K (75.2%)
 Minimum / Average / Maximum Object : 0.01K / 0.32K / 15.69K

  OBJS ACTIVE  USE OBJ SIZE  SLABS OBJ/SLAB CACHE SIZE NAME                   
141372 107303  75%    0.19K   6732       21     26928K dentry                 
 63510  40233  63%    1.05K   2117       30     67744K ext4_inode_cache       
 61581  56301  91%    0.10K   1579       39      6316K buffer_head            
#+END_SRC

输出的顶端是汇总信息，下面是slab列表。

slab统计信息取至于 =/proc/slabinfo=,也可以使用 =vmstat -m= 输出
*** ps
ps可以列出包括内存使用统计信息在内的所有进程细节.

#+BEGIN_SRC shell :results org
  ps aux |head
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.0  0.0 192476  1324 ?        Ss   09:01   0:03 /sbin/init
root         2  0.0  0.0      0     0 ?        S    09:01   0:00 [kthreadd]
root         3  0.0  0.0      0     0 ?        I<   09:01   0:00 [rcu_gp]
root         4  0.0  0.0      0     0 ?        I<   09:01   0:00 [rcu_par_gp]
root         5  0.0  0.0      0     0 ?        I    09:01   0:00 [kworker/0:0-events]
root         6  0.0  0.0      0     0 ?        I<   09:01   0:00 [kworker/0:0H-kblockd]
root         8  0.0  0.0      0     0 ?        I<   09:01   0:00 [mm_percpu_wq]
root         9  0.0  0.0      0     0 ?        S    09:01   0:00 [ksoftirqd/0]
root        10  0.0  0.0      0     0 ?        I    09:01   0:03 [rcu_preempt]
#+END_SRC

其中涉及内存的列包括:

+ %MEM :: 内存使用(物理内存，RSS)占总内存的百分比
+ RSS :: 常驻集合大小(KB),它包括系统库在内的映射共享段，可能被多个进程共享。因此如果把RSS列取和可能会超过系统内存综合。
+ VSZ :: 虚拟内存大小(KB)
         
         
我们还可以通过 =-o= 选项指定输出的列，其中 =maj_flt= 表示严重换页， =min_flt= 表示轻微换页
#+BEGIN_SRC shell :results org
ps -o pid,pmem,vsz,rss,comm,maj_flt,min_flt
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
  PID %MEM    VSZ   RSS COMMAND          MAJFL  MINFL
 1465  0.0  36396  1164 systemd              4   1699
 1466  0.0 233800     0 (sd-pam)             0     46
 2194  0.0  10752  1096 dbus-daemon         24    610
 2227  1.3 317552 53136 fcitx             1029  16998
 2239  0.0  10536   644 dbus-daemon          0    165
 2243  0.0   9208    60 fcitx-dbus-watc      2     41
 2271  0.0 308180   688 at-spi-bus-laun     10    660
 2278  0.0  10396   580 dbus-daemon          0    277
 2280  0.0 167584   364 at-spi2-registr      5    419
 2297  0.0 240888   800 gvfsd               15    578
 2302  0.0 313536  1212 gvfsd-fuse           1    456
 2333  0.0  22580  1480 gconfd-2            28    331
 2346  0.0 371592  3544 sogou-qimpanel-     76   1123
 2426  0.0      0     0 sh <defunct>         0    284
 2518  1.1 3041280 42836 sogou-qimpanel   1210 373425
 2808 12.9 2304768 492644 firefox        11744 1019181
 2885  4.1 1862460 157128 Web Content     3812 313650
 2952  1.7 1776312 66472 Web Content      1126 238892
 2975  7.3 2267212 280232 WebExtensions  22415 921570
 3175  1.6 1787072 62280 Web Content      3178 357870
 3295  1.0 1519624 39228 Web Content      1401  59796
 4685  0.3 100640 14288 urxvt              223  11099
 5683  5.9 866384 226356 emacs           31186 160679
 7008  0.0  10176   436 reddit_wallpape      0     58
 7009  0.0  10176  1812 reddit_wallpape      0    117
 7010  0.4  32016 15796 wget                 0   2747
 7011  0.0   9364  2080 grep                 0    188
 7012  0.0   9396  2148 grep                 0    196
 7013  0.0   8372   696 shuf                 0    112
 7014  0.0   8656   764 head                 0    155
 7148  0.1  16104  4500 aspell             152    606
 7244  0.0  10176  2716 bash                 0    366
 7245  0.0  15788  2920 ps                   0    211
 7509  0.0  83512  1568 epdfinfo            43  19665
24759  0.0  10176  3324 reddit_wallpape      0    252
#+END_SRC
*** top
top命令监控排名靠前的运行中的进程，并显示内存统计信息
#+BEGIN_SRC shell :results org
  top -n 1 2>&1 |head
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
  任务: 181 total,   1 running, 179 sleeping,
     0 stopped,   1 zombie
  %Cpu(s):  7.6 us,  1.5 sy,  0.0 ni,
   89.4 id,  0.0 wa,  1.5 hi,  0.0 s
  i,  0.0 st
  MiB Mem :   3720.5 total,    755.9 free,   2397.2 

  used,    567.4 buff/cache
  MiB Swap:   8192.0 total,   6832.2 free,   1359.8 
  used.    922.2 avail Mem 

   进程 USER      PR  NI    VIRT    RES    SHR    %CPU  %MEM     TIME+ COMMAND    
    992 root      20   0  339728 178776  28548 S  13.3   4.7  22:35.41 k3s-server 
   1846 lujun99+  20   0  273824  34256  20656 S   6.7   0.9  16:48.70 Xorg       
   2223 lujun99+  20   0  371492  73800   6616 S   6.7   1.9   0:33.93 awesome    
  13302 lujun99+  20   0   16500   3660   3072 R   6.7   0.1   0:00.01 top        
      1 root      20   0  192476   2212   1796 S   0.0   0.1   0:04.83 systemd    
      2 root      20   0       0      0      0 S   0.0   0.0   0:00.00 kthreadd   
      3 root       0 -20       0      0      0 I   0.0   0.0   0:00.00 rcu_gp     
      4 root       0 -20       0      0      0 I   0.0   0.0   0:00.00 rcu_par_gp 
      5 root      20   0       0      0      0 I   0.0   0.0   0:00.22 kworker/0+ 
      6 root       0 -20       0      0      0 I   0.0   0.0   0:00.00 kworker/0+ 
      8 root       0 -20       0      0      0 I   0.0   0.0   0:00.00 mm_percpu+ 
      9 root      20   0       0      0      0 S   0.0   0.0   0:00.61 ksoftirqd+ 
#+END_SRC

顶部的摘要会显示物理内存(Mem)与虚拟内存(Swap)的总量、使用量和空闲量。还有缓冲缓存(buffers)和页缓存(cached)

下面列表中的 内存占用百分比(%MEM),虚拟内存大小(VIRT)和常驻集合大小(RES)跟PS对应的列一样。
*** pmap
:PROPERTIES:
:interleave_page_note: 314
:END:
pmap命令列出进程的内存映射，显示它们的大小、权限及映射的对象。

#+BEGIN_SRC shell :results org
  pmap -x $$
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
20287:   /bin/bash
住址            Kbytes     RSS   Dirty Mode  Mapping
0000555b458f0000     124     124       0 r---- bash
0000555b4590f000     552     552       0 r-x-- bash
0000555b45999000     180     148       0 r---- bash
0000555b459c6000      12      12      12 r---- bash
0000555b459c9000      16      16      16 rw--- bash
0000555b459cd000      52      40      40 rw---   [ anon ]
0000555b45f8b000     264     188     188 rw---   [ anon ]
00007fa21a6dd000    6036     372       0 r---- locale-archive
00007fa21acc2000       8       8       8 rw---   [ anon ]
00007fa21acc4000      92      92       0 r---- libncursesw.so.6.1
00007fa21acdb000     236      56       0 r-x-- libncursesw.so.6.1
00007fa21ad16000      92       0       0 r---- libncursesw.so.6.1
00007fa21ad2d000      20      20      20 r---- libncursesw.so.6.1
00007fa21ad32000       4       4       4 rw--- libncursesw.so.6.1
00007fa21ad33000     136     136       0 r---- libc-2.28.so
00007fa21ad55000    1324     876       0 r-x-- libc-2.28.so
00007fa21aea0000     304     124       0 r---- libc-2.28.so
00007fa21aeec000       4       0       0 ----- libc-2.28.so
00007fa21aeed000      16      16      16 r---- libc-2.28.so
00007fa21aef1000       8       8       8 rw--- libc-2.28.so
00007fa21aef3000      16      12      12 rw---   [ anon ]
00007fa21aef7000       4       4       0 r---- libdl-2.28.so
00007fa21aef8000       4       4       0 r-x-- libdl-2.28.so
00007fa21aef9000       4       0       0 r---- libdl-2.28.so
00007fa21aefa000       4       4       4 r---- libdl-2.28.so
00007fa21aefb000       4       4       4 rw--- libdl-2.28.so
00007fa21aefc000      88      88       0 r---- libreadline.so.8.0
00007fa21af12000     160      64       0 r-x-- libreadline.so.8.0
00007fa21af3a000      40       0       0 r---- libreadline.so.8.0
00007fa21af44000      12      12      12 r---- libreadline.so.8.0
00007fa21af47000      24      24      24 rw--- libreadline.so.8.0
00007fa21af4d000      12       8       8 rw---   [ anon ]
00007fa21af9f000       8       8       0 r---- ld-2.28.so
00007fa21afa1000     124     124       0 r-x-- ld-2.28.so
00007fa21afc0000      32      32       0 r---- ld-2.28.so
00007fa21afc8000       4       4       4 r---- ld-2.28.so
00007fa21afc9000       4       4       4 rw--- ld-2.28.so
00007fa21afca000       4       4       4 rw---   [ anon ]
00007ffef0f95000     132      28      28 rw---   [ stack ]
00007ffef0ff1000      12       0       0 r----   [ anon ]
00007ffef0ff4000       4       4       0 r-x--   [ anon ]
---------------- ------- ------- ------- 
total kB           10176    3224     416
#+END_SRC

其中显示的内存映像中包括，虚拟内存(KBytes)、物理内存(RSS)、私有匿名内存(Dirty)、权限(Mode).

其中大部分映射都没有匿名内存，且大部分的权限应该都是只读的。这意味着这些页面可以被其他进程共享、尤其是系统库更是如此。

由于pmap可能会暂停进程以报告内存使用，这会影响活跃任务的性能，因此该工具不能作为监视工具频繁运行。
*** 其他工具
+ free :: 报告空闲内存、包括缓冲缓存和页缓存
+ dmesg :: 检查来只OOM Killer的"Out of memory" 信息
+ valgrind :: 一个包括memcheck在内的性能分析套件，可用于发现内存泄漏
+ swapon :: 添加和观察物理交换设备和文件
+ iostat :: 通过观测设备IO来判断系统是否在换页
+ perf :: 利用它能观察CPI、MMU/TSB事件，以及源自CPU性能计数器的内存总线的停滞周期计数。它还提供缺页以及一些内核内存事件的探针
+ /proc/zoneinfo :: NUMA节点的统计信息
+ /proc/buddyinfo :: 内核页面伙伴分配器统计信息
** 调优
:PROPERTIES:
:interleave_page_note: 320
:END:
最重要的内存调优是保证应用程序保留在主存中，并且避免换页和交换经常发生。

其他内存调优的方法有:内核可调参数、配置大页面、分配器和资源控制
*** 可调参数
:PROPERTIES:
:interleave_page_note: 321
:END:
Documentation/sysctl/vm.txt 的内核源代码文档中介绍了多种可调参数

#+NAME: Linux内存可调参数
| 选项                         |  默认值 | 说明                                                           |
|------------------------------+---------+----------------------------------------------------------------|
| vm.dirty_background_bytes    |       0 | 触发pdflush后台回写的脏主存容量                                |
| vm.dirty_background_ratio    |      10 | 触发pdflush后台回写的脏主存百分比                              |
| vm.dirty_bytes               |       0 | 触发一个写入进程开始回写的主存器容量                           |
| vm.dirty_ratio               |      20 | 触发一个写入进程开始回写的主存器比率                           |
| vm.dirty_expire_centisecs    |    3000 | 适用pdflush的脏主存最小时间                                    |
| vm.dirty_writeback_centisecs |     500 | pdflush活跃时间间隔,0表示停用                                  |
| vm.min_free_kbytes           | dynamic | 设置期望的空闲（free）主存容量                                 |
| vm.overcommit_memory         |       0 | 0=利用探索法允许合理的过度分配。1=一直过度分配。2=禁止过度分配 |
| vm.swapiness                 |      60 | 倾向使用交换而不是回收页面高速缓存来释放主存的程度             |
| vm.vfs_cache_pressure        |     100 | 回收高速缓存的目录和inode对象的程度。                          |
*** 配置大页面
大页面能提高TLB缓存命中率从而提升内存IO性能。

在Linux中设置大内存的方法可以参考 =Documentation/vm/hugetlbpage.txt=
*** 分配器
有多种为多线程应用提供性能的用户级分配器可供选择，在编译阶段通过 =LD_PRELOAD= 环境变量设置
*** 资源控制
基础的资源控制可以通过ulimit实现

Linux cgroup也能对内存子系统进行多种控制:
+ memory.memsw.limit_in_bytes :: 允许的最大内存和交换分区总和，单位是字节
+ memory.limit_in_bytes :: 允许的最大用户内存，包括文件缓存，单位是字节
+ memory.swappiness :: 类似vm.swappiness,设置通过交换释放内存的偏好
+ memory.oom_control :: 设置为0，允许OOM Killer运用于这个cgroup，1则表示禁止OOM killer
* 文件系统
:PROPERTIES:
:interleave_page_note: 328
:END:
文件系统通过缓存、缓冲以及异步IO等手段来缓和磁盘延时对应用程序的影响，因此文件系统性能要比磁盘性能更加重要

所谓文件系统缓存是指物理内存中的一块区域，用来缓存文件系统的内容，可能包含各种数据和元数据。

当我们说文件系统IO时，仅仅指的是read(),write(),stat(),mkdir()操作，而不包括open和close操作。

此外，我们还把IO分成两类:
+ 逻辑IO，指由应用程序发给文件系统的IO
+ 物理IO，指由文件系统直接发给磁盘的IO，也成为裸IO
** 文件系统模型
*** 文件系统接口
[[file:./images/screenshot-06.png]]
*** 文件系统缓存
读操作从缓存中返回(缓存命中)或者从磁盘返回(缓存未命中). 未命中的操作会被存储在缓存中。

[[file:./images/screenshot-07.png]]

写操作也可以将内容先写入缓存，然后等待时机批量写入。
** 文件系统性能的几个关键概念
:PROPERTIES:
:interleave_page_note: 333
:END:

+ 文件系统延时 :: 指一个文件系统逻辑请求从开始到结束的时间，包括消耗在文件系统、内核磁盘IO子系统以及磁盘设备物理IO的时间。

+ 缓存 :: 文件系统缓存对应用程序是透明的，文件系统使用缓存(caching)提高读性能，用换从(buffering)提高写性能

+ 随机IO与顺序IO :: 顺序IO里每个IO都开始于上一个IO结束的地址。随机IO则偏移量随机变化。

+ 碎片化 :: 若文件在文件系统中的摆放变得杂乱无章则顺序的逻辑IO也可能变成随机的物理IO，这种情况称为碎片化。

+ 预取(预读) :: 听过检查当前和上一个IO的文件偏移量，可以检测出当前是否是顺序读负载，从而做出预测，在应用程序请求前将磁盘内容读入文件系统缓存。

  1. 应用程序对文件调用read(),把控制权交给内核
  2. 文件系统发起磁盘读操作
  3. 将上一次文件偏移指针与当前地址进行对比，如果是顺序的，则文件系统发起额外读请求
  4. 第一次读取结果返回，内核把数据和控制权交还给应用程序
  5. 额外的读请求
            
+ 写回缓存 :: 当数据写入主存后就认为写入以及结束并返回，之后再异步地把数据刷入磁盘。

  1. 应用程序发起文件的write()请求，把控制权交给内核
  2. 数据从应用程序地址空间复制到内核空间
  3. write函数调用被内核视为已结束，把控制权还给应用程序
  4. 一段时间后，一个异步的内核任务定位到要写入的数据，发起磁盘的写操作

+ 同步写 :: 等待所有的数据以及文件系统元数据被完整地写入到磁盘中,常用语数据库写日志。

+ 裸IO :: 绕过整个文件系统，直接写入磁盘。因为有些应用程序能比文件系统更好地缓存自己的数据，缺点在于难以管理，不能使用日常文件系统工具进行备份、回复和监控

+ 直接IO :: 绕过缓存使用文件系统，类似同步写，可以防止只读一次的数据污染文件系统缓存

+ 内存映射文件 :: 可以通过把文件映射到进程地址空间，通过直接存取内存地址的方法来提高文件系统IO性能，因为这样可以避免调用read()和write()时产生的系统调用和上下文切换的开销。 如果内核支持直接复制文件数据缓冲到进程地址空间，那么还能防止复制数据两次

+ 逻辑元数据 :: 应用程序读取或写入的信息，如读取文件统计信息(stat),创建、删除文件(create,unlink),创建、删除目录(mkdir,rmdir),更新文件系统存取时间戳,更新目录修改时间戳

+ 物理元数据 :: 与磁盘布局相关的元数据，依赖于文件系统类型，可能包括超级块、inode、数据块指针、空闲链表等

+ 逻辑IO :: 应用程序向文件系统发起的IO

+ 物理IO :: 磁盘IO，由于文件系统缓存读，写，维护元数据，向上对齐,奇偶校验等，因此物理IO对应用程序的影响显得不那么直接。

+ 容量对IO性能的影响 :: 当文件系统装满时，写入新数据需要花更多时间来寻找磁盘上的空闲块，此外更小和随机的IO页影响了磁盘性能
** 文件系统架构
:PROPERTIES:
:interleave_page_note: 340
:END:
*** 文件系统IO栈的一般模型
[[file:./images/screenshot-08.png]]
*** 文件系统缓存
Linux具有多种缓存，包括了：
+ 缓冲区高速缓存(2.4开始被并入页缓存中)
+ 页缓存
+ 目录缓存
+ inode缓存

下图是Linux文件系统缓存的概览图
[[file:./images/screenshot-09.png]]
**** 页缓存
叶缓存缓存了虚拟内存和文件系统的页面，从而提升文件和目录性能。
页缓存的大小是动态的，它会不断增长消耗可用的内存，并在应用程序需要的时候释放

这些缓存中的脏页会定时被flush线程写入设备中，Linux会为每个设备分配一个线程，从而平衡每个设备的负载，提高吞吐量。
页面写回的条件包括:
+ 等待了一段时间(30s)
+ 调用了sync,fsync或msync等系统调用
+ 过多的脏页面(比率超过dirty_ratio参数)
+ 页面缓存中没有可用的页面

如果系统内存不足，则kswapd线程会把脏页面写入磁盘上，从而腾出可重用的内存页面。
**** 目录项缓存(Dcache)
目录项缓存记录了从目录项到VFS inode的映射关系，从而提高路径查找性能。

当遍历一个路径名时，查找其中每一个名字都可以先检查Dcache，直接得到inode的映射，而不用到目录里一项项地翻查

目录项缓存也是动态变化的，当系统需要更多内存时，会按照LRU原则缩小。它的大小可以通过 =/proc= 查看
**** inode缓存
VFS inode描述了文件系统一个对象的属性，这些属性多可以通过stat()系统调动获取，并被操作系统频繁访问。

inode缓存也是动态变化的，它保存了 *至少* 所有被目录项缓存映射的inode。
当系统内存不足时，inode缓存会先释放未与目录项关联的inode，以缩小内存占用。
*** 文件系统特性
**** 块和区段
[[file:./images/screenshot-10.png]]
**** 日志
[[file:./images/screenshot-11.png]]
**** 写时复制
[[file:./images/screenshot-12.png]]
**** 擦洗
[[file:./images/screenshot-13.png]]
*** 卷和池
卷把多个磁盘组成一块虚拟磁盘，再在此智商建立文件系统。
在整块磁盘上建立文件系统（不分片或分区）是，卷能够隔离负载、降低竞争、缓和性能问题
常见的卷管理软件就是Linux的逻辑卷管理器(LVM)

池存储是把磁盘放在一个存储池中，池上可以建立多个文件系统。

相比来说，池存储会比卷存储更灵活，可以增长或缩小文件系统而不涉及下面的设备。

下图体现了卷和池的不同之处:
[[file:./images/screenshot-14.png]]
** 文件系统分析和调优的方法
推荐的分析测试是按顺序使用以下策略: 延时分析、性能监控、负载特征归纳、微型基准测试、静态性能调优、事件监控
:PROPERTIES:
:interleave_page_note: 353
:END:
*** 磁盘分析

由于存在文件系统缓存，因此磁盘IO实际上影响比较间接，因此这个方法已经不太常用了。

但在文件系统较为简单且缓存较小的情况下可以嘉定IO瓶颈就在磁盘上。

*** 延时分析

延时分析测量文件系统操作的延时。有四个层次的延时:

[[file:./images/screenshot-15.png]]

在分析延时时要注意，对于缓存命中率高的文件系统，大部分的操作可能都被缓存命中而导致平均延时较低。
但真正重要的是那些高延时的个案。

文件系统延时分析还能以应用程序事务内等待文件系统的占比来体现: =文件系统消耗占比=所有文件系统阻塞延时/应用程序事务时间=
从这个角度来分析，那么若应用程序发起的是异步IO，则由于应用程序可以一边等待文件系统返回、一边继续执行；因此文件系统阻塞的延迟仅仅包括应用程序让出CPU的时间而已。

*** 负载特征分析
:PROPERTIES:
:interleave_page_note: 357
:END:

文件系统负载需要归纳的几个基本属性包括:
+ 操作频率和操作类型
+ 文件IO吞吐量
+ 文件IO大小
+ 读写比例
+ 同步写的比例
+ 文件随机和连续访问比率

下面是一个负载描述的样例
#+BEGIN_EXAMPLE
  一个金融交易系统的数据库，给文件系统产生了随机读负载，频率为平均每秒18000次读， 平均读大小为2KB。
  总操作频率是21000次/s,包括了读取、统计、打开、关闭和大约每秒200次的写入。
  写频率想丢读比较稳定，后者高峰时能达到每秒39000次
#+END_EXAMPLE

在深度研究文件系统问题时，可以检查下面内容:
+ 文件系统缓存命中率是多少？未命中率是多少？
+ 文件系统缓存有多大？当前使用情况如何？
+ 使用了那些缓存（目录、inode、高速缓冲区），它们的使用情况如何？
+ 那些应用程序和用户在使用文件系统？
+ 那些文件、目录正在被访问？做了哪些操作？
+ 文件系统操作出现什么问题吗？是否是非法请求还是文件系统本身有问题？
+ 用户程序的调用路径是什么
+ 应用发起的文件系统IO中，同步的占比是多少？
+ IO抵达时间的分布是怎样的？

*** 性能监控
:PROPERTIES:
:interleave_page_note: 358
:END:

主要的文件系统性能指标包括:
+ 操作频率
+ 操作延时

可以记录单个操作类型(读、写、统计、打开、关闭等)的频率和延时数据。这对调查负载和性能变化有很大的帮助，可以找出不同类型之间的差异。

*** 事件跟踪
:PROPERTIES:
:interleave_page_note: 358
:END:

时间跟踪捕获文件系统每个操作的细节并保存到日志文件中。这些日志信息可能包含操作的如下信息：

+ 文件系统类型
+ 文件系统挂载点
+ 操作类型(读取、写入、统计、打开、关闭、建目录等)
+ 操作大小（字节数）
+ 操作开始时间戳：向文件系统发起操作的时间
+ 操作结束时间戳：文件系统完成操作的时间
+ 操作完成状态：错误还是成功
+ 路径名
+ 进程ID
+ 应用程序名

*** 静态性能调优
:PROPERTIES:
:interleave_page_note: 359
:END:

静态心梗调优主要关注问题发生的配置环境。对于文件系统性能，检查下面静态配置情况：
+ 挂载并使用了多少个文件系统
+ 文件系统记录大小是多少？
+ 启用了访问时间戳吗？
+ 还启动了哪些文件系统选项（压缩、加密等）
+ 文件系统缓存是嗯么配置的？最大缓存大小是多少？
+ 其他缓存（目录、inode、高速缓存）是怎么配置的？
+ 有二级缓存吗？用了吗？
+ 有多少了存储设备？用了几个？
+ 设备存储是怎么配置的？用了RAID吗？
+ 用了哪种文件系统？文件系统能够的版本？
+ 有什么需要考虑的文件系统BUG或补丁吗？
+ 启用了文件系统IO的资源控制吗？
  
回答这些问题能够暴露一些被忽视的配置问题。

*** 缓存调优
:PROPERTIES:
:interleave_page_note: 360
:END:
内核和文件系统会使用多种缓存，包括缓冲区高速缓存、目录缓存、inode缓存和文件系统缓存。

缓存调优需要先检查有哪些缓存、接着看他们是否投入使用，使用的情况如何以及缓存大小。 再根据负责调整缓存。

*** 负载分离
:PROPERTIES:
:interleave_page_note: 360
:END:
有些类型的负载在独占文件系统和磁盘设备时表现更好，这是因为当施加多种不同的负载时可能会导致随机IO，这对旋转磁盘特别不利。

比如我们可以让日志文件和数据库文件拥有单独的文件系统和磁盘，能提高数据库性能。

*** 内存文件系统
:PROPERTIES:
:interleave_page_note: 360
:END:
内存文件系统将文件内容存放在内存中，这样以最快速度响应情况。

不过现代文件系统通常拥有很大的文件系统缓存，使用内存文件系统并不那么实用。

*** 微型基准测试
:PROPERTIES:
:interleave_page_note: 360
:END:
可以实用基准测试工具来测试多种类型的文件系统性能，或者某负载下，同一文件系统不同设置下的性能。

+ 操作频率: 读、写等其他文件系统操作的频率
+ IO大小： 访问的数据量
+ 文件偏移量模式: 随机或者连续
+ 随机访问模式: 随机分布还是帕累托分布
+ 写类型: 异步写/同步写(O_SYNC)
+ 工作集大小: 文件系统缓存是否放得下
+ 并发数: 同时执行的IO数
+ 内存映射: 文件通过mmap()访问还是通过read、write访问
+ 缓存状态: 访问的对象是否以及被读入缓存
+ 文件系统可调参数: 块大小、压缩、数据消重等

常见的测试组合包括,随机读、随机写、连续读、连续写.
其中最重要的参数通常是IO大小，因为小IO通常可以命中缓存直接从内存中返回，而大IO需要从磁盘中读取内容。

[[file:./images/screenshot-16.png]]

** 分析工具
:PROPERTIES:
:interleave_page_note: 362
:END:
[[file:./images/screenshot-17.png]]

*** strace
使用strace可以检测open(),read(),write()等API的耗时情况

*** DTrace/SystemTap
:PROPERTIES:
:interleave_page_note: 364
:END:

DTrace能从系统调用接口、VFS接口或者文件系统内部的角度来查看文件系统行为。
这些功能可以用在负载特征归纳和延时分析上。

*** free
:PROPERTIES:
:interleave_page_note: 374
:END:
