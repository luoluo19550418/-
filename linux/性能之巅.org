#+INTERLEAVE_PDF: ../../Downloads/性能之巅 洞悉系统、企业与云计算.pdf
#+TITLE: 性能之巅
#+AUTHOR: lujun9972
#+TAGS: linux
#+DATE: [2019-01-03 四 09:20]
#+LANGUAGE:  zh-CN
#+OPTIONS:  H:6 num:nil toc:t \n:nil ::t |:t ^:nil -:nil f:t *:t <:nil
* 操作系统
** 用户栈和内核栈
:PROPERTIES:
:interleave_page_note: 125
:END:
在执行系统调用是，一个进程的线程有两个栈：一个用户级别的栈和一个内核级别的栈。

当线程被阻塞时，用户级别的栈在系统调用期间并不会被改变，因为在内核上下文中执行时，线程用的是一个单独的内核级别的栈。
* 观测工具
** 性能观测工具的分类
:PROPERTIES:
:interleave_page_note: 147
:END:

根据工具是 =系统级别/进程级别= 和 =基于计数/基于跟踪= 这两个维度可以将性能观测工具分成4类:

[[file:./images/screenshot-02.png]]

*** 计数器
内核维护了各种统计数据用于对事件计数，通常计数器实现为无符号的整型，当发生事件时递增。

计数器的使用可以认为是零开销，因为它就在那里，始终由内核维护，唯一的使用开销是从用户空间读取它而已。

系统级别的计数器工具包括:

+ vmstat :: 虚拟内存和物理内存的统计
+ mpstat :: 每个CPU的使用情况
+ iostat :: 每个磁盘IO的使用情况，由块设备接口报告
+ netstat :: 网络接口的统计，TCP/IP栈的统计，以及每个连接的一些统计信息
+ sar :: 各种各样的统计，能归档历史数据

         
进程级别的计数器工具包括:

+ ps :: 查看进程各种统计信息，包括内存和CPU的使用
+ top :: 按一个统计数据排序
+ pmap :: 将进程的内存段和使用统计一起列出

*** 跟踪
跟踪收集每一个事件的数据以供分析。跟踪捕获数据会有CPU开销，还需要不小的存储空间来存放数据，因此可能会拖慢被跟踪的对象。

日志可以被认为是一种默认开启的低频率跟踪。

系统级别的跟踪工具包括:

+ tcpdump :: 网络包跟踪（libpcap库)
+ snoop :: 网络包跟踪工具
+ blktrace :: 块IO跟踪
+ iosnoop :: 基于DTrace的块IO跟踪工具
+ execsnoop :: 基于Dtrace的新进程跟踪工具
+ dtruss :: 基于Dtrace的系统调用缓冲跟踪工具
+ DTrace :: 跟踪内核的内部活动和所有资源的使用情况，支持静态和动态的跟踪
+ SystemTap :: 跟踪内核的内部活动和所有资源的使用情况，支持静态和动态的跟踪
+ perf :: Linux性能事件、静态和动态跟踪的探针

进程级别的跟踪工具包括:

+ strace :: 跟踪Linux系统调用
+ truss :: 跟踪系统调用
+ gdb :: 源码级别的调试器
+ mdb :: 一个具有可扩展性的调试器

*** 剖析(profiling)
profiling通过对目标收集采样或者快照来归纳目标特征

常见的profiler有:

+ oprofile :: Linux系统剖析
+ perf :: Linux性能工具集
+ DTrace :: 程序化剖析，profile provider提供基于时间的剖析，cpc provider提供基于硬件的剖析
+ SystemTap :: 程序化剖析，timer tapset提供基于时间的剖析，perf tapset提供基于硬件的剖析
+ cachegrind :: 源自valgrind工具集，能对硬件缓存的使用做剖析，也能用kcachegrind做数据可视化
+ Intel VTune Amplifier XE :: Linux和Windows的剖析，拥有包括源代码浏览在内的图形界面
+ Oracle Solaris Studio :: 用自带的性能分析器对Solaris和Linux做剖析

此外，编程语言通常有各自的专用分析器

*** 监视
:PROPERTIES:
:interleave_page_note: 150
:END:

最广泛应用的监视工具是sar，它基于计数器，在预定的时间被调用以记录系统计数器的状态

除了sar之外，还有其他的替代，比如System Data Recorder和Collectl

** 观测来源
:PROPERTIES:
:interleave_page_note: 151
:END:

系统性能统计的主要来源包括 =/proc=, =/sys=, =kstat= 等

#+TABLE: 观测来源
| Type               | Linux                      | Solaris         |
|--------------------+----------------------------+-----------------|
| 进程级计数器       | /proc                      | /proc,lxproc    |
| 系统级计数器       | /proc,/sys                 | kstat           |
| 设备驱动和调试信息 | /sys                       | kstat           |
| 进程级跟踪         | ptrace,uprobes             | procfs,dtrace   |
| 性能计数器         | perf_event                 | libcpc          |
| 网络跟踪           | libpcap                    | libdlpi,libpcap |
| 进程级延时指标     | 延时核算                   | 微状态核算      |
| 系统级跟踪         | tracepoints,kprobes,ftrace | dtrace          |

*** /proc
这是一个提供内核统计信息的文件系统接口。 =/proc= 提供很多目录，其中以进程ID命名的目录代表的就是那个进程。
这些目录下的众多文件包含了进程的信息和统计数据，由内核数据结构映射而来。其中，与进程性能观测相关的文件如下:
+ limits :: 实际的资源限制
+ maps :: 映射的内存区域
+ sched :: CPU调度器的各种统计
+ schedstat :: CPU运行时间、延时和时间分片
+ smaps :: 映射内存区域的使用统计
+ stat :: 进程状态和统计，包括总的CPU和内存的使用情况
+ statm :: 以页为单位的内存使用总结
+ status :: stat和statm的信息，用户可读
+ task :: 每个任务的统计目录

Linux将 =/proc= 延伸到了系统级别的统计,与性能观测相关的系统级别的文件包括:
+ cpuinfo :: CPU信息，包括所有虚拟CPU、型号、时钟频率和缓存大小
+ diskstats :: 对所有磁盘设备的磁盘IO统计
+ interrupts :: 每个CPU的中断计数器
+ loadavg :: 负载平均值
+ meminfo :: 系统内存使用明细
+ net/dev :: 网络接口统计
+ net/tcp :: 活跃的TCP套结字信息
+ schedstat :: 系统级别的CPU调度器统计
+ self :: 当前进程ID路径的符号连接
+ slabinfo :: 内核slab分配器缓存统计
+ stat :: 内核和系统资源的统计，CPU、磁盘、分页、交换区、进程
+ zoneinfo :: 内存区信息

关于 =/proc= 的内容可以在 =proc(5)= d的man页和Linux内核文档 =/Documentation/filesystems/proc.txt= 中找到。
Linux中的 =/proc= 的文件系统类型是 =proc=, 而基于Solaris的系统是 =procfs=.

*** /sys
:PROPERTIES:
:interleave_page_note: 156
:END:

Linux还提供了一个sysfs文件系统，挂载在 =/sys=.

#+BEGIN_SRC shell :results org
grep . /sys/devices/system/cpu/cpu0/cache/index*/size
#+END_SRC

#+BEGIN_SRC org
/sys/devices/system/cpu/cpu0/cache/index0/size:32K
/sys/devices/system/cpu/cpu0/cache/index1/size:32K
/sys/devices/system/cpu/cpu0/cache/index2/size:256K
/sys/devices/system/cpu/cpu0/cache/index3/size:3072K
#+END_SRC

这说明CPU0有两个L1缓存，每个都是32KB，还有一个256K的缓存和3M的L3缓存

*** 延时核算
:PROPERTIES:
:interleave_page_note: 159
:END:

开启 =CONFIG_TASK_DELAY_ACCT= 选项的Linux还会跟踪以下状态的时间
+ 调度器延时(CPU) :: 等待轮上CPU的是时间
+ 块IO(IO) :: 等待块IO完成的时间
+ 交换(SWAP) :: 等待内存换页的时间
+ 内存回收(RECLAIM) :: 等待内存回收的时间

*** 其他观测源
:PROPERTIES:
:interleave_page_note: 160
:END:

+ CPU性能计数器 :: 在Linux上通过 =perf_events= 接口，或者系统调用 =perf_event_open(0= ，或者 =perf= 这样的工具来访问
+ 进程级跟踪 :: Linux上可以通过系统调用 =ptrace()= 来控制进程跟踪， =strace= 命令来跟踪系统调用，还有 =uprobes= 来做用户级别的动态跟踪
+ 内核跟踪 :: 在Linux中，tracepoints提供静止的内核探针，kproes提供动态探针。
+ 网络嗅探 :: 在Linux上，嗅探的功能是通过libpcap库和 =/proc/net/dev= 提供的
+ 系统调用 :: 某些系统调用和库函数可以提供性能指标，比如 =getrusage()= 函数可以为进程拿到自己资源的统计信息

** DTrace
:PROPERTIES:
:interleave_page_note: 162
:END:
DTrace的设计是生产环境安全的，拥有极小的性能开销。
DTrace同时支持静态跟踪和动态跟踪，两者功能互补。静态探针有文档完备且稳定的接口，而动态探针能够提供近乎无限的可观测性。
其中，静态跟踪是o通过直接嵌入源代码的静态探针实现的，而动态跟踪是通过内核地址空间的 =live patching= 将函数入口指令修改为引发一个软中断,该软中断会出发指定的action。

DTrace能动态跟踪函数的入口和返回，以及任何在用户空间执行的指令，但这是通过为CPU指令动态建立探针实现的，而CPU指令可能发生改变，因此该接口并不稳定。

*** D语言
DTrace通过一套D语言来设置各个探针，并定义在探针命中时执行的操作。
D语言与awk很像，甚至它也能跟awk一样既能在单行命令中执行，也能写成脚本。D语言的语法形式如下:

#+begin_example
  探针描述 /过滤条件/ {actions}
#+end_example

**** 探针描述
DTrace探针描述分成四个部分:

#+begin_example
  provider:module:function:name
#+end_example

其中， =provider= 是探针的集合，类似于库的概念,
=module= 和 =function= 用来标记探针指示的代码位置，可以用通配符 =*=,或者留空("::"相当于":*:")来表示任意位置。
=name= 则是探针的名字。

可用的provider取决于你的DTrance和操作系统的版本，比较常见的provider有:

+ syscall :: 系统调用自陷表
+ vminfo :: 虚拟内存统计
+ sysinfo :: 系统统计
+ profile :: 任意频率的采样
+ sched :: 内核调度事件
+ proc :: 进程级别事件，比如创建、执行、退出
+ io :: 块设备接口跟踪
+ pid :: 用户级别动态跟踪
+ tcp :: TCP协议事件，网络连接，数据包发送和接受
+ ip :: IP协议事件，发送和接受
+ fbt :: 内核级别动态跟踪
+ 其他高级语言的provider :: 比如Java，JavaScript，Node.js，Perl，Python,Ruby,Tcl等

**** 参数
探针通过参数来获取数据，不同探针接受的参数也不一样。
我们可以通过 =arg0...argN= 来获取这些参数，可以通过 =dtrace -lv= 选项来查看每个provider参数的概要说明。

**** 跟
内置变量awk一样，DTrace默认也提供了一些内置变量，可以在 =过滤条件= 和 =action= 中使用. 常见的内置变量有:

#+TABLE: 常用内置变量

| 变量            | 描述                         |
|-----------------+------------------------------|
| execname        | 执行的进程名字               |
| uid             | 用户ID                       |
| pid             | 进程ID                       |
| timestamp       | 当前时间，为自启动以来的ns数 |
| vtimestamp      | 线程执行时间，单位是ns       |
| arg0...argN     | 探针参数                     |
| arg[0]...arg[N] | 探针参数                     |
| curthread       | 指向当前线程内核结构的指针   |
| probefunc       | 探针触发的function位置       |
| probename       | 探针名称                     |
| curpsinfo       | 当前进程信息                 |

*** 过滤条件
=/过滤条件/= 这一部分是可选的，例如
#+begin_example
  proc:::exec-success /execname == "httpd"/ {trace(pid);}
#+end_example
就会限定指定对 =httpd= 进程执行 =trace(pid)= 这一action

如果省略这一部分，则表示不做过滤。
*** action
action指定了当触发探针时做的操作，常见的action包括:

#+TABLE: 常见action
| action                 | 描述                                                                       |
|------------------------+----------------------------------------------------------------------------|
| trace(arg)             | 输出arg的值                                                                |
| printf(format,arg,...) | 格式化输出arg的值                                                          |
| stringof(addr)         | 返回来自内核空间的字符串                                                   |
| copyinstr(addr)        | 返回来自用户空间的字符串（需要内核执行一次从用户空间到内核空间的复制操作） |
| stack(count)           | 打印内核级别的栈跟踪，如果有count则按count截断                             |
| ustack(count)          | 打印用户级别的栈跟踪，如果有count则按count截断                             |
| func(pc)               | 根据内核程序计数器(pc),返回内核函数名                                      |
| ufunc(pc)              | 根据用户程序计数器(pc),返回用户函数名                                      |
| exit(status)           | 退出DTrace，并返回状态                                                     |
| trunc(@agg,count)      | 截断聚合变量，若没有count则表示清空该聚合变量                              |
| clear(@agg)            | 清空聚合变量中各个键对应的值                                               |
| printa(format,@agg)    | 格式化输出聚合变量中的值                                                               |
*** 变量类型
:PROPERTIES:
:interleave_page_note: 192
:END:
#+TABLE: 变量类型及开销

| 类型               | 前缀   | 作用域         | 开销   | 多CPU是否安全 | 示例             |
|--------------------+--------+----------------+--------+---------------+------------------|
| 聚合变量           | @      | 全局           | 低     | 是            | @x = count();    |
| 带键的聚合变量     | @[]    | 全局           | 低     | 是            | @x[pid]=count(); |
| action子句局部变量 | this-> | action子句内部 | 非常低 | 是            | this->x=1;       |
| 线程局部变量       | self-> | 线程内         | 中等   | 是            | self->x=1;       |
| 标量               | 无     | 全局           | 中下   | 否            | x=1;             |
| 关联数组           | 无     | 全局           | 中上   | 否            | x[y]=1;         |

其中，聚合变量是一种特殊类型的变量，可以由CPU单独计算汇总之后再传递到用户空间。
该变量类型拥有最低的开销，是另一种数据汇总的方法。

下面这些action可以用来填充聚合变量

#+TABLE: 聚合action
| 聚合action                                                 | 描述                                              |
|------------------------------------------------------------+---------------------------------------------------|
| count()                                                    | 发生计数                                          |
| sum(value)                                                 | 对value求和                                       |
| min(value)                                                 | 记录value的最小值                                 |
| max(value)                                                 | 记录value的最大值                                 |
| quantize(value)                                            | 用2的幂次方直方图记录value                        |
| lquantize(value,min,max,step)                              | 用给定最小值、最大值和步进值做线性直方图记录value |
| llquantize(value,factor,min)magnitude,max_magnitude,steps) | 用混合对数/线性直方图记录value                                |
* 应用程序
** 应用程序性能技术
:PROPERTIES:
:interleave_page_note: 184
:END:

提高应用的常用技术包括:

+ 选择IO尺寸
+ 缓存/缓冲区
+ 轮询
+ 并发和并行
+ 非阻塞IO和处理器帮顶
*** 选择IO尺寸
执行IO的开销包括初始化缓冲区、系统调用、上下文切换分配内核元数据、检查进程权限和限制、映射地址到设备、执行内核和驱动代码来执行IO、释放元数据和缓冲区。
其中，初始化缓冲区的开销对于大型IO和小型IO来说都是差不多的，一般来讲每次IO传输的数据越多，效率越高。

增加IO尺寸是应用程序提高吞吐量的常用策略。但过大的IO尺寸会浪费缓存空间
*** 缓存
:PROPERTIES:
:interleave_page_note: 185
:END:

缓存的一个重要方面就是如何保证完整性，确保查询不会返回过期的数据，这被称为存的一致性。

过大的缓冲区可能会增加写延时，这是因为为了等待缓存区被写满，可能需要等待很多的时间。
*** 轮询
轮询是系统等待某一事件发生的技术，该技术在循环中检查事件状态。
轮询中有一些潜在的性能问题:

+ 循环检查导致CPU的开销过高
+ 循环之间的行为可能导致事件发生和下一次检查之间的延时较高。
**** poll()系统调用
poll()系统调用用来检查文件描述符的状态，提供与轮询相似的能力，不过它基于事件的，没有轮询那样的性能负担。

poll()借口将多个文件描述符放在数组中，应用系统扫描整个数组来寻找相应的文件描述符
这个扫描是O(n)的，因此可能会引发性能问题。
**** epoll()
:PROPERTIES:
:interleave_page_note: 188
:END:
Linux中提供了epoll()系统调用，它能够避免这种扫描，时间复杂度是O(1)
Notes for page 188**** 并发和并行
:PROPERTIES:
:interleave_page_note: 186
:END:
并发除了使用同步原语来保障完整性之外，还一般会与hash表一同使用来提高性能。

常见的同步原语有三种类型:

+ 排它锁(mutex) :: 只有锁持有者才能操作，其他线程阻塞并等待CPU
+ 自旋锁 :: 自旋锁允许所持有者操作，其他需要自旋锁的线程则会在CPU上循环自旋，检查锁是否被释放。这样的好处是线程不离开CPU，能够延时低，但是另一方面浪费CPU资源
+ 读写锁 :: 读写锁允许多个读者，但是只能有一个写着。

**** 使用hash表减少锁竞争
创建固定数目的锁，用hash算法来选择哪个锁用于哪个数据结构，这样可以减少锁的竞争。

一般来说，为了最大程度的并行，hash表的桶的数目应该大于或等于CPU的数目。

*** 非阻塞IO
在进程IO是进行阻塞，这种模型存在以下两个性能问题:

1. 由于每一次阻塞就是消耗一个线程/进程，因此对于多路并发的IO就意味着会创建很多的线程/进程，线程/进程的创建和销毁代码巨大。
2. 对于频繁发起的短时IO，会导致频换切换上下文，从而增加CPU资源的消耗。

而非阻塞IO模型则是异步发起IO，不阻塞当前的线程，线程可以执行其他工作。当IO完成后再通过信号通知线程继续下面的工作。

*** 处理器绑定
在使用NUMA的多处理器系统中将进程绑定到某个处理器运行，可以一直使用该CPU的本地存储器，从而减少对内存的IO，提高应用程序的整体性能。

但CPU绑定也会带来风险，比如若其他用户或程序也刚好用到这个绑定的CPU，则可能会引发冲突和调度器延时。

** 编程语言
:PROPERTIES:
:interleave_page_note: 189
:END:
解析器和语言虚拟机一般都有自己专门的工具来做不同级别的性能观测.

对于编译语言我们可以通过编译器优化来提升性能，但优化程度越高，其产生的机器码与源代码之间的映射关系就越模糊，可能会使性能分析变得不那么直观。

GC是常见的性能调整对象，用以降低CPU成本和减少延时时异常值的发生。
比如Java虚拟机就提供了许多可调参数来设置GC类型，GC线程数，堆尺寸最大值、目标堆空闲率等。

** 分析方法

*** 线程状态分析
:PROPERTIES:
:interleave_page_note: 192
:END:
线程状态分析的目的是分辨应用程序线程的时间用在了什么地方。

在线程状态分析时，我们可以把线程状态分成下面几中类型：
+ 执行 :: 正在CPU上执行
+ 可运行 :: CPU时间片耗尽，等待下一次轮询
+ 匿名换页 :: 因内存换页而受阻
+ 睡眠 :: 等待网络、块设备等IO操作完成
+ 锁 :: 等待获取同步锁
+ 空闲 :: 等待工作

提高性能的关键在于减少线程处于前五类状态的时间，针对线程处于哪类状态，我们可以做进一步的研究:
+ 执行 :: 检查线程实在用户态执行还是内核态执行，用profiling对CPU资源消耗情况进行分析，确定哪些代码路径消耗的CPU过大
+ 可运行 :: 这可能意味着应用程序需要更多的CPU资源，检查整个系统的CPU负载以及是否对应用程序做了CPU限制
+ 匿名换页 :: 应用程序缺少主存会引起换页，需要检查整个系统的内存使用情况，是否对应用程序做了不合理的内存限制
+ 睡眠 :: 分析到底是哪些资源导致应用程序阻塞，IO是否异常
+ 锁 :: 识别那些线程持有锁，确定线程持锁这么长时间的原因。

Linux系统为我们提供了下面这些工具进行分析:
+ 使用 =top= 命令可以查看各个进程的CPU消耗情况
+ 内核的 =schedstat= 功能会追踪可运行的线程，并将信息显示在 =/proc/$pid/schedstat= 中
+ =perf sched= 工具也提供了用于了解可运行线程与等待线程所花时间的指标
+ =pidstat -d= 可以判断一个进程实在执行磁盘IO还是睡眠
+ =iotop= 能够查看各个进程的io情况
+ 若某个应用程序的睡眠时间很长（达到秒级），则可以用pstack输出堆栈快照来调查原因。

*** CPU剖析
剖析的目标是要判断应用程序是如何消耗CPU资源的。一个有效的技术是对CPU上的用户栈跟踪做采样并将采样结果联系起来。
这些栈信息能够让告诉我们代码的执行路径，从而揭示出应用程序消耗CPU的原因。

针对解释语言和虚拟机语言的CPU剖析是很难的，因为从执行的代码到原始的程序之间并没有简单的映射关系。
只能寄希望于

*** 系统调用分析
:PROPERTIES:
:interleave_page_note: 197
:END:
系统调用分析的目标是要找出系统调用的时间花在什么地方，还有系统调用的类型以及使用该系统调用的原因。

**** strace命令
在Linux下可以使用strace命令跟踪系统调用，例如:
#+BEGIN_SRC shell
  strace -ttt -T -p $(pidof emacs)
#+END_SRC

#+BEGIN_EXAMPLE
  [lujun9972@T520 8948]$ sudo strace -ttt -T -p $(pidof emacs)
  strace: Process 6407 attached
  1546945285.834914 pselect6(21, [3 5 6 7 8 10 12 19 20], [], NULL, {tv_sec=2, tv_nsec=500433727}, {NULL, 8}) = 1 (in [7], left {tv_sec=0, tv_nsec=978006169}) <1.522453>
  1546945287.357587 rt_sigprocmask(SIG_BLOCK, [INT], [], 8) = 0 <0.000122>
  1546945287.357868 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0 <0.000045>
  1546945287.358029 accept4(7, {sa_family=AF_UNIX}, [112->2], SOCK_CLOEXEC) = 9 <0.000071>
  1546945287.358181 fcntl(9, F_SETFL, O_RDONLY|O_NONBLOCK) = 0 <0.000011>
  1546945287.358237 getsockname(9, {sa_family=AF_UNIX, sun_path="/tmp/emacs1000/server"}, [112->24]) = 0 <0.000008>
  1546945287.358430 recvmsg(10, {msg_namelen=0}, 0) = -1 EAGAIN (资源暂时不可用) <0.000009>
  1546945287.359993 poll([{fd=8, events=POLLIN}, {fd=10, events=POLLIN}, {fd=12, events=POLLIN}], 3, 0) = 0 (Timeout) <0.000012>
  1546945287.360174 rt_sigprocmask(SIG_BLOCK, [INT], [], 8) = 0 <0.000018>
  1546945287.360250 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0 <0.000010>
  1546945287.360288 pselect6(21, [3 5 6 7 8 9 10 12 19 20], [], NULL, {tv_sec=0, tv_nsec=975134338}, {NULL, 8}) = 1 (in [9], left {tv_sec=0, tv_nsec=975125651}) <0.000023>
  1546945287.360361 rt_sigprocmask(SIG_BLOCK, [INT], [], 8) = 0 <0.000023>
  1546945287.360432 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0 <0.000007>
  1546945287.360474 read(9, "-dir /home/lujun9972/ -current-f"..., 4096) = 332 <0.000016>
  1546945287.360624 getpid()              = 6407 <0.000008>
  1546945287.360659 write(9, "-emacs-pid 6407\n", 16) = 16 <0.000016>
  1546945287.361017 stat("/home/lujun9972", {st_mode=S_IFDIR|0710, st_size=12288, ...}) = 0 <0.000017>
  1546945287.361351 write(9, "-print nil\n", 11) = 11 <0.000015>
  1546945287.361517 close(9)              = 0 <0.000023>
  1546945287.363620 rt_sigprocmask(SIG_BLOCK, [WINCH IO], NULL, 8) = 0 <0.000020>
  1546945287.363783 poll([{fd=10, events=POLLIN|POLLOUT}], 1, -1) = 1 ([{fd=10, revents=POLLOUT}]) <0.000012>
  1546945287.363836 writev(10, [{iov_base=";\0\5\0\325\1\340\2\0\0\0\0x\3\202\2\315\1\22\0C\0\5\0H\1\340\2\325\1\340\2"..., iov_len=148}, {iov_base=NULL, iov_len=0}, {iov_base="", iov_len=0}], 3) = 148 <0.000020>
#+END_EXAMPLE

其中:

+ -ttt :: 在第一栏输出UNIX时间戳，以秒为单位，精确度可以到毫秒级
+ -T :: 在最后一栏输出系统调用的时间，以秒为单位，精确到毫秒级别
+ -p $PID :: 跟踪某个PID的进程

上述形式的strace没一行都表示一个系统调用。若只想输出系统调用活动的统计信息可以使用 =-c= 选项
#+BEGIN_SRC shell :results org
  strace -c date 2>&1
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
2019年 01月 08日 星期二 19:11:10 HKT
% time     seconds  usecs/call     calls    errors syscall
------ ----------- ----------- --------- --------- ----------------
 20.00    0.000032           5         6           close
 18.75    0.000030           7         4           openat
 17.50    0.000028           4         6           fstat
 15.00    0.000024          24         1           write
 10.62    0.000017           2         6           read
  6.88    0.000011           1         8           mmap
  6.88    0.000011           3         3           brk
  4.38    0.000007           1         4           lseek
  0.00    0.000000           0         4           mprotect
  0.00    0.000000           0         1           munmap
  0.00    0.000000           0         1         1 access
  0.00    0.000000           0         1           execve
  0.00    0.000000           0         2         1 arch_prctl
------ ----------- ----------- --------- --------- ----------------
100.00    0.000160                    47         2 total
#+END_SRC

其中:
+ time :: 显示系统CPU时间花在哪里的百分比
+ seconds :: 总的系统CPU时间，单位是秒
+ usecs/call :: 每次调用的平均系统CPU时间，单位是毫秒
+ calls :: 整个strace过程中系统嗲用的次数
+ syscall :: 系统调用的名字
**** truss
:PROPERTIES:
:interleave_page_note: 199
:END:
在Solaris系统上使用truss命令来分析系统调用,例如
#+BEGIN_SRC shell
  truss -dE -p $(pidof emacs)
#+END_SRC

这里的选项：
+ -d :: 输出命令启动后的秒数
+ -E :: 输出系统调用的耗时，单位为秒
+ -p PID :: 指定跟踪的进程

同样的，truss也使用 =-c= 选项进行系统调用的统计总结:
#+BEGIN_SRC shell
  truss -c dd if=/dev/zero of=/dev/null bs=1k count=10k
#+END_SRC

truss还可以使用 =-u= 选项对用户级函数进行动态跟踪，例如跟踪 =printf= 调用:
#+BEGIN_SRC shell
  truss -u 'libc:*printf*' uptime
#+END_SRC

**** 缓存跟踪
:PROPERTIES:
:interleave_page_note: 201
:END:

与断点跟踪相比，缓存跟踪并不会中断目标程序的执行，而是将监控程序缓存在内核中。

在perf中可以通过trace子命令来执行系统调用的缓存跟踪:
#+BEGIN_SRC shell :results org :dir /sudo::/tmp
  sudo perf trace touch a 2>&1
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
         ? (         ): touch/26378  ... [[33mcontinued[m]: execve()) = 0
     0.080 ( 0.006 ms): touch/26378 brk(                                                                  ) = 0x55d62ec22000
     0.093 ( 0.004 ms): touch/26378 arch_prctl(option: 12289, arg2: 140723363955488                       ) = -1 EINVAL Invalid argument
     0.134 ( 0.010 ms): touch/26378 access(filename: 0xe6f043a0, mode: R                                  ) = -1 ENOENT No such file or directory
     0.153 ([33m 0.011 ms[m): touch/26378 openat(dfd: CWD, filename: 0xe6f01891, flags: CLOEXEC                 ) = 3
     0.169 ( 0.005 ms): touch/26378 fstat(fd: 3, statbuf: 0x7ffcb61eb500                                  ) = 0
     0.178 ([33m 0.011 ms[m): touch/26378 mmap(len: 308934, prot: READ, flags: PRIVATE, fd: 3                   ) = 0x7f89e6e93000
     0.193 ( 0.004 ms): touch/26378 close(fd: 3                                                           ) = 0
     0.231 ( 0.009 ms): touch/26378 openat(dfd: CWD, filename: 0xe6f0ac70, flags: CLOEXEC                 ) = 3
     0.244 ( 0.006 ms): touch/26378 read(fd: 3, buf: 0x7ffcb61eb6c8, count: 832                           ) = 832
     0.255 ( 0.004 ms): touch/26378 lseek(fd: 3, offset: 792, whence: SET                                 ) = 792
     0.262 ( 0.004 ms): touch/26378 read(fd: 3, buf: 0x7ffcb61eb580, count: 68                            ) = 68
     0.271 ( 0.004 ms): touch/26378 fstat(fd: 3, statbuf: 0x7ffcb61eb560                                  ) = 0
     0.279 ( 0.008 ms): touch/26378 mmap(len: 8192, prot: READ|WRITE, flags: PRIVATE|ANONYMOUS            ) = 0x7f89e6e91000
     0.298 ( 0.004 ms): touch/26378 lseek(fd: 3, offset: 792, whence: SET                                 ) = 792
     0.305 ( 0.004 ms): touch/26378 read(fd: 3, buf: 0x7ffcb61eb1d0, count: 68                            ) = 68
     0.313 ( 0.003 ms): touch/26378 lseek(fd: 3, offset: 864, whence: SET                                 ) = 864
     0.320 ( 0.004 ms): touch/26378 read(fd: 3, buf: 0x7ffcb61eb1f0, count: 32                            ) = 32
     0.328 ([33m 0.010 ms[m): touch/26378 mmap(len: 1848896, prot: READ, flags: PRIVATE|DENYWRITE, fd: 3        ) = 0x7f89e6ccd000
     0.343 ([33m 0.019 ms[m): touch/26378 mprotect(start: 0x7f89e6cef000, len: 1671168                          ) = 0
     0.366 ([33m 0.017 ms[m): touch/26378 mmap(addr: 0x7f89e6cef000, len: 1355776, prot: EXEC|READ, flags: PRIVATE|FIXED|DENYWRITE, fd: 3, off: 139264) = 0x7f89e6cef000
     0.388 ([33m 0.010 ms[m): touch/26378 mmap(addr: 0x7f89e6e3a000, len: 311296, prot: READ, flags: PRIVATE|FIXED|DENYWRITE, fd: 3, off: 1495040) = 0x7f89e6e3a000
     0.402 ([33m 0.013 ms[m): touch/26378 mmap(addr: 0x7f89e6e87000, len: 24576, prot: READ|WRITE, flags: PRIVATE|FIXED|DENYWRITE, fd: 3, off: 1806336) = 0x7f89e6e87000
     0.427 ([33m 0.011 ms[m): touch/26378 mmap(addr: 0x7f89e6e8d000, len: 13888, prot: READ|WRITE, flags: PRIVATE|FIXED|ANONYMOUS) = 0x7f89e6e8d000
     0.455 ( 0.004 ms): touch/26378 close(fd: 3                                                           ) = 0
     0.557 ( 0.006 ms): touch/26378 arch_prctl(option: 4098, arg2: 140230261286272                        ) = 0
     0.691 ([33m 0.016 ms[m): touch/26378 mprotect(start: 0x7f89e6e87000, len: 16384, prot: READ                ) = 0
     0.760 ( 0.010 ms): touch/26378 mprotect(start: 0x55d62e37e000, len: 4096, prot: READ                 ) = 0
     0.781 ([33m 0.011 ms[m): touch/26378 mprotect(start: 0x7f89e6f08000, len: 4096, prot: READ                 ) = 0
     0.797 ([33m 0.029 ms[m): touch/26378 munmap(addr: 0x7f89e6e93000, len: 308934                              ) = 0
     1.004 ( 0.005 ms): touch/26378 brk(                                                                  ) = 0x55d62ec22000
     1.013 ( 0.008 ms): touch/26378 brk(brk: 0x55d62ec43000                                               ) = 0x55d62ec43000
     1.036 ([33m 0.011 ms[m): touch/26378 openat(dfd: CWD, filename: 0xe6e588a0, flags: CLOEXEC                 ) = 3
     1.052 ( 0.004 ms): touch/26378 fstat(fd: 3, statbuf: 0x7f89e6e8c920                                  ) = 0
     1.060 ([33m 0.011 ms[m): touch/26378 mmap(len: 6180864, prot: READ, flags: PRIVATE, fd: 3                  ) = 0x7f89e66e8000
     1.084 ( 0.004 ms): touch/26378 close(fd: 3                                                           ) = 0
     1.159 ([33m 0.011 ms[m): touch/26378 openat(dfd: CWD, filename: 0xb61ecea9, flags: CREAT|NOCTTY|NONBLOCK|WRONLY, mode: IRUGO|IWUGO) = 3
     1.175 ( 0.004 ms): touch/26378 dup2(oldfd: 3                                                         ) = 0
     1.183 ( 0.003 ms): touch/26378 close(fd: 3                                                           ) = 0
     1.190 ( 0.007 ms): touch/26378 utimensat(                                                            ) = 0
     1.200 ( 0.003 ms): touch/26378 close(                                                                ) = 0
     1.220 ( 0.004 ms): touch/26378 close(fd: 1                                                           ) = 0
     1.229 ( 0.003 ms): touch/26378 close(fd: 2                                                           ) = 0
     1.251 (         ): touch/26378 exit_group(                                                           )
#+END_SRC

*** I/O剖析
:PROPERTIES:
:interleave_page_note: 203
:END:

与CPU剖析作用类似，I/O剖析判断的是I/O相关的系统调用（比如read(),write()）执行的原因和方式。

比如下面dtrace命令跟踪PostgreSQL的read()系统调用，并收集用户级别的栈跟踪:
#+BEGIN_SRC shell
  dtrace -n 'syscall::read:entry /execname == "postgres"/ {@[ustack()] = count();}'
#+END_SRC

*** USE方法
:PROPERTIES:
:interleave_page_note: 204
:END:

USE方法通过检查资源的使用率，饱和度和发生的错误来判断某一资源是否成为瓶颈。

例如若系统为文件描述符设置了一个数量上限，则相应的指标为:

+ 使用率 :: 使用中文件描述符的数量，与系统设置上限的比率
+ 饱和度 :: 等待文件描述符分配的线程数
+ 错误 :: 分配失败，提示EFILE，打开太多文件。

*** 锁分析
:PROPERTIES:
:interleave_page_note: 205
:END:

对于多线程的应用程序，锁可能会成为阻碍并发和扩展性的瓶颈。

对于自旋锁来说，当锁出现竞争时，CPU使用率也会发生变化。
通过对CPU进行栈跟踪通常能识别出来。

*** 静态性能调优
:PROPERTIES:
:interleave_page_note: 208
:END:

静态性能调优是通过对程序运行环境的检查，看是否有优化的空间，例如:

+ 运行的程序是什么版本？是否有更新版本？发布说明是否提及性能提高
+ 应用程序有哪些已知的性能问题？有可供搜索的bug数据库吗？
+ 应用程序是怎么配置的？能通过调整配置优化速度吗？
+ 应用程序利用了缓存吗？缓存大小如何？
+ 应用程序是并发运行吗？线程池大小如何？
+ 应用程序是在调试模式下运行吗？
+ 应用程序用到了哪些程序库？他们的版本是什么？
+ 应用程序用的是怎样的内存分配器
+ 应用程序用大页面做堆吗？
+ 应用程序是编译的吗？编译器版本是什么？优化选项有哪些？
+ 应用程序遇到错误了吗？发生错误后会运行在降级模式吗？
+ 有没有系统资源方面的限制？

* CPU
:PROPERTIES:
:interleave_page_note: 212
:END:

正在排队和就绪运行的软件线程数量是一个很重要的性能指标，表示了CPU的饱和度。
花在等待CPU运行上的时间又被称为运行队列延时或者分发器队列延时。

对于多处理器系统，内核通常为每个CPU提供了一个运行队列，并尽量使每个线程每次都放在同一个队列。
这是因为CPU缓存中很可能保存了该线程的数据，同时在NUMA系统中，这会提高内存本地性，从而提高系统性能。
